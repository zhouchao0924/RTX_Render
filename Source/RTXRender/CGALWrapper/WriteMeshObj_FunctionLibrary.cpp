// Copyright© 2017 ihomefnt All Rights Reserved.


#include "WriteMeshObj_FunctionLibrary.h"
#include "PolygonAlg.h"
#include <fstream>
#include <iostream>
#include "VaRestJsonObject.h"
#include "VaRestJsonValue.h"
#include "Json.h"
#include "HomeLayout/HouseArchitect/WallBuildSystem.h"
#include "EditorGameInStance.h"
#include "Building/DRFunLibrary.h"

#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
#include <CGAL/Polygon_2.h>
#include "../Source/Runtime/Engine/Classes/Components/ActorComponent.h"
#include "../Source/Runtime/Engine/Classes/Components/PointLightComponent.h"
#include "../Source/Runtime/Engine/Classes/Engine/SpotLight.h"
#include "HomeLayout/SceneEntity/FurnitureModelActor.h"
#include "Misc/FileHelper.h"
#include "Data/DRProjData.h"
#include "Data/Adapter/DRSolidWallAdapter.h"
#include "HouseCustomActor.h"
#include "Kismet/GameplayStatics.h"

using K = CGAL::Exact_predicates_inexact_constructions_kernel;
using Point_2 = K::Point_2;
using Polygon_2 = CGAL::Polygon_2<K>;


bool UWriteMeshObj_FunctionLibrary::FromJsonToWriteObjFile(UObject* WorldContextObject, UVaRestJsonObject* InJson, const FString FilePath)
{
	TArray<FVector> AreaBoundaryPs;
	TArray<int> AreaPIndexVec;
	TArray<FVector> WallPoints;
	TArray<FString> AreaNames;
	if ((InJson == nullptr) || (*FilePath == NULL))
	{
		return false;
	}

	UVaRestJsonObject* ObjData = InJson->GetObjectField("objData");

	TArray<UVaRestJsonObject*> RoomJsonObj = ObjData->GetObjectArrayField("roomList");
	for (int Index = 0; Index < RoomJsonObj.Num(); Index++)
	{
		TArray<UVaRestJsonObject*> AreaCoorJson = RoomJsonObj[Index]->GetObjectArrayField("areas");
		int NumCount = 0;
		for (int AreaIndex = 0; AreaIndex < AreaCoorJson.Num(); AreaIndex++)
		{
			float TempX = AreaCoorJson[AreaIndex]->GetNumberField("x");
			float TempY = AreaCoorJson[AreaIndex]->GetNumberField("y");
			AreaBoundaryPs.Add(FVector(TempX, TempY, 0));
			NumCount++;
			FString TempRoomNameString = RoomJsonObj[Index]->GetStringField("roomName");
			AreaNames.Add(TempRoomNameString);

		}
		AreaPIndexVec.Add(NumCount);
	}

	TArray<UVaRestJsonObject*> WallJsonObj = ObjData->GetObjectArrayField("walls");
	for (int Index = 0; Index < WallJsonObj.Num(); Index++)
	{
		TArray<UVaRestJsonObject*> EachWallRegion = WallJsonObj[Index]->GetObjectArrayField("wallPoints");

		for (int WallIndex = 0; WallIndex < EachWallRegion.Num(); WallIndex++)
		{
			float TempX = EachWallRegion[WallIndex]->GetNumberField("x");
			float TempY = EachWallRegion[WallIndex]->GetNumberField("y");
			float TempZ = EachWallRegion[WallIndex]->GetNumberField("z");
			WallPoints.Add(FVector(TempX, TempY, TempZ));
		}
	}

	float WallHeight = 0.0;
	for (int Pindex = 0; Pindex < WallPoints.Num(); Pindex++)
	{
		if (WallPoints[Pindex].Z != 0)
		{
			WallHeight = WallPoints[Pindex].Z;
			break;
		}
	}


	int SolutionID = InJson->GetNumberField("solutionId");
	FString FileName = FString::FromInt(SolutionID);
	FString ObjFileName = FilePath + FileName + ".obj";
	std::ofstream OutFile(*ObjFileName);
	for (int Index = 0; Index < WallPoints.Num(); Index++)
	{
		OutFile << "v" << " " << WallPoints[Index].X << " " << WallPoints[Index].Y << " " << WallPoints[Index].Z << std::endl;

	}
	int EachWallNumV = 8;
	int FaceNum = WallPoints.Num() / EachWallNumV;
	for (int FaceId = 0; FaceId < FaceNum; FaceId++)
	{
		for (int Forder = 0; Forder < 6; Forder++)
		{
			if (Forder == 0)
			{
				OutFile << "f" << " " << 4 + FaceId * 8 << " " << 3 + FaceId * 8 << " " << 2 + FaceId * 8 << " " << 1 + FaceId * 8 << std::endl;
			}
			else if (Forder == 1)
			{
				OutFile << "f" << " " << 1 + FaceId * 8 << " " << 2 + FaceId * 8 << " " << 5 + FaceId * 8 << " " << 6 + FaceId * 8 << std::endl;
			}
			else if (Forder == 2)
			{
				OutFile << "f" << " " << 8 + FaceId * 8 << " " << 7 + FaceId * 8 << " " << 6 + FaceId * 8 << " " << 5 + FaceId * 8 << std::endl;
			}
			else if (Forder == 3)
			{
				OutFile << "f" << " " << 3 + FaceId * 8 << " " << 4 + FaceId * 8 << " " << 7 + FaceId * 8 << " " << 8 + FaceId * 8 << std::endl;
			}
			else if (Forder == 4)
			{
				OutFile << "f" << " " << 1 + FaceId * 8 << " " << 6 + FaceId * 8 << " " << 7 + FaceId * 8 << " " << 4 + FaceId * 8 << std::endl;
			}
			else if (Forder == 5)
			{
				OutFile << "f" << " " << 2 + FaceId * 8 << " " << 3 + FaceId * 8 << " " << 8 + FaceId * 8 << " " << 5 + FaceId * 8 << std::endl;
			}
		}
	}
	int NumWallPs = WallPoints.Num();
	for (int Index = 0; Index < AreaBoundaryPs.Num(); Index++)
	{
		OutFile << "v" << " " << AreaBoundaryPs[Index].X << " " << AreaBoundaryPs[Index].Y << " " << 0 << std::endl;
	}
	int NumCount = 0;
	int NumArray = AreaPIndexVec.Num();
	for (int FaceId = 1; FaceId <= NumArray; FaceId++)
	{
		OutFile << "f";

		if (FaceId == 1)
		{
			float VecX1 = AreaBoundaryPs[NumCount + 1].X - AreaBoundaryPs[NumCount].X;
			float VecY1 = AreaBoundaryPs[NumCount + 1].Y - AreaBoundaryPs[NumCount].Y;
			float VecZ1 = AreaBoundaryPs[NumCount + 1].Z - AreaBoundaryPs[NumCount].Z;

			float VecX2 = AreaBoundaryPs[NumCount + AreaPIndexVec[FaceId - 1] - 1].X - AreaBoundaryPs[NumCount].X;
			float VecY2 = AreaBoundaryPs[NumCount + AreaPIndexVec[FaceId - 1] - 1].Y - AreaBoundaryPs[NumCount].Y;
			float VecZ2 = AreaBoundaryPs[NumCount + AreaPIndexVec[FaceId - 1] - 1].Z - AreaBoundaryPs[NumCount].Z;

			float CrossResX = VecY1 * VecZ2 - VecZ1 * VecY2;
			float CrossResY = VecZ1 * VecX2 - VecX1 * VecZ2;
			float CrossResZ = VecX1 * VecY2 - VecY1 * VecX2;
			if (CrossResZ < 0)
			{
				for (int Forder = AreaPIndexVec[FaceId - 1]; Forder >= 1; Forder--)
				{
					OutFile << " " << NumWallPs + Forder << " ";
				}
				int NumVec = AreaPIndexVec[FaceId - 1];
				for (int Jindex = 0; Jindex < NumVec / 2; Jindex++)
				{
					FVector TempVec = AreaBoundaryPs[Jindex];
					AreaBoundaryPs[Jindex] = AreaBoundaryPs[NumVec - 1 - Jindex];
					AreaBoundaryPs[NumVec - 1 - Jindex] = TempVec;
				}
			}
			else
			{
				for (int Forder = 1; Forder <= AreaPIndexVec[FaceId - 1]; Forder++)
				{

					OutFile << " " << NumWallPs + Forder << " ";
				}
			}

			NumCount = AreaPIndexVec[0];
		}
		else if (FaceId != 1)
		{
			float VecX1 = AreaBoundaryPs[NumCount + 1].X - AreaBoundaryPs[NumCount].X;
			float VecY1 = AreaBoundaryPs[NumCount + 1].Y - AreaBoundaryPs[NumCount].Y;
			float VecZ1 = AreaBoundaryPs[NumCount + 1].Z - AreaBoundaryPs[NumCount].Z;

			float VecX2 = AreaBoundaryPs[NumCount + AreaPIndexVec[FaceId - 1] - 1].X - AreaBoundaryPs[NumCount].X;
			float VecY2 = AreaBoundaryPs[NumCount + AreaPIndexVec[FaceId - 1] - 1].Y - AreaBoundaryPs[NumCount].Y;
			float VecZ2 = AreaBoundaryPs[NumCount + AreaPIndexVec[FaceId - 1] - 1].Z - AreaBoundaryPs[NumCount].Z;

			float CrossResX = VecY1 * VecZ2 - VecZ1 * VecY2;
			float CrossResY = VecZ1 * VecX2 - VecX1 * VecZ2;
			float CrossResZ = VecX1 * VecY2 - VecY1 * VecX2;
			if (CrossResZ < 0)
			{
				for (int Forder = AreaPIndexVec[FaceId - 1]; Forder >= 1; Forder--)
				{
					OutFile << " " << NumWallPs + NumCount + Forder << " ";
				}
				int NumVec = AreaPIndexVec[FaceId - 1];
				for (int Jindex = 0; Jindex < NumVec / 2; Jindex++)
				{
					FVector TempVec = AreaBoundaryPs[NumCount + Jindex];
					AreaBoundaryPs[NumCount + Jindex] = AreaBoundaryPs[NumCount + NumVec - 1 - Jindex];
					AreaBoundaryPs[NumCount + NumVec - 1 - Jindex] = TempVec;
				}
			}
			else
			{
				for (int Forder = 1; Forder <= AreaPIndexVec[FaceId - 1]; Forder++)
				{
					OutFile << " " << NumWallPs + NumCount + Forder << " ";
				}
			}

			NumCount = NumCount + AreaPIndexVec[FaceId - 1];
		}

		OutFile << std::endl;
	}

	OutFile.close();

	return true;
}



bool  UWriteMeshObj_FunctionLibrary::PolygonTriangulate(const TArray<FVector2D> InPnts, TArray<int>&TriIndexs)
{
	if (InPnts.Num() < 3)
	{
		return false;
	}
	TArray<FVector2D> PostPoints;
	for (int _CurP = 0; _CurP < InPnts.Num(); ++_CurP)
	{
		PostPoints.AddUnique(InPnts[_CurP]);
	}
	if (InPnts.Num() != PostPoints.Num())
	{
		return false;
	}
	FPolygonAlg::PolygonTriangulate(InPnts, TriIndexs);
	if (TriIndexs.Num() < 3)
	{
		return false;
	}
	return true;
}


bool  UWriteMeshObj_FunctionLibrary::GetHouseRoomIDs(UObject* WorldContextObject, UVaRestJsonObject* InJson, TArray<int>& AllRoomIDs)
{
	if (InJson == nullptr)
	{
		return false;
	}
	int SolutionID = 0;
	SolutionID = InJson->GetNumberField("solutionId");
	TArray<UVaRestJsonObject*> RoomJsonObj = InJson->GetObjectArrayField("roomList");
	for (int RoomIndex = 0; RoomIndex < RoomJsonObj.Num(); RoomIndex++)
	{
		int RoomId = RoomJsonObj[RoomIndex]->GetNumberField("roomId");
		AllRoomIDs.Add(RoomId);
	}
	if (AllRoomIDs.Num() == 0)
	{
		return false;
	}
	return true;
}


bool  UWriteMeshObj_FunctionLibrary::GetWallsOfRoom(UObject* WorldContextObject, const int RoomID, TArray<ALineWallActor *> &WallsOfRegion)
{
	UWorld* MyWorld = WorldContextObject->GetWorld();
	UCEditorGameInstance *GameInstance = Cast<UCEditorGameInstance>(MyWorld->GetGameInstance());
	UWallBuildSystem *WallBuildSystem = GameInstance->WallBuildSystem;


	if (WallBuildSystem != nullptr)
	{
		ARoomActor* TempRoomActor = WallBuildSystem->FindRoomByRoomID(RoomID);
		if (TempRoomActor != nullptr)
		{
			FRoomBindInfo TempRoomBuildInfo = UDRFunLibrary::GetDesignationRoomBindInfo(WorldContextObject, TempRoomActor);
			TArray<FWallBindInfo> TempWalls = TempRoomBuildInfo.Walls;
			TArray<ALineWallActor *> TempWallLines;
			for (int I = 0; I < TempWalls.Num(); ++I)
			{
				TempWallLines.AddUnique(TempWalls[I].Wall);
			}
			if (TempWallLines.Num() == 0)
			{
				return false;
			}
			WallsOfRegion = TempWallLines;
		}
	}
	else
	{
		return false;
	}

	return true;
}

bool UWriteMeshObj_FunctionLibrary::GetDoorsOfRegion(UObject* WorldContextObject, const int RoomID, TArray<FVector>&DoorPoints)
{
	TArray<ALineWallActor *> WallsOfRegion;
	bool IsSuccess = GetWallsOfRoom(WorldContextObject, RoomID, WallsOfRegion);
	if (!IsSuccess)
	{
		return false;
	}

	TArray<AWall_Boolean_Base*> DoorOrGroundWindowOnWall;
	for (ALineWallActor* WallActor : WallsOfRegion)
	{
		UDRProjData* projectDataManager = UDRProjData::GetProjectDataManager(WallActor);
		if (projectDataManager == nullptr) {
			continue;
		}

		UDRSolidWallAdapter* solidWallAdapter = Cast<UDRSolidWallAdapter>(projectDataManager->GetAdapter(WallActor->ObjectId));
		if (solidWallAdapter == nullptr) {
			continue;
		}

		TArray<AWall_Boolean_Base*> TempBoolean = WallActor->GetOpeningsOnWall();
		FVector2D PStartPos(solidWallAdapter->GetWallPositionData().LeftStartPos.X, solidWallAdapter->GetWallPositionData().LeftStartPos.Y);
		FVector2D PEndPos(solidWallAdapter->GetWallPositionData().LeftEndPos.X, solidWallAdapter->GetWallPositionData().LeftEndPos.Y);
		FVector2D WallVec = PEndPos - PStartPos;
		WallVec.Normalize();
		FVector2D OutVec = WallVec.GetRotated(90);

		FVector2D wallLeftStart(solidWallAdapter->GetWallPositionData().LeftStartPos.X, solidWallAdapter->GetWallPositionData().LeftStartPos.Y);
		FVector2D wallRightStart(solidWallAdapter->GetWallPositionData().RightStartPos.X, solidWallAdapter->GetWallPositionData().RightStartPos.Y);
		FVector2D wallLeftEnd(solidWallAdapter->GetWallPositionData().LeftEndPos.X, solidWallAdapter->GetWallPositionData().LeftEndPos.Y);
		FVector2D wallRightEnd(solidWallAdapter->GetWallPositionData().RightEndPos.X, solidWallAdapter->GetWallPositionData().RightEndPos.Y);

		FVector2D WallStandCenter = 0.25*(wallLeftStart + wallRightStart + wallLeftEnd + wallRightEnd);

		for (int I = 0; I < TempBoolean.Num(); I++)
		{
			FOpeningSimpleAttr FOpenAttr = TempBoolean[I]->GetOpeningSimpleAttr();
			if ((FOpenAttr.Type == EOpeningType::DoorWay) || (FOpenAttr.Type == EOpeningType::SingleDoor)
				|| (FOpenAttr.Type == EOpeningType::DoubleDoor) || (FOpenAttr.Type == EOpeningType::SlidingDoor))
			{
				FVector2D TempLocation = FOpenAttr.Location;
				float DoorHeight = FOpenAttr.Height;
				float TempLeftWidth = FOpenAttr.LeftWidth;
				float TempRightWidth = FOpenAttr.RightWidth;
				float TempWallLeftThick = 0.f;
				float TempWallRighThick = 0.f;
				if (WallActor->WallComp3d)
				{
					TempWallLeftThick = WallActor->WallComp3d->Data->GetFloat(TEXT("ThickLeft"));
					TempWallRighThick = WallActor->WallComp3d->Data->GetFloat(TEXT("ThickRight"));
				}

				FVector2D PStartLeft = TempLocation - TempLeftWidth * WallVec + OutVec * TempWallLeftThick;
				FVector2D PEndLeft = TempLocation + TempRightWidth * WallVec + OutVec * TempWallLeftThick;
				FVector2D PStartRight = TempLocation - TempLeftWidth * WallVec - OutVec * TempWallRighThick;
				FVector2D PEndRight = TempLocation + TempRightWidth * WallVec - OutVec * TempWallRighThick;

				FVector2D TempCenter = 0.25*(PStartLeft + PStartRight + PEndLeft + PEndRight);
				FVector2D DoorCenterToWallStartPos = WallStandCenter - TempCenter;
				float VecCross = FVector2D::DotProduct(DoorCenterToWallStartPos, OutVec);
				PStartLeft = PStartLeft + VecCross * OutVec;
				PEndLeft = PEndLeft + VecCross * OutVec;
				PStartRight = PStartRight + VecCross * OutVec;
				PEndRight = PEndRight + VecCross * OutVec;

				FVector PStartLeft_Up = FVector(PStartLeft, DoorHeight);
				FVector PEndLeft_Up = FVector(PEndLeft, DoorHeight);
				FVector PStartRight_Up = FVector(PStartRight, DoorHeight);
				FVector PEndRight_Up = FVector(PEndRight, DoorHeight);
				DoorPoints.Add(FVector(PStartLeft, 0.0));
				DoorPoints.Add(FVector(PEndLeft, 0.0));
				DoorPoints.Add(FVector(PStartRight, 0.0));
				DoorPoints.Add(FVector(PEndRight, 0.0));

				DoorPoints.Add(PStartLeft_Up);
				DoorPoints.Add(PEndLeft_Up);
				DoorPoints.Add(PStartRight_Up);
				DoorPoints.Add(PEndRight_Up);

			}


		}
	}
	if (DoorPoints.Num() == 0)
	{
		return false;
	}
	return true;
}


bool UWriteMeshObj_FunctionLibrary::CreateAdvancedLocationJsonWithFloors(UObject* WorldContextObject, UVaRestJsonObject* InJson, UVaRestJsonObject* &LocationJson,
	TArray<FVector2D>& CameraLocations, int& NumOfTotalPickPs, TMap<int, FloorGroup>&GroupRoomIDs)
{
	if (InJson == nullptr)
	{
		return false;
	}

	TArray<UVaRestJsonObject*> WallJsonObj = InJson->GetObjectArrayField("walls");
	TArray<Polygon_2> WallPolygon;
	TArray<FVector2D> WallCenters;
	TMap<int, TArray<FVector2D>> IndexMapWallPs;
	for (int Index = 0; Index < WallJsonObj.Num(); Index++)
		for (int Index = 0; Index < WallJsonObj.Num(); Index++)
		{
			TArray<FVector2D> WallRegionPoints;
			TArray<UVaRestJsonObject*> EachWallRegion = WallJsonObj[Index]->GetObjectArrayField("wallPoints");

			for (int WallIndex = 0; WallIndex < EachWallRegion.Num(); WallIndex++)
			{
				float TempX = EachWallRegion[WallIndex]->GetNumberField("x");
				float TempY = EachWallRegion[WallIndex]->GetNumberField("y");
				WallRegionPoints.Add(FVector2D(TempX, TempY));
			}
			Polygon_2 TempWallPolygon;
			float WallCenterX = 0.0, WallCenterY = 0.0;
			for (int PIndex = 0; PIndex < 4; PIndex++)
			{
				TempWallPolygon.push_back(Point_2(WallRegionPoints[PIndex].X, WallRegionPoints[PIndex].Y));
				WallCenterX = WallCenterX + WallRegionPoints[PIndex].X;
				WallCenterY = WallCenterY + WallRegionPoints[PIndex].Y;
			}
			IndexMapWallPs.Add(Index, WallRegionPoints);
			WallCenterX = WallCenterX / 4;
			WallCenterY = WallCenterY / 4;
			WallCenters.Add(FVector2D(WallCenterX, WallCenterY));
			WallPolygon.Add(TempWallPolygon);
			TempWallPolygon.clear();
		}

	TArray<FVector2D> SmallRegionCenters, NewSmallRegionCenters, ThirdDiningSmallCenters, FourthDiningSmallCenters;
	TMap<int, FVector2D> RoomIDMapToiletSmallCenter;
	TArray<FString> RoomNameSet, RoomUsageNameSet;
	TArray<int> RoomIDs;
	TArray<float> UsageIDs;
	TArray<float> IDs;
	TArray<UVaRestJsonObject*> RoomJsonObj = InJson->GetObjectArrayField("roomList");

	TMap<int, TArray<FVector2D>> IndexMapRoomPs;
	TMap<FVector2D, TArray<FVector2D>> PointMapLocalRegion;
	TMap<int, TArray<FVector2D>> RoomIdMapSmallCenters;

	TMap<int, TArray<int>> RoomIDMapToRemoveIndexs;

	for (int Index = 0; Index < RoomJsonObj.Num(); Index++)
	{
		TArray<FVector2D> AreaPoints;
		FVector2D SuitableCenter;
		TArray<UVaRestJsonObject*> AreaCoorJson = RoomJsonObj[Index]->GetObjectArrayField("areas");

		FString TempRoomNameString = RoomJsonObj[Index]->GetStringField("roomName");
		RoomNameSet.Add(TempRoomNameString);

		int TempRoomID = RoomJsonObj[Index]->GetIntegerField("roomId");
		RoomIDs.Add(TempRoomID);

		FString TempRoomUseString = RoomJsonObj[Index]->GetStringField("roomUsageName");
		RoomUsageNameSet.Add(TempRoomUseString);

		float TempUsageID = RoomJsonObj[Index]->GetNumberField("usageId");
		UsageIDs.Add(TempUsageID);

		IDs.Add(Index + 1);

		for (int AreaIndex = 0; AreaIndex < AreaCoorJson.Num(); AreaIndex++)
		{
			float TempX = AreaCoorJson[AreaIndex]->GetNumberField("x");
			float TempY = AreaCoorJson[AreaIndex]->GetNumberField("y");
			AreaPoints.AddUnique(FVector2D(TempX, TempY));
		}


		float VecX1 = AreaPoints[1].X - AreaPoints[0].X;
		float VecY1 = AreaPoints[1].Y - AreaPoints[0].Y;

		float VecX2 = AreaPoints[AreaPoints.Num() - 1].X;
		float VecY2 = AreaPoints[AreaPoints.Num() - 1].Y;
		float CrossResZ = VecX1 * VecY2 - VecY1 * VecX2;
		if (CrossResZ < 0)
		{
			for (int Jindex = 0; Jindex < AreaPoints.Num() / 2; Jindex++)
			{
				FVector2D TempVec = AreaPoints[Jindex];
				AreaPoints[Jindex] = AreaPoints[AreaPoints.Num() - 1 - Jindex];
				AreaPoints[AreaPoints.Num() - 1 - Jindex] = TempVec;
			}
		}

		FString LocalRoomName = RoomJsonObj[Index]->GetStringField("roomName");


		if ((LocalRoomName == TEXT("客厅")) || (LocalRoomName == TEXT("起居室")))
		{
			TMap<FVector2D, TArray<FVector2D>> TempCenterMapLocalRegions;
			bool IsSuccess = FPolygonAlg::LocateCentersOfDiningOrLivingRegion(AreaPoints, SuitableCenter, SmallRegionCenters, TempCenterMapLocalRegions);
			if (!IsSuccess)
			{
				return false;
			}
			CameraLocations.Add(SuitableCenter);

			if (TempCenterMapLocalRegions.Contains(SuitableCenter))
			{
				PointMapLocalRegion.Add(SuitableCenter, TempCenterMapLocalRegions[SuitableCenter]);
			}
			TArray<AFurnitureModelActor*> ModelsOfRoom;
			FindModelsOfRoom(WorldContextObject, AreaPoints, ModelsOfRoom);
			TArray<int> TempToRemoveIndexs;
			for (int _CurP = 0; _CurP < SmallRegionCenters.Num(); ++_CurP)
			{
				for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
				{
					FBox TempBox = ModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
					bool IfInModel = TempBox.IsInsideOrOn(FVector(SmallRegionCenters[_CurP], 130));
					if (IfInModel)
					{
						FVector FMin = TempBox.Min;
						FVector FMax = TempBox.Max;
						bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
						if (ModelBoxIsUseful)
						{
							TempToRemoveIndexs.AddUnique(_CurP);
						}
					}
				}
			}
			RoomIDMapToRemoveIndexs.Add(TempRoomID, TempToRemoveIndexs);
			for (int _CurF = 0; _CurF < SmallRegionCenters.Num(); ++_CurF)
			{
				if (!TempToRemoveIndexs.Contains(_CurF))
				{
					if (TempCenterMapLocalRegions.Contains(SmallRegionCenters[_CurF]))
					{
						PointMapLocalRegion.Add(SmallRegionCenters[_CurF], TempCenterMapLocalRegions[SmallRegionCenters[_CurF]]);
					}
				}
			}
			NumOfTotalPickPs = NumOfTotalPickPs + SmallRegionCenters.Num() - TempToRemoveIndexs.Num();
		}
		else if (LocalRoomName == TEXT("餐厅"))
		{
			TMap<FVector2D, TArray<FVector2D>> TempCenterMapLocalRegions;
			bool IsSuccess = FPolygonAlg::LocateCentersOfDiningOrLivingRegion(AreaPoints, SuitableCenter, NewSmallRegionCenters, TempCenterMapLocalRegions);
			if (!IsSuccess)
			{
				return false;
			}
			CameraLocations.Add(SuitableCenter);

			if (TempCenterMapLocalRegions.Contains(SuitableCenter))
			{
				PointMapLocalRegion.Add(SuitableCenter, TempCenterMapLocalRegions[SuitableCenter]);
			}

			TArray<AFurnitureModelActor*> ModelsOfRoom;
			FindModelsOfRoom(WorldContextObject, AreaPoints, ModelsOfRoom);
			TArray<int> TempToRemoveIndexs;
			for (int _CurP = 0; _CurP < NewSmallRegionCenters.Num(); ++_CurP)
			{
				for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
				{
					FBox TempBox = ModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
					bool IfInModel = TempBox.IsInsideOrOn(FVector(NewSmallRegionCenters[_CurP], 130));
					if (IfInModel)
					{
						FVector FMin = TempBox.Min;
						FVector FMax = TempBox.Max;
						bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
						if (ModelBoxIsUseful)
						{
							TempToRemoveIndexs.AddUnique(_CurP);
						}
					}
				}
			}
			RoomIDMapToRemoveIndexs.Add(TempRoomID, TempToRemoveIndexs);
			for (int _CurF = 0; _CurF < NewSmallRegionCenters.Num(); ++_CurF)
			{
				if (!TempToRemoveIndexs.Contains(_CurF))
				{
					if (TempCenterMapLocalRegions.Contains(NewSmallRegionCenters[_CurF]))
					{
						PointMapLocalRegion.Add(NewSmallRegionCenters[_CurF], TempCenterMapLocalRegions[NewSmallRegionCenters[_CurF]]);
					}
				}
			}
			NumOfTotalPickPs = NumOfTotalPickPs + NewSmallRegionCenters.Num() - TempToRemoveIndexs.Num();
		}
		else if ((LocalRoomName == TEXT("主卧")) || (LocalRoomName == TEXT("次卧")) || (LocalRoomName == TEXT("儿童房")) || (LocalRoomName == TEXT("老人房"))
			|| (LocalRoomName == TEXT("榻榻米房")) || (LocalRoomName == TEXT("客人房")) || (LocalRoomName == TEXT("书房")) || (LocalRoomName == TEXT("健身房"))
			|| (LocalRoomName == TEXT("多功能房")))
		{
			TArray<FVector2D> TempSmallCenters;
			TMap<FVector2D, TArray<FVector2D>> TempCenterMapLocalRegions;
			bool IsCreated = FPolygonAlg::LocateCentersOfRoom(AreaPoints, SuitableCenter, TempSmallCenters, TempCenterMapLocalRegions);
			if (!IsCreated)
			{
				return false;
			}
			RoomIdMapSmallCenters.Add(TempRoomID, TempSmallCenters);
			CameraLocations.Add(SuitableCenter);

			if (TempCenterMapLocalRegions.Contains(SuitableCenter))
			{
				PointMapLocalRegion.Add(SuitableCenter, TempCenterMapLocalRegions[SuitableCenter]);
			}


			TArray<AFurnitureModelActor*> ModelsOfRoom;
			FindModelsOfRoom(WorldContextObject, AreaPoints, ModelsOfRoom);
			TArray<int> ToRemoveSmallIndexs;
			for (int _CurP = 0; _CurP < TempSmallCenters.Num(); ++_CurP)
			{
				for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
				{
					FBox TempBox = ModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
					bool IfInModel = TempBox.IsInsideOrOn(FVector(TempSmallCenters[_CurP], 130));
					if (IfInModel)
					{
						FVector FMin = TempBox.Min;
						FVector FMax = TempBox.Max;
						bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
						if (ModelBoxIsUseful)
						{
							ToRemoveSmallIndexs.AddUnique(_CurP);
						}
					}
				}
			}
			RoomIDMapToRemoveIndexs.Add(TempRoomID, ToRemoveSmallIndexs);
			for (int _CurF = 0; _CurF < TempSmallCenters.Num(); ++_CurF)
			{
				if (!ToRemoveSmallIndexs.Contains(_CurF))
				{
					PointMapLocalRegion.Add(TempSmallCenters[_CurF], TempCenterMapLocalRegions[TempSmallCenters[_CurF]]);
				}
			}
			NumOfTotalPickPs = NumOfTotalPickPs + TempSmallCenters.Num() - ToRemoveSmallIndexs.Num();
		}
		else if ((LocalRoomName == TEXT("主阳台")) || (LocalRoomName == TEXT("生活阳台")) || (LocalRoomName == TEXT("休闲阳台")) || (LocalRoomName == TEXT("卧室阳台")))
		{
			TArray<FVector2D> TempSmallCenters;
			TMap<FVector2D, TArray<FVector2D>> TempCenterMapLocalRegions;
			bool IsCreated = FPolygonAlg::LocateCentersOfBalcony(AreaPoints, SuitableCenter, TempSmallCenters, TempCenterMapLocalRegions);
			if (!IsCreated)
			{
				return false;
			}
			RoomIdMapSmallCenters.Add(TempRoomID, TempSmallCenters);
			CameraLocations.Add(SuitableCenter);

			if (TempCenterMapLocalRegions.Contains(SuitableCenter))
			{
				PointMapLocalRegion.Add(SuitableCenter, TempCenterMapLocalRegions[SuitableCenter]);
			}
			TArray<AFurnitureModelActor*> ModelsOfRoom;
			FindModelsOfRoom(WorldContextObject, AreaPoints, ModelsOfRoom);
			TArray<int> ToRemoveSmallIndexs;
			for (int _CurP = 0; _CurP < TempSmallCenters.Num(); ++_CurP)
			{
				for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
				{
					FBox TempBox = ModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
					bool IfInModel = TempBox.IsInsideOrOn(FVector(TempSmallCenters[_CurP], 130));
					if (IfInModel)
					{
						FVector FMin = TempBox.Min;
						FVector FMax = TempBox.Max;
						bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
						if (ModelBoxIsUseful)
						{
							ToRemoveSmallIndexs.AddUnique(_CurP);
						}
					}
				}
			}
			RoomIDMapToRemoveIndexs.Add(TempRoomID, ToRemoveSmallIndexs);
			for (int _CurF = 0; _CurF < TempSmallCenters.Num(); ++_CurF)
			{
				if (!ToRemoveSmallIndexs.Contains(_CurF))
				{
					PointMapLocalRegion.Add(TempSmallCenters[_CurF], TempCenterMapLocalRegions[TempSmallCenters[_CurF]]);
				}
			}
			NumOfTotalPickPs = NumOfTotalPickPs + TempSmallCenters.Num() - ToRemoveSmallIndexs.Num();
		}
		else if (LocalRoomName == TEXT("厨房"))
		{
			bool IsCreated = FPolygonAlg::LocateCenterOfKitchen(AreaPoints, SuitableCenter);
			if (!IsCreated)
			{
				return false;
			}
			bool IsUnUseful = false;
			TArray<AFurnitureModelActor*> TempModelsOfRoom;
			FindModelsOfRoom(WorldContextObject, AreaPoints, TempModelsOfRoom);
			for (int _CurM = 0; _CurM < TempModelsOfRoom.Num(); ++_CurM)
			{
				AFurnitureModelActor* TempFur = TempModelsOfRoom[_CurM];
				FBox TempBox = TempFur->GetComponentsBoundingBox(true);
				bool IsInModel = TempBox.IsInside(FVector(SuitableCenter, 130));
				if (IsInModel)
				{
					FVector FMin = TempBox.Min;
					FVector FMax = TempBox.Max;
					bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
					if (!ModelBoxIsUseful)
					{
						IsUnUseful = true;
					}
				}
			}
			if (!IsUnUseful)
			{
				PointMapLocalRegion.Add(SuitableCenter, AreaPoints);
				CameraLocations.Add(SuitableCenter);
			}
			else
			{
				TArray<FVector>DoorPoints;
				bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomID, DoorPoints);
				if (!GetDoorSuccess)
				{
					PointMapLocalRegion.Add(SuitableCenter, AreaPoints);
					CameraLocations.Add(SuitableCenter);
				}
				else
				{
					TMap<int, TArray<FVector>> RoomIDMapHoleData;
					int NumOfDoors = DoorPoints.Num() / 8;
					RoomIDMapHoleData.Add(TempRoomID, DoorPoints);
					if (NumOfDoors >= 1)
					{
						FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
						FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
						DirVec = DirVec.GetSafeNormal();
						DirVec = DirVec.GetRotated(90);
						FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
						FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
						FVector2D TempVec1 = DoorCenter2D + 45 * DirVec;
						if (FPolygonAlg::JudgePointInPolygon(AreaPoints, TempVec1))
						{
							PointMapLocalRegion.Add(TempVec1, AreaPoints);
							CameraLocations.Add(TempVec1);
						}
						else
						{
							FVector2D TempP = DoorCenter2D - 45 * DirVec;
							if (FPolygonAlg::JudgePointInPolygon(AreaPoints, TempP))
							{
								PointMapLocalRegion.Add(TempP, AreaPoints);
								CameraLocations.Add(TempP);
							}
							else
							{
								PointMapLocalRegion.Add(SuitableCenter, AreaPoints);
								CameraLocations.Add(SuitableCenter);
							}
						}
					}
				}
			}

		}
		else if ((LocalRoomName == TEXT("主卫")) || (LocalRoomName == TEXT("客卫")) || (LocalRoomName == TEXT("卫生间")))
		{
			bool FindWall = false;
			int TargetIndex = 0;
			for (int _CurIndex = 0; _CurIndex < WallCenters.Num(); ++_CurIndex)
			{
				bool JudgeIfInRegion = FPolygonAlg::JudgePointInPolygon(AreaPoints, WallCenters[_CurIndex]);
				if (JudgeIfInRegion)
				{
					FindWall = true;
					TargetIndex = _CurIndex;
					break;
				}
			}

			if (FindWall)
			{
				TArray<int> LocalRemoveIndexs;
				TArray<FVector2D> PickCenters;
				TArray<FVector2D> WallPoints = IndexMapWallPs[TargetIndex];
				bool LocateSuccess = FPolygonAlg::LocateCentersOfSecondToilet(AreaPoints, WallPoints, PickCenters);
				if (LocateSuccess)
				{
					PointMapLocalRegion.Add(PickCenters[0], AreaPoints);
					PointMapLocalRegion.Add(PickCenters[1], AreaPoints);
					CameraLocations.Add(PickCenters[0]);
					RoomIDMapToiletSmallCenter.Add(TempRoomID, PickCenters[1]);
					NumOfTotalPickPs = NumOfTotalPickPs + 1;
				}
			}
			else
			{
				FVector2D TempLocateCenter;
				bool IsSuccess = FPolygonAlg::LocateCenterOfOneToilet(AreaPoints, TempLocateCenter);
				if (IsSuccess)
				{
					PointMapLocalRegion.Add(TempLocateCenter, AreaPoints);
					CameraLocations.Add(TempLocateCenter);
				}
			}
		}
		else if (LocalRoomName == TEXT("储藏间"))
		{
			FVector2D TempLoc;
			bool HasFound = FPolygonAlg::LocateSuitableCenter(AreaPoints, TempLoc);
			if (HasFound)
			{
				bool IsUnUseful = false;
				TArray<AFurnitureModelActor*> TempModelsOfRoom;
				FindModelsOfRoom(WorldContextObject, AreaPoints, TempModelsOfRoom);
				for (int _CurM = 0; _CurM < TempModelsOfRoom.Num(); ++_CurM)
				{
					AFurnitureModelActor* TempFur = TempModelsOfRoom[_CurM];
					FBox TempBox = TempFur->GetComponentsBoundingBox(true);
					bool IsInModel = TempBox.IsInside(FVector(TempLoc, 130));
					if (IsInModel)
					{
						IsUnUseful = true;
						break;
					}
				}
				if (!IsUnUseful)
				{
					PointMapLocalRegion.Add(TempLoc, AreaPoints);
					CameraLocations.Add(TempLoc);
				}
				else
				{
					TArray<FVector>DoorPoints;
					bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomID, DoorPoints);
					if (!GetDoorSuccess)
					{
						PointMapLocalRegion.Add(TempLoc, AreaPoints);
						CameraLocations.Add(TempLoc);
					}
					else
					{
						TMap<int, TArray<FVector>> RoomIDMapHoleData;
						int NumOfDoors = DoorPoints.Num() / 8;
						RoomIDMapHoleData.Add(TempRoomID, DoorPoints);
						if (NumOfDoors >= 1)
						{
							FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
							FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
							DirVec = DirVec.GetSafeNormal();
							DirVec = DirVec.GetRotated(90);
							FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
							FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
							FVector2D TempVec1 = DoorCenter2D + 22 * DirVec;
							if (FPolygonAlg::JudgePointInPolygon(AreaPoints, TempVec1))
							{
								PointMapLocalRegion.Add(TempVec1, AreaPoints);
								CameraLocations.Add(TempVec1);
							}
							else
							{
								FVector2D TempP = DoorCenter2D - 22 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(AreaPoints, TempP))
								{
									PointMapLocalRegion.Add(TempP, AreaPoints);
									CameraLocations.Add(TempP);
								}
								else
								{
									PointMapLocalRegion.Add(TempLoc, AreaPoints);
									CameraLocations.Add(TempLoc);
								}
							}
						}
					}
				}
			}
		}
		else if ((LocalRoomName == TEXT("衣帽间")) || (LocalRoomName == TEXT("茶室")))
		{
			FVector2D TempLoc;
			bool HasFound = FPolygonAlg::LocateSuitableCenter(AreaPoints, TempLoc);
			if (HasFound)
			{
				bool IsUnUseful = false;
				TArray<AFurnitureModelActor*> TempModelsOfRoom;
				FindModelsOfRoom(WorldContextObject, AreaPoints, TempModelsOfRoom);
				for (int _CurM = 0; _CurM < TempModelsOfRoom.Num(); ++_CurM)
				{
					AFurnitureModelActor* TempFur = TempModelsOfRoom[_CurM];
					FBox TempBox = TempFur->GetComponentsBoundingBox(true);
					bool IsInModel = TempBox.IsInside(FVector(TempLoc, 130));
					if (IsInModel)
					{
						IsUnUseful = true;
						break;
					}
				}
				if (!IsUnUseful)
				{
					PointMapLocalRegion.Add(TempLoc, AreaPoints);
					CameraLocations.Add(TempLoc);
				}
				else
				{
					TArray<FVector>DoorPoints;
					bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomID, DoorPoints);
					if (!GetDoorSuccess)
					{
						PointMapLocalRegion.Add(TempLoc, AreaPoints);
						CameraLocations.Add(TempLoc);
					}
					else
					{
						TMap<int, TArray<FVector>> RoomIDMapHoleData;
						int NumOfDoors = DoorPoints.Num() / 8;
						RoomIDMapHoleData.Add(TempRoomID, DoorPoints);
						if (NumOfDoors >= 1)
						{
							FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
							FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
							DirVec = DirVec.GetSafeNormal();
							DirVec = DirVec.GetRotated(90);
							FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
							FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
							FVector2D TempVec1 = DoorCenter2D + 40 * DirVec;
							if (FPolygonAlg::JudgePointInPolygon(AreaPoints, TempVec1))
							{
								PointMapLocalRegion.Add(TempVec1, AreaPoints);
								CameraLocations.Add(TempVec1);
							}
							else
							{
								FVector2D TempP = DoorCenter2D - 40 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(AreaPoints, TempP))
								{
									PointMapLocalRegion.Add(TempP, AreaPoints);
									CameraLocations.Add(TempP);
								}
								else
								{
									PointMapLocalRegion.Add(TempLoc, AreaPoints);
									CameraLocations.Add(TempLoc);
								}
							}
						}
					}
				}
			}
		}
		else
		{
			bool IsCreated = FPolygonAlg::LocateSuitableCenter(AreaPoints, SuitableCenter);
			if (!IsCreated)
			{
				return false;
			}
			PointMapLocalRegion.Add(SuitableCenter, AreaPoints);
			CameraLocations.Add(SuitableCenter);
		}
	}
	NumOfTotalPickPs = NumOfTotalPickPs + CameraLocations.Num();

	if (!LocationJson)
		LocationJson = UVaRestJsonObject::ConstructJsonObject(WorldContextObject);


	float WallHeight = 0.0;
	TArray<UVaRestJsonObject*> WallArray = InJson->GetObjectArrayField("walls");
	for (int Index = 0; Index < WallArray.Num(); Index++)
	{
		TArray<FVector2D> AreaPoints;
		FVector2D SuitableCenter;
		TArray<UVaRestJsonObject*> WallCoorJson = WallArray[Index]->GetObjectArrayField("wallPoints");
		for (int WallIndex = 0; WallIndex < WallCoorJson.Num(); WallIndex++)
		{
			float TempZ = WallCoorJson[WallIndex]->GetNumberField("z");
			if (TempZ != 0)
			{
				WallHeight = TempZ;
				break;
			}
		}
	}

	int AreaNum = CameraLocations.Num();
	TArray<UVaRestJsonObject*> CameraPointArray;
	for (int Index = 0; Index < AreaNum; Index++)
	{
		UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

		UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
		SinglePointObj->SetNumberField("x", CameraLocations[Index].X);
		SinglePointObj->SetNumberField("y", CameraLocations[Index].Y);
		SinglePointObj->SetNumberField("z", 130);

		TArray<UVaRestJsonObject*> PointObjArrTemp;
		PointObjArrTemp.Emplace(SinglePointObj);
		TempPoint->SetObjectArrayField("point", PointObjArrTemp);
		TempPoint->SetStringField("roomName", RoomNameSet[Index]);
		TempPoint->SetIntegerField("roomId", RoomIDs[Index]);
		TempPoint->SetStringField("roomUsageName", RoomUsageNameSet[Index]);
		TempPoint->SetNumberField("usageId", UsageIDs[Index]);
		TempPoint->SetNumberField("id", IDs[Index]);
		CameraPointArray.Add(TempPoint);

	}
	bool DivideAreaSuccess = DivideAreas(WorldContextObject, InJson, GroupRoomIDs);
	int NumOfFloors = GroupRoomIDs.Num();
	TArray<UVaRestJsonObject*> NewCameraPointArray;
	int idOrder = 0;
	TArray<FString> AllNameStrings;
	/////////////////////统计客厅用途信息并排序////////////////////////////
	TMap<int, int> LivingRoomUseIndexMapRoomID;
	TArray<int> LivingRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("客厅")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					LivingRoomUseIndexArr.Add(TempNumber);
					LivingRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				LivingRoomUseIndexArr.Add(0);
				LivingRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	LivingRoomUseIndexArr.Sort();
	/////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////统计餐厅用途信息并排序//////////////////////////////////////////////
	TMap<int, int> DiningRoomUseIndexMapRoomID;
	TArray<int> DiningRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("餐厅")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					DiningRoomUseIndexArr.Add(TempNumber);
					DiningRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				DiningRoomUseIndexArr.Add(0);
				DiningRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	DiningRoomUseIndexArr.Sort();
	//////////////////////////////////////////////////////////////////////////////////////////
	////////////////////统计主卧用途信息并排序////////////////////////////////////////////////
	TMap<int, int> FirstRoomUseIndexMapRoomID;
	TArray<int> FirstRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("主卧")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					FirstRoomUseIndexArr.Add(TempNumber);
					FirstRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				FirstRoomUseIndexArr.Add(0);
				FirstRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	FirstRoomUseIndexArr.Sort();
	//////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计次卧个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> SecondRoomUseIndexMapRoomID;
	TArray<int> SecondRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("次卧")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					SecondRoomUseIndexArr.Add(TempNumber);
					SecondRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				SecondRoomUseIndexArr.Add(0);
				SecondRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	SecondRoomUseIndexArr.Sort();
	/////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计儿童房的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> ChildRoomUseIndexMapRoomID;
	TArray<int> ChildRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("儿童房")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					ChildRoomUseIndexArr.Add(TempNumber);
					ChildRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				ChildRoomUseIndexArr.Add(0);
				ChildRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	ChildRoomUseIndexArr.Sort();
	//////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计老人房的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> OlderRoomUseIndexMapRoomID;
	TArray<int> OlderRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("老人房")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					ChildRoomUseIndexArr.Add(TempNumber);
					ChildRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				ChildRoomUseIndexArr.Add(0);
				ChildRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	OlderRoomUseIndexArr.Sort();
	////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计榻榻米房的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> TatamiRoomUseIndexMapRoomID;
	TArray<int>TatamiRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("榻榻米房")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					TatamiRoomUseIndexArr.Add(TempNumber);
					TatamiRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				TatamiRoomUseIndexArr.Add(0);
				TatamiRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	TatamiRoomUseIndexArr.Sort();
	////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计书房的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> StudyRoomUseIndexMapRoomID;
	TArray<int>StudyRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("书房")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					StudyRoomUseIndexArr.Add(TempNumber);
					StudyRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				StudyRoomUseIndexArr.Add(0);
				StudyRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	StudyRoomUseIndexArr.Sort();
	////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计多功能房的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> MultiFunctionRoomUseIndexMapRoomID;
	TArray<int>MultiFunctionRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("多功能房")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					MultiFunctionRoomUseIndexArr.Add(TempNumber);
					MultiFunctionRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				MultiFunctionRoomUseIndexArr.Add(0);
				MultiFunctionRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	MultiFunctionRoomUseIndexArr.Sort();
	////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计起居室的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> StartRoomUseIndexMapRoomID;
	TArray<int> StartRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("起居室")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					StartRoomUseIndexArr.Add(TempNumber);
					StartRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				StartRoomUseIndexArr.Add(0);
				StartRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	StartRoomUseIndexArr.Sort();
	////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计储藏间的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> StoreRoomUseIndexMapRoomID;
	TArray<int> StoreRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("储藏间")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					StoreRoomUseIndexArr.Add(TempNumber);
					StoreRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				StoreRoomUseIndexArr.Add(0);
				StoreRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	StoreRoomUseIndexArr.Sort();
	////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计衣帽间的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> CloakRoomUseIndexMapRoomID;
	TArray<int> CloakRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("衣帽间")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					CloakRoomUseIndexArr.Add(TempNumber);
					CloakRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				CloakRoomUseIndexArr.Add(0);
				CloakRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	CloakRoomUseIndexArr.Sort();
	////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计厨房的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> KitchenRoomUseIndexMapRoomID;
	TArray<int> KitchenRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("厨房")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					KitchenRoomUseIndexArr.Add(TempNumber);
					KitchenRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				KitchenRoomUseIndexArr.Add(0);
				KitchenRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	KitchenRoomUseIndexArr.Sort();
	////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计主卫的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> FirstToiletRoomUseIndexMapRoomID;
	TArray<int> FirstToiletRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("主卫")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					FirstToiletRoomUseIndexArr.Add(TempNumber);
					FirstToiletRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				FirstToiletRoomUseIndexArr.Add(0);
				FirstToiletRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	FirstToiletRoomUseIndexArr.Sort();
	//////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计客卫的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> SecondToiletRoomUseIndexMapRoomID;
	TArray<int> SecondToiletRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("客卫")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					SecondToiletRoomUseIndexArr.Add(TempNumber);
					SecondToiletRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				SecondToiletRoomUseIndexArr.Add(0);
				SecondToiletRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	SecondToiletRoomUseIndexArr.Sort();
	//////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计生活阳台的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> LivingBalconyRoomUseIndexMapRoomID;
	TArray<int> LivingBalconyRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("生活阳台")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					LivingBalconyRoomUseIndexArr.Add(TempNumber);
					LivingBalconyRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				LivingBalconyRoomUseIndexArr.Add(0);
				LivingBalconyRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	LivingBalconyRoomUseIndexArr.Sort();
	//////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计休闲阳台的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> LeisureBalconyRoomUseIndexMapRoomID;
	TArray<int> LeisureBalconyRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("休闲阳台")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					LeisureBalconyRoomUseIndexArr.Add(TempNumber);
					LeisureBalconyRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				LeisureBalconyRoomUseIndexArr.Add(0);
				LeisureBalconyRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	LeisureBalconyRoomUseIndexArr.Sort();
	//////////////////////////////////////////////////////////////////////////////////////////////////////
	TArray<int> HasProcessed;


	////////////////////////按用途顺序输出客厅相关数据json////////////////////////////////////////////////
	for (int _CurNum = 0; _CurNum < LivingRoomUseIndexArr.Num(); ++_CurNum)
	{
		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == LivingRoomUseIndexMapRoomID[LivingRoomUseIndexArr[_CurNum]])
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);
					if (NumOfFloors == 1)
					{
						SinglePointObj->SetNumberField("floor", 1);
					}
					else if (NumOfFloors == 2)
					{
						for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
						{
							TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
							if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
							{
								SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
							}
						}
					}
					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Add(SinglePointObj);
					/////////////////////////////////
					for (int PIndex = 0; PIndex < SmallRegionCenters.Num(); PIndex++)
					{
						if (!RoomIDMapToRemoveIndexs[RoomIDs[NewIndex]].Contains(PIndex))
						{
							idOrder++;
							UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
							TSinglePointObj->SetNumberField("id", idOrder);
							TSinglePointObj->SetNumberField("x",SmallRegionCenters[PIndex].X);
							TSinglePointObj->SetNumberField("y",SmallRegionCenters[PIndex].Y);
							TSinglePointObj->SetNumberField("z", 130);
							TSinglePointObj->SetNumberField("markType", 0);
							if (NumOfFloors == 1)
							{
								TSinglePointObj->SetNumberField("floor", 1);
							}
							else if (NumOfFloors == 2)
							{
								for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
								{
									TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
									if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
									{
										TSinglePointObj->SetNumberField("floor", 1 + _CurFloor);
									}
								}
							}

							if (PointMapLocalRegion.Contains(SmallRegionCenters[PIndex]))
							{
								TArray<FVector2D> LocalPoints = PointMapLocalRegion[SmallRegionCenters[PIndex]];
								TArray<UVaRestJsonObject*> LocalBoundPoints;
								for (int IP = 0; IP < LocalPoints.Num(); ++IP)
								{
									UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
									TempPoint->SetNumberField("x", LocalPoints[IP].X);
									TempPoint->SetNumberField("y", LocalPoints[IP].Y);
									LocalBoundPoints.Add(TempPoint);
								}
								TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
							}
							PointObjArrTemp.Add(TSinglePointObj);
						}
					}

					//////////////////////////

					TempPoint->SetObjectArrayField("point", PointObjArrTemp);
					TempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					TempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					TempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					TempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(TempPoint);
					AllNameStrings.Add(TempString);
				}
			}
		}
	}
	////////////////////////////////////////////////////////////////////////////////////////////////////


	////////////////////////按用途顺序输出餐厅相关数据json//////////////////////////////////////////////
	for (int _CurNum = 0; _CurNum < DiningRoomUseIndexArr.Num(); ++_CurNum)
	{
		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == DiningRoomUseIndexMapRoomID[DiningRoomUseIndexArr[_CurNum]])
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);

					if (NumOfFloors == 1)
					{
						SinglePointObj->SetNumberField("floor", 1);
					}
					else if (NumOfFloors == 2)
					{
						for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
						{
							TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
							if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
							{
								SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
							}
						}
					}

					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Add(SinglePointObj);
					/////////////////////////////////
					for (int PIndex = 0; PIndex < NewSmallRegionCenters.Num(); PIndex++)
					{
						if (!RoomIDMapToRemoveIndexs[RoomIDs[NewIndex]].Contains(PIndex))
						{
							idOrder++;
							UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
							TSinglePointObj->SetNumberField("id", idOrder);
							TSinglePointObj->SetNumberField("x",NewSmallRegionCenters[PIndex].X);
							TSinglePointObj->SetNumberField("y",NewSmallRegionCenters[PIndex].Y);
							TSinglePointObj->SetNumberField("z", 130);
							TSinglePointObj->SetNumberField("markType", 0);

							if (NumOfFloors == 1)
							{
								TSinglePointObj->SetNumberField("floor", 1);
							}
							else if (NumOfFloors == 2)
							{
								for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
								{
									TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
									if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
									{
										TSinglePointObj->SetNumberField("floor", 1 + _CurFloor);
									}
								}
							}

							if (PointMapLocalRegion.Contains(NewSmallRegionCenters[PIndex]))
							{
								TArray<FVector2D> LocalPoints = PointMapLocalRegion[NewSmallRegionCenters[PIndex]];
								TArray<UVaRestJsonObject*> LocalBoundPoints;
								for (int IP = 0; IP < LocalPoints.Num(); ++IP)
								{
									UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
									TempPoint->SetNumberField("x", LocalPoints[IP].X);
									TempPoint->SetNumberField("y", LocalPoints[IP].Y);
									LocalBoundPoints.Add(TempPoint);
								}
								TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
							}
							PointObjArrTemp.Add(TSinglePointObj);
						}
					}

					//////////////////////////

					TempPoint->SetObjectArrayField("point", PointObjArrTemp);
					TempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					TempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					TempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					TempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(TempPoint);
					AllNameStrings.Add(TempString);
				}
			}

		}
	}


	/////////////////////////按用途顺序输出主卧相关数据json/////////////////////////////////////////////
	for (int _CurNum = 0; _CurNum < FirstRoomUseIndexArr.Num(); ++_CurNum)
	{
		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == FirstRoomUseIndexMapRoomID[FirstRoomUseIndexArr[_CurNum]])
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);

					if (NumOfFloors == 1)
					{
						SinglePointObj->SetNumberField("floor", 1);
					}
					else if (NumOfFloors == 2)
					{
						for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
						{
							TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
							if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
							{
								SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
							}
						}
					}

					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;

					PointObjArrTemp.Add(SinglePointObj);



					/////////////////////////////////
					if (RoomIdMapSmallCenters.Contains(RoomIDs[NewIndex]))
					{
						NewSmallRegionCenters = RoomIdMapSmallCenters[RoomIDs[NewIndex]];
						for (int PIndex = 0; PIndex < NewSmallRegionCenters.Num(); PIndex++)
						{
							if (!RoomIDMapToRemoveIndexs[RoomIDs[NewIndex]].Contains(PIndex))
							{
								idOrder++;
								UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
								TSinglePointObj->SetNumberField("id", idOrder);
								TSinglePointObj->SetNumberField("x", NewSmallRegionCenters[PIndex].X);
								TSinglePointObj->SetNumberField("y", NewSmallRegionCenters[PIndex].Y);
								TSinglePointObj->SetNumberField("z", 130);
								TSinglePointObj->SetNumberField("markType", 0);

								if (NumOfFloors == 1)
								{
									TSinglePointObj->SetNumberField("floor", 1);
								}
								else if (NumOfFloors == 2)
								{
									for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
									{
										TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
										if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
										{
											TSinglePointObj->SetNumberField("floor", 1 + _CurFloor);
										}
									}
								}

								if (PointMapLocalRegion.Contains(NewSmallRegionCenters[PIndex]))
								{
									TArray<FVector2D> LocalPoints = PointMapLocalRegion[NewSmallRegionCenters[PIndex]];
									TArray<UVaRestJsonObject*> LocalBoundPoints;
									for (int IP = 0; IP < LocalPoints.Num(); ++IP)
									{
										UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
										TempPoint->SetNumberField("x", LocalPoints[IP].X);
										TempPoint->SetNumberField("y", LocalPoints[IP].Y);
										LocalBoundPoints.Add(TempPoint);
									}
									TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
								}
								PointObjArrTemp.Add(TSinglePointObj);
							}
						}
					}
					///////////////////////////////////////////////
					TempPoint->SetObjectArrayField("point", PointObjArrTemp);
					TempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					TempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					TempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					TempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(TempPoint);
					AllNameStrings.Add(TempString);
				}
			}

		}
	}


	//////////////////////////按用途顺序输出次卧相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < SecondRoomUseIndexArr.Num(); ++_CurNum)
	{
		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == SecondRoomUseIndexMapRoomID[SecondRoomUseIndexArr[_CurNum]])
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);

					if (NumOfFloors == 1)
					{
						SinglePointObj->SetNumberField("floor", 1);
					}
					else if (NumOfFloors == 2)
					{
						for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
						{
							TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
							if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
							{
								SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
							}
						}
					}

					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Add(SinglePointObj);
					/////////////////////////////////
					if (RoomIdMapSmallCenters.Contains(RoomIDs[NewIndex]))
					{
						NewSmallRegionCenters = RoomIdMapSmallCenters[RoomIDs[NewIndex]];
						for (int PIndex = 0; PIndex < NewSmallRegionCenters.Num(); PIndex++)
						{
							if (!RoomIDMapToRemoveIndexs[RoomIDs[NewIndex]].Contains(PIndex))
							{
								idOrder++;
								UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
								TSinglePointObj->SetNumberField("id", idOrder);
								TSinglePointObj->SetNumberField("x", NewSmallRegionCenters[PIndex].X);
								TSinglePointObj->SetNumberField("y", NewSmallRegionCenters[PIndex].Y);
								TSinglePointObj->SetNumberField("z", 130);
								TSinglePointObj->SetNumberField("markType", 0);

								if (NumOfFloors == 1)
								{
									TSinglePointObj->SetNumberField("floor", 1);
								}
								else if (NumOfFloors == 2)
								{
									for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
									{
										TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
										if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
										{
											TSinglePointObj->SetNumberField("floor", 1 + _CurFloor);
										}
									}
								}

								if (PointMapLocalRegion.Contains(NewSmallRegionCenters[PIndex]))
								{
									TArray<FVector2D> LocalPoints = PointMapLocalRegion[NewSmallRegionCenters[PIndex]];
									TArray<UVaRestJsonObject*> LocalBoundPoints;
									for (int IP = 0; IP < LocalPoints.Num(); ++IP)
									{
										UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
										TempPoint->SetNumberField("x", LocalPoints[IP].X);
										TempPoint->SetNumberField("y", LocalPoints[IP].Y);
										LocalBoundPoints.Add(TempPoint);
									}
									TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);

								}
								PointObjArrTemp.Add(TSinglePointObj);
							}
						}
					}
					///////////////////////////////////////////////
					TempPoint->SetObjectArrayField("point", PointObjArrTemp);
					TempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					TempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					TempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					TempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(TempPoint);
					AllNameStrings.Add(TempString);
				}
			}
		}
	}

	//////////////////////////按用途顺序输出儿童房相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < ChildRoomUseIndexArr.Num(); ++_CurNum)
	{
		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
			int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
			if (TempIDOfRoom == ChildRoomUseIndexMapRoomID[ChildRoomUseIndexArr[_CurNum]])
			{
				HasProcessed.Add(NewIndex);
				idOrder++;
				UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

				UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
				SinglePointObj->SetNumberField("id", idOrder);
				SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
				SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
				SinglePointObj->SetNumberField("z", 130);
				SinglePointObj->SetNumberField("markType", 1);

				if (NumOfFloors == 1)
				{
					SinglePointObj->SetNumberField("floor", 1);
				}
				else if (NumOfFloors == 2)
				{
					for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
					{
						TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
						if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
						{
							SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
						}
					}
				}

				if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
				{
					TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
					TArray<UVaRestJsonObject*> LocalBoundPoints;
					for (int IP = 0; IP < LocalPoints.Num(); ++IP)
					{
						UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
						TempPoint->SetNumberField("x", LocalPoints[IP].X);
						TempPoint->SetNumberField("y", LocalPoints[IP].Y);
						LocalBoundPoints.Add(TempPoint);
					}
					SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
				}
				TArray<UVaRestJsonObject*> PointObjArrTemp;
				PointObjArrTemp.Emplace(SinglePointObj);


				/////////////////////////////////
				if (RoomIdMapSmallCenters.Contains(RoomIDs[NewIndex]))
				{
					NewSmallRegionCenters = RoomIdMapSmallCenters[RoomIDs[NewIndex]];
					for (int PIndex = 0; PIndex < NewSmallRegionCenters.Num(); PIndex++)
					{
						if (!RoomIDMapToRemoveIndexs[RoomIDs[NewIndex]].Contains(PIndex))
						{
							idOrder++;
							UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
							TSinglePointObj->SetNumberField("id", idOrder);
							TSinglePointObj->SetNumberField("x", NewSmallRegionCenters[PIndex].X);
							TSinglePointObj->SetNumberField("y", NewSmallRegionCenters[PIndex].Y);
							TSinglePointObj->SetNumberField("z", 130);
							TSinglePointObj->SetNumberField("markType", 0);

							if (NumOfFloors == 1)
							{
								TSinglePointObj->SetNumberField("floor", 1);
							}
							else if (NumOfFloors == 2)
							{
								for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
								{
									TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
									if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
									{
										TSinglePointObj->SetNumberField("floor", 1 + _CurFloor);
									}
								}
							}

							if (PointMapLocalRegion.Contains(NewSmallRegionCenters[PIndex]))
							{
								TArray<FVector2D> LocalPoints = PointMapLocalRegion[NewSmallRegionCenters[PIndex]];
								TArray<UVaRestJsonObject*> LocalBoundPoints;
								for (int IP = 0; IP < LocalPoints.Num(); ++IP)
								{
									UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
									TempPoint->SetNumberField("x", LocalPoints[IP].X);
									TempPoint->SetNumberField("y", LocalPoints[IP].Y);
									LocalBoundPoints.Add(TempPoint);
								}
								TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);

							}
							PointObjArrTemp.Add(TSinglePointObj);
						}
					}
				}
				///////////////////////////////////////////////
				TempPoint->SetObjectArrayField("point", PointObjArrTemp);
				TempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
				TempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
				TempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
				TempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
				NewCameraPointArray.Add(TempPoint);
				AllNameStrings.Add(TempString);
			}
		}
	}

	//////////////////////////按用途顺序输出老人房相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < OlderRoomUseIndexArr.Num(); ++_CurNum)
	{
		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == OlderRoomUseIndexMapRoomID[OlderRoomUseIndexArr[_CurNum]])
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x",CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y",CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);

					if (NumOfFloors == 1)
					{
						SinglePointObj->SetNumberField("floor", 1);
					}
					else if (NumOfFloors == 2)
					{
						for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
						{
							TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
							if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
							{
								SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
							}
						}
					}

					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x",LocalPoints[IP].X);
							TempPoint->SetNumberField("y",LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Emplace(SinglePointObj);

					/////////////////////////////////
					if (RoomIdMapSmallCenters.Contains(RoomIDs[NewIndex]))
					{
						NewSmallRegionCenters = RoomIdMapSmallCenters[RoomIDs[NewIndex]];
						for (int PIndex = 0; PIndex < NewSmallRegionCenters.Num(); PIndex++)
						{
							if (!RoomIDMapToRemoveIndexs[RoomIDs[NewIndex]].Contains(PIndex))
							{
								idOrder++;
								UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
								TSinglePointObj->SetNumberField("id", idOrder);
								TSinglePointObj->SetNumberField("x", NewSmallRegionCenters[PIndex].X);
								TSinglePointObj->SetNumberField("y", NewSmallRegionCenters[PIndex].Y);
								TSinglePointObj->SetNumberField("z", 130);
								TSinglePointObj->SetNumberField("markType", 0);

								if (NumOfFloors == 1)
								{
									TSinglePointObj->SetNumberField("floor", 1);
								}
								else if (NumOfFloors == 2)
								{
									for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
									{
										TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
										if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
										{
											TSinglePointObj->SetNumberField("floor", 1 + _CurFloor);
										}
									}
								}

								if (PointMapLocalRegion.Contains(NewSmallRegionCenters[PIndex]))
								{
									TArray<FVector2D> LocalPoints = PointMapLocalRegion[NewSmallRegionCenters[PIndex]];
									TArray<UVaRestJsonObject*> LocalBoundPoints;
									for (int IP = 0; IP < LocalPoints.Num(); ++IP)
									{
										UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
										TempPoint->SetNumberField("x",LocalPoints[IP].X);
										TempPoint->SetNumberField("y",LocalPoints[IP].Y);
										LocalBoundPoints.Add(TempPoint);
									}
									TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);

								}
								PointObjArrTemp.Add(TSinglePointObj);
							}
						}
					}
					///////////////////////////////////////////////
					TempPoint->SetObjectArrayField("point", PointObjArrTemp);
					TempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					TempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					TempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					TempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(TempPoint);
					AllNameStrings.Add(TempString);
				}
			}

		}
	}

	//////////////////////////按用途顺序输出榻榻米房相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < TatamiRoomUseIndexArr.Num(); ++_CurNum)
	{
		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == TatamiRoomUseIndexMapRoomID[TatamiRoomUseIndexArr[_CurNum]])
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);
					if (NumOfFloors == 1)
					{
						SinglePointObj->SetNumberField("floor", 1);
					}
					else if (NumOfFloors == 2)
					{
						for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
						{
							TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
							if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
							{
								SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
							}
						}
					}

					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Emplace(SinglePointObj);



					/////////////////////////////////
					if (RoomIdMapSmallCenters.Contains(RoomIDs[NewIndex]))
					{
						NewSmallRegionCenters = RoomIdMapSmallCenters[RoomIDs[NewIndex]];
						for (int PIndex = 0; PIndex < NewSmallRegionCenters.Num(); PIndex++)
						{
							if (!RoomIDMapToRemoveIndexs[RoomIDs[NewIndex]].Contains(PIndex))
							{
								idOrder++;
								UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
								TSinglePointObj->SetNumberField("id", idOrder);
								TSinglePointObj->SetNumberField("x",NewSmallRegionCenters[PIndex].X);
								TSinglePointObj->SetNumberField("y",NewSmallRegionCenters[PIndex].Y);
								TSinglePointObj->SetNumberField("z", 130);
								TSinglePointObj->SetNumberField("markType", 0);

								if (NumOfFloors == 1)
								{
									TSinglePointObj->SetNumberField("floor", 1);
								}
								else if (NumOfFloors == 2)
								{
									for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
									{
										TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
										if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
										{
											TSinglePointObj->SetNumberField("floor", 1 + _CurFloor);
										}
									}
								}

								if (PointMapLocalRegion.Contains(NewSmallRegionCenters[PIndex]))
								{
									TArray<FVector2D> LocalPoints = PointMapLocalRegion[NewSmallRegionCenters[PIndex]];
									TArray<UVaRestJsonObject*> LocalBoundPoints;
									for (int IP = 0; IP < LocalPoints.Num(); ++IP)
									{
										UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
										TempPoint->SetNumberField("x", LocalPoints[IP].X);
										TempPoint->SetNumberField("y", LocalPoints[IP].Y);
										LocalBoundPoints.Add(TempPoint);
									}
									TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);

								}
								PointObjArrTemp.Add(TSinglePointObj);
							}
						}
					}
					///////////////////////////////////////////////
					TempPoint->SetObjectArrayField("point", PointObjArrTemp);
					TempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					TempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					TempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					TempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(TempPoint);
					AllNameStrings.Add(TempString);
				}
			}

		}

	}

	//////////////////////////按用途顺序输出书房相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < StudyRoomUseIndexArr.Num(); ++_CurNum)
	{
		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == StudyRoomUseIndexMapRoomID[StudyRoomUseIndexArr[_CurNum]])
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);

					if (NumOfFloors == 1)
					{
						SinglePointObj->SetNumberField("floor", 1);
					}
					else if (NumOfFloors == 2)
					{
						for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
						{
							TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
							if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
							{
								SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
							}
						}
					}

					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Add(SinglePointObj);


					/////////////////////////////////////////////////////////////////////
					if (RoomIdMapSmallCenters.Contains(RoomIDs[NewIndex]))
					{
						NewSmallRegionCenters = RoomIdMapSmallCenters[RoomIDs[NewIndex]];
						for (int PIndex = 0; PIndex < NewSmallRegionCenters.Num(); PIndex++)
						{
							if (!RoomIDMapToRemoveIndexs[RoomIDs[NewIndex]].Contains(PIndex))
							{
								idOrder++;
								UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
								TSinglePointObj->SetNumberField("id", idOrder);
								TSinglePointObj->SetNumberField("x", NewSmallRegionCenters[PIndex].X);
								TSinglePointObj->SetNumberField("y", NewSmallRegionCenters[PIndex].Y);
								TSinglePointObj->SetNumberField("z", 130);
								TSinglePointObj->SetNumberField("markType", 0);

								if (NumOfFloors == 1)
								{
									TSinglePointObj->SetNumberField("floor", 1);
								}
								else if (NumOfFloors == 2)
								{
									for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
									{
										TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
										if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
										{
											TSinglePointObj->SetNumberField("floor", 1 + _CurFloor);
										}
									}
								}

								if (PointMapLocalRegion.Contains(NewSmallRegionCenters[PIndex]))
								{
									TArray<FVector2D> LocalPoints = PointMapLocalRegion[NewSmallRegionCenters[PIndex]];
									TArray<UVaRestJsonObject*> LocalBoundPoints;
									for (int IP = 0; IP < LocalPoints.Num(); ++IP)
									{
										UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
										TempPoint->SetNumberField("x", LocalPoints[IP].X);
										TempPoint->SetNumberField("y", LocalPoints[IP].Y);
										LocalBoundPoints.Add(TempPoint);
									}
									TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);

								}
								PointObjArrTemp.Add(TSinglePointObj);
							}
						}
					}
					///////////////////////////////////////////////
					TempPoint->SetObjectArrayField("point", PointObjArrTemp);
					TempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					TempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					TempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					TempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(TempPoint);
					AllNameStrings.Add(TempString);
				}
			}

		}
	}


	//////////////////////////按用途顺序输出多功能房相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < MultiFunctionRoomUseIndexArr.Num(); ++_CurNum)
	{
		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == MultiFunctionRoomUseIndexMapRoomID[MultiFunctionRoomUseIndexArr[_CurNum]])
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);

					if (NumOfFloors == 1)
					{
						SinglePointObj->SetNumberField("floor", 1);
					}
					else if (NumOfFloors == 2)
					{
						for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
						{
							TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
							if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
							{
								SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
							}
						}
					}

					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Add(SinglePointObj);


					/////////////////////////////////////////////////////////////////////
					if (RoomIdMapSmallCenters.Contains(RoomIDs[NewIndex]))
					{
						NewSmallRegionCenters = RoomIdMapSmallCenters[RoomIDs[NewIndex]];
						for (int PIndex = 0; PIndex < NewSmallRegionCenters.Num(); PIndex++)
						{
							if (!RoomIDMapToRemoveIndexs[RoomIDs[NewIndex]].Contains(PIndex))
							{
								idOrder++;
								UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
								TSinglePointObj->SetNumberField("id", idOrder);
								TSinglePointObj->SetNumberField("x", NewSmallRegionCenters[PIndex].X);
								TSinglePointObj->SetNumberField("y", NewSmallRegionCenters[PIndex].Y);
								TSinglePointObj->SetNumberField("z", 130);
								TSinglePointObj->SetNumberField("markType", 0);

								if (NumOfFloors == 1)
								{
									TSinglePointObj->SetNumberField("floor", 1);
								}
								else if (NumOfFloors == 2)
								{
									for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
									{
										TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
										if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
										{
											TSinglePointObj->SetNumberField("floor", 1 + _CurFloor);
										}
									}
								}

								if (PointMapLocalRegion.Contains(NewSmallRegionCenters[PIndex]))
								{
									TArray<FVector2D> LocalPoints = PointMapLocalRegion[NewSmallRegionCenters[PIndex]];
									TArray<UVaRestJsonObject*> LocalBoundPoints;
									for (int IP = 0; IP < LocalPoints.Num(); ++IP)
									{
										UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
										TempPoint->SetNumberField("x", LocalPoints[IP].X);
										TempPoint->SetNumberField("y", LocalPoints[IP].Y);
										LocalBoundPoints.Add(TempPoint);
									}
									TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);

								}
								PointObjArrTemp.Add(TSinglePointObj);
							}
						}
					}
					///////////////////////////////////////////////
					TempPoint->SetObjectArrayField("point", PointObjArrTemp);
					TempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					TempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					TempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					TempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(TempPoint);
					AllNameStrings.Add(TempString);
				}
			}

		}
	}


	//////////////////////////按用途顺序输出起居室相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < StartRoomUseIndexArr.Num(); ++_CurNum)
	{
		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == StartRoomUseIndexMapRoomID[StartRoomUseIndexArr[_CurNum]])
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);

					if (NumOfFloors == 1)
					{
						SinglePointObj->SetNumberField("floor", 1);
					}
					else if (NumOfFloors == 2)
					{
						for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
						{
							TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
							if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
							{
								SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
							}
						}
					}

					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Add(SinglePointObj);
					/////////////////////////////////
					for (int PIndex = 0; PIndex < ThirdDiningSmallCenters.Num(); PIndex++)
					{
						if (!RoomIDMapToRemoveIndexs[RoomIDs[NewIndex]].Contains(PIndex))
						{
							idOrder++;
							UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
							TSinglePointObj->SetNumberField("id", idOrder);
							TSinglePointObj->SetNumberField("x", ThirdDiningSmallCenters[PIndex].X);
							TSinglePointObj->SetNumberField("y", ThirdDiningSmallCenters[PIndex].Y);
							TSinglePointObj->SetNumberField("z", 130);
							TSinglePointObj->SetNumberField("markType", 0);


							if (NumOfFloors == 1)
							{
								TSinglePointObj->SetNumberField("floor", 1);
							}
							else if (NumOfFloors == 2)
							{
								for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
								{
									TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
									if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
									{
										TSinglePointObj->SetNumberField("floor", 1 + _CurFloor);
									}
								}
							}

							if (PointMapLocalRegion.Contains(ThirdDiningSmallCenters[PIndex]))
							{
								TArray<FVector2D> LocalPoints = PointMapLocalRegion[ThirdDiningSmallCenters[PIndex]];
								TArray<UVaRestJsonObject*> LocalBoundPoints;
								for (int IP = 0; IP < LocalPoints.Num(); ++IP)
								{
									UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
									TempPoint->SetNumberField("x", LocalPoints[IP].X);
									TempPoint->SetNumberField("y", LocalPoints[IP].Y);
									LocalBoundPoints.Add(TempPoint);
								}
								TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
							}
							PointObjArrTemp.Add(TSinglePointObj);
						}
					}
					TempPoint->SetObjectArrayField("point", PointObjArrTemp);
					TempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					TempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					TempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					TempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(TempPoint);
					AllNameStrings.Add(TempString);
				}
			}
		}
	}


	//////////////////////////按用途顺序输出储藏间相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < StoreRoomUseIndexArr.Num(); ++_CurNum)
	{
		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == StoreRoomUseIndexMapRoomID[StoreRoomUseIndexArr[_CurNum]])
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);

					if (NumOfFloors == 1)
					{
						SinglePointObj->SetNumberField("floor", 1);
					}
					else if (NumOfFloors == 2)
					{
						for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
						{
							TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
							if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
							{
								SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
							}
						}
					}

					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Emplace(SinglePointObj);
					TempPoint->SetObjectArrayField("point", PointObjArrTemp);
					TempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					TempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					TempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					TempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(TempPoint);
					AllNameStrings.Add(TempString);
				}
			}

		}
	}

	//////////////////////////按用途顺序输出衣帽间相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < CloakRoomUseIndexArr.Num(); ++_CurNum)
	{
		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == CloakRoomUseIndexMapRoomID[CloakRoomUseIndexArr[_CurNum]])
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);

					if (NumOfFloors == 1)
					{
						SinglePointObj->SetNumberField("floor", 1);
					}
					else if (NumOfFloors == 2)
					{
						for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
						{
							TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
							if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
							{
								SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
							}
						}
					}

					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Emplace(SinglePointObj);
					TempPoint->SetObjectArrayField("point", PointObjArrTemp);
					TempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					TempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					TempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					TempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(TempPoint);
					AllNameStrings.Add(TempString);
				}
			}

		}
	}


	//////////////////////////按用途顺序输出厨房相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < KitchenRoomUseIndexArr.Num(); ++_CurNum)
	{
		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == KitchenRoomUseIndexMapRoomID[KitchenRoomUseIndexArr[_CurNum]])
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);
					if (NumOfFloors == 1)
					{
						SinglePointObj->SetNumberField("floor", 1);
					}
					else if (NumOfFloors == 2)
					{
						for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
						{
							TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
							if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
							{
								SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
							}
						}
					}

					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Emplace(SinglePointObj);
					TempPoint->SetObjectArrayField("point", PointObjArrTemp);
					TempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					TempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					TempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					TempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(TempPoint);
					AllNameStrings.Add(TempString);
				}
			}

		}
	}

	//////////////////////////按用途顺序输出主卫相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < FirstToiletRoomUseIndexArr.Num(); ++_CurNum)
	{
		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == FirstToiletRoomUseIndexMapRoomID[FirstToiletRoomUseIndexArr[_CurNum]])
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);

					if (NumOfFloors == 1)
					{
						SinglePointObj->SetNumberField("floor", 1);
					}
					else if (NumOfFloors == 2)
					{
						for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
						{
							TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
							if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
							{
								SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
							}
						}
					}

					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}

					///////////////////////////////////////////////////////////////////
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Add(SinglePointObj);
					if (RoomIDMapToiletSmallCenter.Contains(RoomIDs[NewIndex]))
					{
						idOrder++;
						UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
						TSinglePointObj->SetNumberField("id", idOrder);
						TSinglePointObj->SetNumberField("x", RoomIDMapToiletSmallCenter[RoomIDs[NewIndex]].X);
						TSinglePointObj->SetNumberField("y", RoomIDMapToiletSmallCenter[RoomIDs[NewIndex]].Y);
						TSinglePointObj->SetNumberField("z", 130);
						TSinglePointObj->SetNumberField("markType", 0);
						if (NumOfFloors == 1)
						{
							TSinglePointObj->SetNumberField("floor", 1);
						}
						else if (NumOfFloors == 2)
						{
							for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
							{
								TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
								if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
								{
									TSinglePointObj->SetNumberField("floor", 1 + _CurFloor);
								}
							}
						}

						if (PointMapLocalRegion.Contains(RoomIDMapToiletSmallCenter[RoomIDs[NewIndex]]))
						{
							TArray<FVector2D> LocalPoints = PointMapLocalRegion[RoomIDMapToiletSmallCenter[RoomIDs[NewIndex]]];
							TArray<UVaRestJsonObject*> LocalBoundPoints;
							for (int IP = 0; IP < LocalPoints.Num(); ++IP)
							{
								UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
								TempPoint->SetNumberField("x",LocalPoints[IP].X);
								TempPoint->SetNumberField("y",LocalPoints[IP].Y);
								LocalBoundPoints.Add(TempPoint);
							}
							TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
						}
						PointObjArrTemp.Add(TSinglePointObj);
					}
					///////////////////////////////////////////////////////////////////

					TempPoint->SetObjectArrayField("point", PointObjArrTemp);
					TempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					TempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					TempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					TempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(TempPoint);
					AllNameStrings.Add(TempString);
				}
			}

		}

	}

	//////////////////////////按用途顺序输出客卫相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < SecondToiletRoomUseIndexArr.Num(); ++_CurNum)
	{
		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == SecondToiletRoomUseIndexMapRoomID[SecondToiletRoomUseIndexArr[_CurNum]])
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);

					if (NumOfFloors == 1)
					{
						SinglePointObj->SetNumberField("floor", 1);
					}
					else if (NumOfFloors == 2)
					{
						for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
						{
							TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
							if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
							{
								SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
							}
						}
					}

					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}

					///////////////////////////////////////////////////////////////////
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Emplace(SinglePointObj);
					if (RoomIDMapToiletSmallCenter.Contains(RoomIDs[NewIndex]))
					{
						idOrder++;
						UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
						TSinglePointObj->SetNumberField("id", idOrder);
						TSinglePointObj->SetNumberField("x", RoomIDMapToiletSmallCenter[RoomIDs[NewIndex]].X);
						TSinglePointObj->SetNumberField("y", RoomIDMapToiletSmallCenter[RoomIDs[NewIndex]].Y);
						TSinglePointObj->SetNumberField("z", 130);
						TSinglePointObj->SetNumberField("markType", 0);
						if (NumOfFloors == 1)
						{
							TSinglePointObj->SetNumberField("floor", 1);
						}
						else if (NumOfFloors == 2)
						{
							for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
							{
								TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
								if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
								{
									TSinglePointObj->SetNumberField("floor", 1 + _CurFloor);
								}
							}
						}

						if (PointMapLocalRegion.Contains(RoomIDMapToiletSmallCenter[RoomIDs[NewIndex]]))
						{
							TArray<FVector2D> LocalPoints = PointMapLocalRegion[RoomIDMapToiletSmallCenter[RoomIDs[NewIndex]]];
							TArray<UVaRestJsonObject*> LocalBoundPoints;
							for (int IP = 0; IP < LocalPoints.Num(); ++IP)
							{
								UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
								TempPoint->SetNumberField("x", LocalPoints[IP].X);
								TempPoint->SetNumberField("y", LocalPoints[IP].Y);
								LocalBoundPoints.Add(TempPoint);
							}
							TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
						}
						PointObjArrTemp.Add(TSinglePointObj);
					}


					TempPoint->SetObjectArrayField("point", PointObjArrTemp);
					TempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					TempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					TempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					TempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(TempPoint);
					AllNameStrings.Add(TempString);
				}
			}

		}
	}

	//////////////////////////按用途顺序输出生活阳台相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < LivingBalconyRoomUseIndexArr.Num(); ++_CurNum)
	{
		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == LivingBalconyRoomUseIndexMapRoomID[LivingBalconyRoomUseIndexArr[_CurNum]])
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);


					if (NumOfFloors == 1)
					{
						SinglePointObj->SetNumberField("floor", 1);
					}
					else if (NumOfFloors == 2)
					{
						for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
						{
							TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
							if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
							{
								SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
							}
						}
					}

					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;

					PointObjArrTemp.Add(SinglePointObj);



					/////////////////////////////////
					if (RoomIdMapSmallCenters.Contains(RoomIDs[NewIndex]))
					{
						NewSmallRegionCenters = RoomIdMapSmallCenters[RoomIDs[NewIndex]];
						for (int PIndex = 0; PIndex < NewSmallRegionCenters.Num(); PIndex++)
						{
							if (!RoomIDMapToRemoveIndexs[RoomIDs[NewIndex]].Contains(PIndex))
							{
								idOrder++;
								UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
								TSinglePointObj->SetNumberField("id", idOrder);
								TSinglePointObj->SetNumberField("x", NewSmallRegionCenters[PIndex].X);
								TSinglePointObj->SetNumberField("y", NewSmallRegionCenters[PIndex].Y);
								TSinglePointObj->SetNumberField("z", 130);
								TSinglePointObj->SetNumberField("markType", 0);

								if (NumOfFloors == 1)
								{
									TSinglePointObj->SetNumberField("floor", 1);
								}
								else if (NumOfFloors == 2)
								{
									for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
									{
										TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
										if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
										{
											TSinglePointObj->SetNumberField("floor", 1 + _CurFloor);
										}
									}
								}

								if (PointMapLocalRegion.Contains(NewSmallRegionCenters[PIndex]))
								{
									TArray<FVector2D> LocalPoints = PointMapLocalRegion[NewSmallRegionCenters[PIndex]];
									TArray<UVaRestJsonObject*> LocalBoundPoints;
									for (int IP = 0; IP < LocalPoints.Num(); ++IP)
									{
										UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
										TempPoint->SetNumberField("x", LocalPoints[IP].X);
										TempPoint->SetNumberField("y", LocalPoints[IP].Y);
										LocalBoundPoints.Add(TempPoint);
									}
									TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
								}
								PointObjArrTemp.Add(TSinglePointObj);
							}
						}
					}
					///////////////////////////////////////////////
					TempPoint->SetObjectArrayField("point", PointObjArrTemp);
					TempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					TempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					TempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					TempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(TempPoint);
					AllNameStrings.Add(TempString);
				}
			}
		}
	}

	//////////////////////////按用途顺序输出休闲阳台相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < LeisureBalconyRoomUseIndexArr.Num(); ++_CurNum)
	{
		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == LeisureBalconyRoomUseIndexMapRoomID[LeisureBalconyRoomUseIndexArr[_CurNum]])
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);


					if (NumOfFloors == 1)
					{
						SinglePointObj->SetNumberField("floor", 1);
					}
					else if (NumOfFloors == 2)
					{
						for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
						{
							TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
							if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
							{
								SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
							}
						}
					}

					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;

					PointObjArrTemp.Add(SinglePointObj);



					/////////////////////////////////
					if (RoomIdMapSmallCenters.Contains(RoomIDs[NewIndex]))
					{
						NewSmallRegionCenters = RoomIdMapSmallCenters[RoomIDs[NewIndex]];
						for (int PIndex = 0; PIndex < NewSmallRegionCenters.Num(); PIndex++)
						{
							if (!RoomIDMapToRemoveIndexs[RoomIDs[NewIndex]].Contains(PIndex))
							{
								idOrder++;
								UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
								TSinglePointObj->SetNumberField("id", idOrder);
								TSinglePointObj->SetNumberField("x", NewSmallRegionCenters[PIndex].X);
								TSinglePointObj->SetNumberField("y", NewSmallRegionCenters[PIndex].Y);
								TSinglePointObj->SetNumberField("z", 130);
								TSinglePointObj->SetNumberField("markType", 0);

								if (NumOfFloors == 1)
								{
									TSinglePointObj->SetNumberField("floor", 1);
								}
								else if (NumOfFloors == 2)
								{
									for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
									{
										TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
										if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
										{
											TSinglePointObj->SetNumberField("floor", 1 + _CurFloor);
										}
									}
								}

								if (PointMapLocalRegion.Contains(NewSmallRegionCenters[PIndex]))
								{
									TArray<FVector2D> LocalPoints = PointMapLocalRegion[NewSmallRegionCenters[PIndex]];
									TArray<UVaRestJsonObject*> LocalBoundPoints;
									for (int IP = 0; IP < LocalPoints.Num(); ++IP)
									{
										UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
										TempPoint->SetNumberField("x", LocalPoints[IP].X);
										TempPoint->SetNumberField("y", LocalPoints[IP].Y);
										LocalBoundPoints.Add(TempPoint);
									}
									TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
								}
								PointObjArrTemp.Add(TSinglePointObj);
							}
						}
					}
					///////////////////////////////////////////////
					TempPoint->SetObjectArrayField("point", PointObjArrTemp);
					TempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					TempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					TempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					TempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(TempPoint);
					AllNameStrings.Add(TempString);
				}
			}
		}
	}



	for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
	{
		FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
		bool FindNameString = false;

		for (int NIndex = 0; NIndex < AllNameStrings.Num(); NIndex++)
		{
			if (AllNameStrings[NIndex] == TempString)
			{
				FindNameString = true;
				break;
			}
		}
		if (FindNameString == false)
		{
			idOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", idOrder);
			SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
			SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
			SinglePointObj->SetNumberField("z", 130);
			SinglePointObj->SetNumberField("markType", 1);

			if (NumOfFloors == 1)
			{
				SinglePointObj->SetNumberField("floor", 1);
			}
			else if (NumOfFloors == 2)
			{
				for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
				{
					TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
					if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
					{
						SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
					}
				}
			}

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Emplace(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
			TempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
			TempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
			TempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
			NewCameraPointArray.Add(TempPoint);
			AllNameStrings.Add(TempString);
		}
	}

	LocationJson->SetObjectArrayField("cameraLocation", NewCameraPointArray);
	return true;
}




bool  UWriteMeshObj_FunctionLibrary::CreateAdvancedPanorama(UObject* WorldContextObject, UVaRestJsonObject* InJson, UVaRestJsonObject* &OutPanoramaJson)
{
	if (InJson == nullptr)
	{
		return false;
	}
	if (!OutPanoramaJson)
		OutPanoramaJson = UVaRestJsonObject::ConstructJsonObject(WorldContextObject);

	int SolutionID = 0;
	SolutionID = InJson->GetNumberField("solutionId");
	OutPanoramaJson->SetNumberField("solutionId", SolutionID);

	FString SolutionName = InJson->GetStringField("solutionName");
	OutPanoramaJson->SetStringField("name", SolutionName);

	int UserId = InJson->GetNumberField("userId");
	OutPanoramaJson->SetNumberField("userId", UserId);

	TArray<UVaRestJsonObject*> RoomJsonObj = InJson->GetObjectArrayField("roomList");
	TArray<UVaRestJsonObject*> NewRoomJsonObj;
	TMap<int, TArray<FVector2D>> RoomIDMapRegions;
	TMap<int, FString> RoomIDMapName;
	TArray<int> AllRoomIDs;
	TMap<int, FString> RoomIDMapUseageName;
	TMap<int, int> RoomIDMapUsageID;
	for (int RoomIndex = 0; RoomIndex < RoomJsonObj.Num(); RoomIndex++)
	{
		UVaRestJsonObject* NewRoomJson = NewObject<UVaRestJsonObject>();
		TArray<UVaRestJsonObject*> EachRoomRegion = RoomJsonObj[RoomIndex]->GetObjectArrayField("areas");
		TArray<UVaRestJsonObject*> NewEachRoomRegion;
		TArray<FVector2D> TempRegionPs;


		int RoomId = RoomJsonObj[RoomIndex]->GetIntegerField("roomId");
		NewRoomJson->SetIntegerField("roomId", RoomId);
		AllRoomIDs.Add(RoomId);


		for (int NumIndex = 0; NumIndex < EachRoomRegion.Num(); NumIndex++)
		{
			UVaRestJsonObject* TempXY = NewObject<UVaRestJsonObject>();
			float TempX = EachRoomRegion[NumIndex]->GetNumberField("x");
			float TempY = EachRoomRegion[NumIndex]->GetNumberField("y");
			TempRegionPs.AddUnique(FVector2D(TempX, TempY));
			TempXY->SetNumberField("x", TempX);
			TempXY->SetNumberField("y", TempY);
			NewEachRoomRegion.Add(TempXY);
		}
		NewRoomJson->SetObjectArrayField("areas", NewEachRoomRegion);

		FString RoomName = RoomJsonObj[RoomIndex]->GetStringField("roomName");
		NewRoomJson->SetStringField("roomName", RoomName);

		RoomIDMapRegions.Add(RoomId, TempRegionPs);
		RoomIDMapName.Add(RoomId, RoomName);
		FString RoomUsageName = RoomJsonObj[RoomIndex]->GetStringField("roomUsageName");
		NewRoomJson->SetStringField("roomUsageName", RoomUsageName);
		RoomIDMapUseageName.Add(RoomId, RoomUsageName);
		int RoomUsageId = RoomJsonObj[RoomIndex]->GetNumberField("usageId");
		RoomIDMapUsageID.Add(RoomId, RoomUsageId);
		NewRoomJson->SetNumberField("usageId", RoomUsageId);
		NewRoomJsonObj.Add(NewRoomJson);
	}

	TArray<UVaRestJsonObject*> WallJsonObj = InJson->GetObjectArrayField("walls");
	TArray<UVaRestJsonObject*> NewWallJsonObj;

	TMap<int, TArray<FVector>> IndexMapWalls;
	TMap<int, FVector2D>IndexMapWallCenter;
	TMap<int, TArray<FVector2D>> IndexMapWalls2D;
	for (int WallIndex = 0; WallIndex < WallJsonObj.Num(); WallIndex++)
	{
		UVaRestJsonObject* NewWallJson = NewObject<UVaRestJsonObject>();
		TArray<UVaRestJsonObject*> WallPs = WallJsonObj[WallIndex]->GetObjectArrayField("wallPoints");
		TArray<UVaRestJsonObject*> NewWallPs;
		TArray<FVector> TempWall;
		TArray<FVector2D> TempWall2D;
		FVector2D TempWallCenter(0.0, 0.0);
		for (int NumIndex = 0; NumIndex < WallPs.Num(); NumIndex++)
		{
			UVaRestJsonObject* TempWallXYZ = NewObject<UVaRestJsonObject>();
			float TempX = WallPs[NumIndex]->GetNumberField("x");
			float TempY = WallPs[NumIndex]->GetNumberField("y");
			float TempZ = WallPs[NumIndex]->GetNumberField("z");
			TempWallXYZ->SetNumberField("x", TempX);
			TempWallXYZ->SetNumberField("y", TempY);
			TempWallXYZ->SetNumberField("z", TempZ);
			NewWallPs.Add(TempWallXYZ);
			TempWall.Add(FVector(TempX, TempY, TempZ));
			TempWall2D.Add(FVector2D(TempX, TempY));
			TempWallCenter = TempWallCenter + FVector2D(TempX, TempY);
		}
		TempWallCenter = TempWallCenter / WallPs.Num();
		IndexMapWalls.Add(WallIndex, TempWall);
		IndexMapWalls2D.Add(WallIndex, TempWall2D);
		IndexMapWallCenter.Add(WallIndex, TempWallCenter);
		NewWallJson->SetObjectArrayField("wallPoints", NewWallPs);
		NewWallJsonObj.Add(NewWallJson);
	}


	UVaRestJsonObject* ObjData = NewObject<UVaRestJsonObject>();
	ObjData->SetObjectArrayField("roomList", NewRoomJsonObj);
	ObjData->SetObjectArrayField("walls", NewWallJsonObj);
	OutPanoramaJson->SetObjectField("objData", ObjData);

	UVaRestJsonObject	*LocationJson = UVaRestJsonObject::ConstructJsonObject(WorldContextObject);
	TArray<FVector2D> RegionCenters;
	int NumOfTotalPickPs = 0;
	TMap<int, FloorGroup> GroupRoomIDs;
	
	TArray<FGroupRoomIDs> GroupMapLivingOrDiningRoomIDs;
	bool IsSuccess = CreateAdvancedLocationJsonWithFloorsAndMulitiLivings(WorldContextObject, InJson, LocationJson, RegionCenters, NumOfTotalPickPs, GroupRoomIDs, GroupMapLivingOrDiningRoomIDs);
	if (!IsSuccess)
	{
		return false;
	}
	OutPanoramaJson->MergeJsonObject(LocationJson, true);
	///////////////Match RoomID with RegionCenters
	if (AllRoomIDs.Num() != RegionCenters.Num())
	{
		return false;
	}
	TMap<int, FVector2D> RoomIDMapRegionCenters;
	for (int I = 0; I < AllRoomIDs.Num(); ++I)
	{
		RoomIDMapRegionCenters.Add(AllRoomIDs[I], RegionCenters[I]);
	}
	/////////////////////////////////////统计客餐厅组数/////////////////////////
	int NumOfLivings = 0;
	int NumOfDinings = 0;
	TArray<int> LivingIDs, DiningIDs;
	for (int _CurPair = 0; _CurPair < GroupMapLivingOrDiningRoomIDs.Num(); ++_CurPair)
	{
		if (GroupMapLivingOrDiningRoomIDs[_CurPair].GroupIndex == 0)
		{
			LivingIDs = GroupMapLivingOrDiningRoomIDs[_CurPair].RoomIDs;
			NumOfLivings = LivingIDs.Num();
		}
		else if (GroupMapLivingOrDiningRoomIDs[_CurPair].GroupIndex == 1)
		{
			DiningIDs = GroupMapLivingOrDiningRoomIDs[_CurPair].RoomIDs;
			NumOfDinings = DiningIDs.Num();
		}
	}
	///////获取全景图观察点
	//////////预处理客餐厅数据////////////////////////////
	TArray<FVector2D> LivingRoomPs, DiningRoomPs, KitchenRoomPs;
	int LivingRoomID = 0, DiningRoomID = 0, KitchenRoomID = 0;
	bool IsLivingRoom = false;
	bool IsDiningRoom = false;
	bool IsKitchenRoom = false;
	for (int I = 0; I < AllRoomIDs.Num(); ++I)
	{
		int TempRoomId = AllRoomIDs[I];
		FString TempRoomName = RoomIDMapName[TempRoomId];
		if (NumOfLivings > 0)
		{
			if ((TempRoomId == LivingIDs[0]) && (!IsLivingRoom))
			{
				TArray<FVector2D> TempLivingPs = RoomIDMapRegions[TempRoomId];
				for (int _CurP = 0; _CurP < TempLivingPs.Num(); ++_CurP)
				{
					LivingRoomPs.AddUnique(TempLivingPs[_CurP]);
				}
				LivingRoomID = TempRoomId;
				IsLivingRoom = true;
			}
		}
		if (NumOfDinings > 0)
		{
			if ((TempRoomId == DiningIDs[0]) && (!IsDiningRoom))
			{
				TArray<FVector2D> TempDiningPs = RoomIDMapRegions[TempRoomId];
				for (int _CurP = 0; _CurP < TempDiningPs.Num(); ++_CurP)
				{
					DiningRoomPs.AddUnique(TempDiningPs[_CurP]);
				}
				DiningRoomID = TempRoomId;
				IsDiningRoom = true;
			}
		}

		if ((TempRoomName == TEXT("厨房")) && (!IsKitchenRoom))
		{
			KitchenRoomID = TempRoomId;
			TArray<FVector2D> TempKitchenRoomPs = RoomIDMapRegions[TempRoomId];
			for (int _CurP = 0; _CurP < TempKitchenRoomPs.Num(); ++_CurP)
			{
				KitchenRoomPs.AddUnique(TempKitchenRoomPs[_CurP]);
			}
			IsKitchenRoom = true;
		}
	}
	bool IFInterSect = false;
	bool HasCommonPoints = false;
	if ((LivingRoomPs.Num() != 0) && (DiningRoomPs.Num() != 0))
	{
		IFInterSect = FPolygonAlg::JudgePolygonInterSect(LivingRoomPs, DiningRoomPs);
		HasCommonPoints = FPolygonAlg::JudgeHasClosePoint(LivingRoomPs, DiningRoomPs);
	}
	//////////////预处理第三厅以及第四厅数据///////////////////////////
	TArray<FVector2D> ThirdDinging, FourthDining;
	int ThirdDingingRoomID = 0, FourthDiningRoomID = 0;
	bool IsThirdDining = false;
	bool IsFourthDining = false;
	for (int I = 0; I < AllRoomIDs.Num(); ++I)
	{
		int TempRoomId = AllRoomIDs[I];
		FString TempRoomName = RoomIDMapName[TempRoomId];
		if ((TempRoomName == TEXT("客厅")) && (TempRoomId != LivingRoomID) && (!IsThirdDining))
		{
			TArray<FVector2D> TempThirdDining = RoomIDMapRegions[TempRoomId];
			for (int _CurP = 0; _CurP < TempThirdDining.Num(); ++_CurP)
			{
				ThirdDinging.AddUnique(TempThirdDining[_CurP]);
			}
			ThirdDingingRoomID = TempRoomId;
			IsThirdDining = true;
		}
		else if ((TempRoomName == TEXT("餐厅")) && (TempRoomId != DiningRoomID) && (!IsFourthDining))
		{
			TArray<FVector2D> TempFourthDining = RoomIDMapRegions[TempRoomId];
			for (int _CurP = 0; _CurP < TempFourthDining.Num(); ++_CurP)
			{
				FourthDining.AddUnique(TempFourthDining[_CurP]);
			}
			FourthDiningRoomID = TempRoomId;
			IsFourthDining = true;
		}
	}
	bool IFInterSectOfThirdAndFourth = false;
	bool HasCommonPointsOfThirdAndFourth = false;
	if ((ThirdDinging.Num() != 0) && (FourthDining.Num() != 0))
	{
		IFInterSectOfThirdAndFourth = FPolygonAlg::JudgePolygonInterSect(ThirdDinging, FourthDining);
		HasCommonPointsOfThirdAndFourth = FPolygonAlg::JudgeHasClosePoint(ThirdDinging, FourthDining);
	}
	/////////////预处理厨房数据,判断厨房是否是开放式厨房//////////////////
	bool IsOpenKitchen1 = false;
	bool IsOpenKitchen2 = false;

	for (int Index = 0; Index < AllRoomIDs.Num(); ++Index)
	{
		if (AllRoomIDs[Index] != KitchenRoomID)
		{
			TArray<FVector2D> PreRoomPs,TempRoomPs;
			PreRoomPs = RoomIDMapRegions[AllRoomIDs[Index]];
			for (int _CurP = 0; _CurP < PreRoomPs.Num(); ++_CurP)
			{
				TempRoomPs.AddUnique(PreRoomPs[_CurP]);
			}
			IsOpenKitchen1 = FPolygonAlg::JudgePolygonInterSect(KitchenRoomPs, TempRoomPs);
			if (IsOpenKitchen1)
			{
				break;
			}
			TArray<FVector2D> UpdateKitchenRoomPs, UpdateTempRoomPs, TempInterSectPs, TempCombinedPolygon;
			IsOpenKitchen2 = FPolygonAlg::CalculateTwoPolygonInterSect(KitchenRoomPs, TempRoomPs, UpdateKitchenRoomPs, UpdateTempRoomPs, TempInterSectPs, TempCombinedPolygon);
			if (IsOpenKitchen2)
			{
				break;
			}
		}
	}
	TMap<int, FVector2D> PanoramaWatchPoints;
	TMap<int, FVector2D> RoomIDMapWatchDirections;
	TMap<int, TArray<FVector>> RoomIDMapHoleData;
	TArray<int> SpecialRoomIDs;
	for (int RoomIndex = 0; RoomIndex < AllRoomIDs.Num(); RoomIndex++)
	{
		int TempRoomId = AllRoomIDs[RoomIndex];
		FString TempRoomName = RoomIDMapName[TempRoomId];
		TArray<FVector2D> PreTempRegionPs,TempRegionPs;
		PreTempRegionPs = RoomIDMapRegions[TempRoomId];
		for (int _CurP = 0; _CurP < PreTempRegionPs.Num(); ++_CurP)
		{
			TempRegionPs.AddUnique(PreTempRegionPs[_CurP]);
		}

		if ((TempRoomName == TEXT("主卧")) || (TempRoomName == TEXT("次卧")) || (TempRoomName == TEXT("儿童房")) || (TempRoomName == TEXT("老人房"))
			|| (TempRoomName == TEXT("榻榻米房")) || (TempRoomName == TEXT("客人房")) || (TempRoomName == TEXT("书房")) || (TempRoomName == TEXT("健身房"))
			|| (TempRoomName == TEXT("多功能房")))
		{
			TArray<FVector2D> UpdateRegionPs;
			FPolygonAlg::MergeCollinearPoints(TempRegionPs, UpdateRegionPs);
			TArray<AFurnitureModelActor*> ModelsOfRoom;
			FindModelsOfRoom(WorldContextObject, UpdateRegionPs, ModelsOfRoom);
			AFurnitureModelActor* FindFur = nullptr;
			bool FindModel = false;
			bool IsSame = false;
			for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
			{
				AFurnitureModelActor* TempFur = ModelsOfRoom[_CurM];
				int TempID = 0;
				TempFur->GetModelCategory(TempID);
				if ((TempID == 5009) || (TempID == 5010))
				{
					FindFur = TempFur;
					FindModel = true;
					break;
				}
			}
			if (FindModel)
			{
				FBox TempBox = FindFur->GetComponentsBoundingBox(true);
				FVector FMin = TempBox.Min;
				FVector FMax = TempBox.Max;
				FVector2D P1(FMin.X, FMin.Y);
				FVector2D P2(FMax.X, FMin.Y);
				FVector2D P3(FMax.X, FMax.Y);
				FVector2D P4(FMin.X, FMax.Y);
				FVector2D BoxCenter = 0.25*(P1 + P2 + P3 + P4);
				float Dis1 = FVector2D::Distance(P1, P2);
				float Dis2 = FVector2D::Distance(P2, P3);
				FVector2D TempWatchP;
				FVector2D TempDir;
				const float ExtendL = 20;
				if (Dis1 > Dis2)
				{
					FVector2D TempPointVec = P2 - P1;
					TempPointVec = TempPointVec.GetSafeNormal();
					FVector2D TryP1 = BoxCenter + TempPointVec * (0.5*Dis1 + ExtendL);
					FVector2D TryP2 = BoxCenter - TempPointVec * (0.5*Dis1 + ExtendL);
					bool JudgeTryP1 = FPolygonAlg::JudgePointOnOrInPolygon(UpdateRegionPs, TryP1);
					bool JudgeTryP2 = FPolygonAlg::JudgePointOnOrInPolygon(UpdateRegionPs, TryP2);
					if (JudgeTryP1&&JudgeTryP2)
					{
						//IsSame = true;
						TempPointVec = P3 - P2;
						TempPointVec = TempPointVec.GetSafeNormal();
						TryP1 = BoxCenter + TempPointVec * (0.5*Dis2 + ExtendL);
						TryP2 = BoxCenter - TempPointVec * (0.5*Dis2 + ExtendL);
						JudgeTryP1 = FPolygonAlg::JudgePointOnOrInPolygon(UpdateRegionPs, TryP1);
						JudgeTryP2 = FPolygonAlg::JudgePointOnOrInPolygon(UpdateRegionPs, TryP2);
						if (JudgeTryP1&&JudgeTryP2)
						{
							IsSame = true;
						}
						else
						{
							FVector2D TempInterSectP1, TempInterSectP2;
							FPolygonAlg::CalculateRayToInterSectP(UpdateRegionPs, BoxCenter, TempPointVec, TempInterSectP1);
							FPolygonAlg::CalculateRayToInterSectP(UpdateRegionPs, BoxCenter, -TempPointVec, TempInterSectP2);
							float DisToInterSectP1 = FVector2D::Distance(BoxCenter, TempInterSectP1);
							float DisToInterSectP2 = FVector2D::Distance(BoxCenter, TempInterSectP2);
							if ((DisToInterSectP1 >= 20) || (DisToInterSectP2 >= 20))
							{
								if (DisToInterSectP1 > DisToInterSectP2)
								{
									TempWatchP = 0.5*(0.5*(P3 + P4) + TempInterSectP1);
									TempDir = -TempPointVec;
								}
								else
								{
									TempWatchP = 0.5*(0.5*(P1 + P2) + TempInterSectP2);
									TempDir = TempPointVec;
								}
							}
						}
					}
					else
					{
						FVector2D TempInterSectP1, TempInterSectP2;
						FPolygonAlg::CalculateRayToInterSectP(UpdateRegionPs, BoxCenter, TempPointVec, TempInterSectP1);
						FPolygonAlg::CalculateRayToInterSectP(UpdateRegionPs, BoxCenter, -TempPointVec, TempInterSectP2);
						float DisToInterSectP1 = FVector2D::Distance(BoxCenter, TempInterSectP1);
						float DisToInterSectP2 = FVector2D::Distance(BoxCenter, TempInterSectP2);
						if ((DisToInterSectP1 >= 20) || (DisToInterSectP2 >= 20))
						{
							if (DisToInterSectP1 > DisToInterSectP2)
							{
								TempWatchP = 0.5*(0.5*(P2 + P3) + TempInterSectP1);
								TempDir = -TempPointVec;
							}
							else
							{
								TempWatchP = 0.5*(0.5*(P4 + P1) + TempInterSectP2);
								TempDir = TempPointVec;
							}
						}
					}
				}
				else
				{
					FVector2D TempPointVec = P3 - P2;
					TempPointVec = TempPointVec.GetSafeNormal();
					FVector2D TryP1 = BoxCenter + TempPointVec * (0.5*Dis2 + ExtendL);
					FVector2D TryP2 = BoxCenter - TempPointVec * (0.5*Dis2 + ExtendL);
					bool JudgeTryP1 = FPolygonAlg::JudgePointOnOrInPolygon(UpdateRegionPs, TryP1);
					bool JudgeTryP2 = FPolygonAlg::JudgePointOnOrInPolygon(UpdateRegionPs, TryP2);
					if (JudgeTryP1 && JudgeTryP2)
					{
						//IsSame = true;
						TempPointVec = P2 - P1;
						TempPointVec = TempPointVec.GetSafeNormal();
						TryP1 = BoxCenter + TempPointVec * (0.5*Dis1 + ExtendL);
						TryP2 = BoxCenter - TempPointVec * (0.5*Dis1 + ExtendL);
						JudgeTryP1 = FPolygonAlg::JudgePointOnOrInPolygon(UpdateRegionPs, TryP1);
						JudgeTryP2 = FPolygonAlg::JudgePointOnOrInPolygon(UpdateRegionPs, TryP2);
						if (JudgeTryP1&&JudgeTryP2)
						{
							IsSame = true;
						}
						else
						{
							FVector2D TempInterSectP1, TempInterSectP2;
							FPolygonAlg::CalculateRayToInterSectP(UpdateRegionPs, BoxCenter, TempPointVec, TempInterSectP1);
							FPolygonAlg::CalculateRayToInterSectP(UpdateRegionPs, BoxCenter, -TempPointVec, TempInterSectP2);
							float DisToInterSectP1 = FVector2D::Distance(BoxCenter, TempInterSectP1);
							float DisToInterSectP2 = FVector2D::Distance(BoxCenter, TempInterSectP2);
							if ((DisToInterSectP1 >= 20) || (DisToInterSectP2 >= 20))
							{
								if (DisToInterSectP1 > DisToInterSectP2)
								{
									TempWatchP = 0.5*(0.5*(P3 + P4) + TempInterSectP1);
									TempDir = -TempPointVec;
								}
								else
								{
									TempWatchP = 0.5*(0.5*(P1 + P2) + TempInterSectP2);
									TempDir = TempPointVec;
								}
							}
						}
					}
					else
					{
						FVector2D TempInterSectP1, TempInterSectP2;
						FPolygonAlg::CalculateRayToInterSectP(UpdateRegionPs, BoxCenter, TempPointVec, TempInterSectP1);
						FPolygonAlg::CalculateRayToInterSectP(UpdateRegionPs, BoxCenter, -TempPointVec, TempInterSectP2);
						float DisToInterSectP1 = FVector2D::Distance(BoxCenter, TempInterSectP1);
						float DisToInterSectP2 = FVector2D::Distance(BoxCenter, TempInterSectP2);
						if ((DisToInterSectP1 >= 20) || (DisToInterSectP2 >= 20))
						{
							if (DisToInterSectP1 > DisToInterSectP2)
							{
								TempWatchP = 0.5*(0.5*(P3 + P4) + TempInterSectP1);
								TempDir = -TempPointVec;
							}
							else
							{
								TempWatchP = 0.5*(0.5*(P1 + P2) + TempInterSectP2);
								TempDir = TempPointVec;
							}
						}
					}
				}

				if (!IsSame)
				{
					bool FindPointInModel = false;
					for (auto TempModelInRoom : ModelsOfRoom)
					{
						FBox TempBox = TempModelInRoom->GetComponentsBoundingBox(true);
						FString ModelName = TempModelInRoom->GetName();
						if (!ModelName.Contains(TEXT("Light")))
						{
							bool IfInModel = TempBox.IsInsideOrOn(FVector(TempWatchP, 130));
							if (IfInModel)
							{
								FVector FMin = TempBox.Min;
								FVector FMax = TempBox.Max;
								bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, UpdateRegionPs);
								if (ModelBoxIsUseful)
								{
									FindPointInModel = true;
									break;
								}
							}
						}
					}
					bool IsInSide = false;
					IsInSide = FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, TempWatchP);

					if ((!FindPointInModel) && (IsInSide))
					{
						PanoramaWatchPoints.Add(TempRoomId, TempWatchP);
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						SpecialRoomIDs.AddUnique(TempRoomId);
						TArray<FVector>DoorPoints;
						bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
						if (GetDoorSuccess)
						{
							int TempNumOfDoors = DoorPoints.Num() / 8;
							if (TempNumOfDoors > 0)
							{
								RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
							}
						}
					}
					else
					{
						IsSame = true;
					}
				}
			}
			else
			{
				IsSame = true;
			}
			if (IsSame)
			{
				TArray<FVector>DoorPoints;
				if (UpdateRegionPs.Num() <= 5)
				{
					bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
					if (!GetDoorSuccess)
					{
						PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
						FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}
					else
					{

						int NumOfDoors = DoorPoints.Num() / 8;
						RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
						FVector2D SuitPoint;
						TArray<FVector2D> RoomWallPs;
						bool GetWallSuccess = GetWallPointsOfRoom(WorldContextObject, TempRoomId, RoomWallPs);
						if (GetWallSuccess)
						{
							bool GetSpecialSuccess = FPolygonAlg::GetRegionOfFourCornerSpecialRoom(UpdateRegionPs, SuitPoint, RoomWallPs, DoorPoints, 0.01);
							if (GetSpecialSuccess)
							{
								if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, SuitPoint))
								{
									PanoramaWatchPoints.Add(TempRoomId, SuitPoint);
									FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - SuitPoint;
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
								else
								{
									PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
									FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}

							}
							else
							{
								if (NumOfDoors == 1)
								{
									FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
									FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
									DirVec = DirVec.GetSafeNormal();
									DirVec = DirVec.GetRotated(90);
									FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
									FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
									FVector2D TempVec1 = DoorCenter2D + 100 * DirVec;
									if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, TempVec1))
									{
										PanoramaWatchPoints.Add(TempRoomId, TempVec1);
										FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
									}
									else
									{
										if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, DoorCenter2D - 100 * DirVec))
										{
											PanoramaWatchPoints.Add(TempRoomId, DoorCenter2D - 100 * DirVec);
											FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - (DoorCenter2D - 100 * DirVec);
											TempDir = TempDir.GetSafeNormal();
											RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
										}
										else
										{
											PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
											FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
											TempDir = TempDir.GetSafeNormal();
											RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
										}

									}
								}
								else if (NumOfDoors >= 2)
								{
									FVector2D TempCenter = RegionCenters[RoomIndex];
									float MaxDis = 0.0;
									int TargetDoorIndex = 0;
									for (int J = 0; J < NumOfDoors; ++J)
									{
										FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
										FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
										float TempDis = FVector2D::Distance(TempCenter, TempDoorCenter2D);
										if ((MaxDis == 0.0) || (TempDis > MaxDis))
										{
											MaxDis = TempDis;
											TargetDoorIndex = J;
										}
									}
									FVector2D PStart = FVector2D(DoorPoints[0 + 8 * TargetDoorIndex].X, DoorPoints[1 + 8 * TargetDoorIndex].Y);
									FVector2D PEnd = FVector2D(DoorPoints[2 + 8 * TargetDoorIndex].X, DoorPoints[3 + 8 * TargetDoorIndex].Y);
									FVector2D ParallelPStart, ParallelPEnd;
									const float DisValue = 30;
									int ParallelEdgeIndex = 0;
									bool FindSuccess = FPolygonAlg::FindParallelEdge(UpdateRegionPs, PStart, PEnd, ParallelPStart, ParallelPEnd, ParallelEdgeIndex, DisValue);
									if (!FindSuccess)
									{
										FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
										FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
										DirVec = DirVec.GetSafeNormal();
										DirVec = DirVec.GetRotated(90);
										FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
										FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
										FVector2D TempVec1 = DoorCenter2D + 100 * DirVec;
										if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, TempVec1))
										{
											PanoramaWatchPoints.Add(TempRoomId, TempVec1);
											FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
											TempDir = TempDir.GetSafeNormal();
											RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
										}
										else
										{
											if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, DoorCenter2D - 100 * DirVec))
											{
												PanoramaWatchPoints.Add(TempRoomId, DoorCenter2D - 100 * DirVec);
												FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - (DoorCenter2D - 100 * DirVec);
												TempDir = TempDir.GetSafeNormal();
												RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
											}
											else
											{
												PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
												FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
												TempDir = TempDir.GetSafeNormal();
												RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
											}

										}
									}
									else
									{
										FVector TempDirVec = DoorPoints[1 + 8 * TargetDoorIndex] - DoorPoints[0 + 8 * TargetDoorIndex];
										FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
										DirVec = DirVec.GetSafeNormal();
										DirVec = DirVec.GetRotated(90);
										FVector DoorCenter3D = 0.25*(DoorPoints[0 + 8 * TargetDoorIndex] + DoorPoints[1 + 8 * TargetDoorIndex] + DoorPoints[2 + 8 * TargetDoorIndex]
											+ DoorPoints[3 + 8 * TargetDoorIndex]);
										FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
										FVector2D TempVec1 = DoorCenter2D + 100 * DirVec;
										if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, TempVec1))
										{
											PanoramaWatchPoints.Add(TempRoomId, TempVec1);
											FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
											TempDir = TempDir.GetSafeNormal();
											RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
										}
										else
										{
											if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, DoorCenter2D - 100 * DirVec))
											{
												PanoramaWatchPoints.Add(TempRoomId, DoorCenter2D - 100 * DirVec);
												FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - (DoorCenter2D - 100 * DirVec);
												TempDir = TempDir.GetSafeNormal();
												RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
											}
											else
											{
												PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
												FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
												TempDir = TempDir.GetSafeNormal();
												RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
											}

										}
									}
								}
							}
						}
						else
						{
							PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
							FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
					}
				}
				else if (UpdateRegionPs.Num() >= 6)
				{
					bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
					if (!GetDoorSuccess)
					{
						PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
						FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}
					else
					{
						int NumOfDoors = DoorPoints.Num() / 8;
						RoomIDMapHoleData.Add(TempRoomId, DoorPoints);

						TArray<FVector2D> MaxAreaRegion;
						FVector2D SuitPoint;

						bool GetSuccess = FPolygonAlg::GetMaxRegionOfSpecialRoom(UpdateRegionPs, MaxAreaRegion, SuitPoint, DoorPoints);
						if (GetSuccess)
						{
							if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, SuitPoint))
							{
								PanoramaWatchPoints.Add(TempRoomId, SuitPoint);
								FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - SuitPoint;
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
							}
							else
							{
								PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
								FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
							}

						}
						else
						{
							const float DisBound = 180;
							if (NumOfDoors == 1)
							{
								///////////////////////////////////////////////////计算从门中心出发射线与区域的交点/////////////////////////////////////////////////
								FVector2D TempDoorLoc = 0.25*FVector2D(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
								FVector2D TempDoorVec = FVector2D(DoorPoints[1] - DoorPoints[0]);
								TempDoorVec = TempDoorVec.GetSafeNormal();
								FVector2D TempRotateOfVec = TempDoorVec.GetRotated(90);
								FVector2D TempExtendP = TempDoorLoc + 40 * TempRotateOfVec;
								bool IfInArea = FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, TempExtendP);
								bool HasLocated = false;
								if (IfInArea)
								{
									FVector2D TempInterP;
									bool IsLocated = FPolygonAlg::CalculateRayInterSectPoly(UpdateRegionPs, TempDoorLoc, TempRotateOfVec, TempInterP, DisBound);
									if (IsLocated)
									{
										FVector2D SuitLoc = 0.5*(TempInterP + TempDoorLoc);
										PanoramaWatchPoints.Add(TempRoomId, SuitLoc);
										FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - SuitLoc;
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
										HasLocated = true;
									}
								}
								else
								{
									FVector2D TempInterP;
									bool IsLocated = FPolygonAlg::CalculateRayInterSectPoly(UpdateRegionPs, TempDoorLoc, -TempRotateOfVec, TempInterP, DisBound);
									if (IsLocated)
									{
										FVector2D SuitLoc = 0.5*(TempInterP + TempDoorLoc);
										PanoramaWatchPoints.Add(TempRoomId, SuitLoc);
										FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - SuitLoc;
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
										HasLocated = true;
									}
								}

								if (!HasLocated)
								{
									PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
									FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}

							}
							else if (NumOfDoors >= 2)
							{
								FVector2D TempCenter = RegionCenters[RoomIndex];
								float MaxDis = 0.0;
								int TargetDoorIndex = 0;
								for (int J = 0; J < NumOfDoors; ++J)
								{
									FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
									FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
									float TempDis = FVector2D::Distance(TempCenter, TempDoorCenter2D);
									if ((MaxDis == 0.0) || (TempDis > MaxDis))
									{
										MaxDis = TempDis;
										TargetDoorIndex = J;
									}
								}

								FVector2D TempDoorLoc = 0.25*FVector2D(DoorPoints[8 * TargetDoorIndex + 0] + DoorPoints[8 * TargetDoorIndex + 1] + DoorPoints[8 * TargetDoorIndex + 2] + DoorPoints[8 * TargetDoorIndex + 3]);
								FVector2D TempDoorVec = FVector2D(DoorPoints[8 * TargetDoorIndex + 1] - DoorPoints[8 * TargetDoorIndex + 0]);
								TempDoorVec = TempDoorVec.GetSafeNormal();
								FVector2D TempRotateOfVec = TempDoorVec.GetRotated(90);
								FVector2D TempExtendP = TempDoorLoc + 40 * TempRotateOfVec;
								bool IfInArea = FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, TempExtendP);
								bool HasLocated = false;
								if (IfInArea)
								{
									FVector2D TempInterP;
									bool IsLocated = FPolygonAlg::CalculateRayInterSectPoly(UpdateRegionPs, TempDoorLoc, TempRotateOfVec, TempInterP, DisBound);
									if (IsLocated)
									{
										FVector2D SuitLoc = 0.5*(TempInterP + TempDoorLoc);
										PanoramaWatchPoints.Add(TempRoomId, SuitLoc);
										FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - SuitLoc;
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
										HasLocated = true;
									}
								}
								else
								{
									FVector2D TempInterP;
									bool IsLocated = FPolygonAlg::CalculateRayInterSectPoly(UpdateRegionPs, TempDoorLoc, -TempRotateOfVec, TempInterP, DisBound);
									if (IsLocated)
									{
										FVector2D SuitLoc = 0.5*(TempInterP + TempDoorLoc);
										PanoramaWatchPoints.Add(TempRoomId, SuitLoc);
										FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - SuitLoc;
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
										HasLocated = true;
									}
								}

								if (!HasLocated)
								{
									PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
									FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
							}
						}
					}
				}
			}
		}
		else if ((TempRoomName == TEXT("客厅")) || (TempRoomName == TEXT("起居室")))
		{
			if (TempRoomId == LivingRoomID)
			{
				if ((LivingRoomPs.Num() != 0) && (DiningRoomPs.Num() != 0))
				{
					if ((IFInterSect) || (HasCommonPoints))
					{
						FVector2D TempCenter = 0.5*(RoomIDMapRegionCenters[LivingRoomID] + RoomIDMapRegionCenters[DiningRoomID]);
						if ((FPolygonAlg::JudgePointOnOrInPolygon(TempRegionPs, TempCenter)) || (FPolygonAlg::JudgePointOnOrInPolygon(DiningRoomPs, TempCenter)))
						{
							PanoramaWatchPoints.Add(TempRoomId, TempCenter);
							FVector2D TempDir = RoomIDMapRegionCenters[LivingRoomID] - TempCenter;
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						else
						{
							PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
							FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						TArray<FVector>DoorPoints;
						bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
						if (GetDoorSuccess)
						{
							RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
						}
					}
					else if ((!IFInterSect) && (!HasCommonPoints))
					{
						TArray<FVector>DoorPoints;
						bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
						if (!GetDoorSuccess)
						{
							PanoramaWatchPoints.Add(LivingRoomID, RoomIDMapRegionCenters[LivingRoomID]);
							FVector2D TempDir = -RoomIDMapRegionCenters[LivingRoomID];
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						else
						{
							int NumOfDoors = DoorPoints.Num() / 8;
							RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
							if (NumOfDoors == 1)
							{
								FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
								FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
								DirVec = DirVec.GetSafeNormal();
								DirVec = DirVec.GetRotated(90);
								FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
								FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
								FVector2D TempVec1 = DoorCenter2D + 80 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
								{
									PanoramaWatchPoints.Add(TempRoomId, TempVec1);
									FVector2D TempDir = RoomIDMapRegionCenters[LivingRoomID] - TempVec1;
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
								else
								{
									FVector2D TempWatchP = DoorCenter2D - 80 * DirVec;
									if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempWatchP))
									{
										PanoramaWatchPoints.Add(TempRoomId, TempWatchP);
										FVector2D TempDir = RoomIDMapRegionCenters[LivingRoomID] - TempWatchP;
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
									}
									else
									{
										PanoramaWatchPoints.Add(LivingRoomID, RoomIDMapRegionCenters[LivingRoomID]);
										FVector2D TempDir = -RoomIDMapRegionCenters[LivingRoomID];
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
									}

								}
							}
							else if (NumOfDoors >= 2)
							{
								FVector2D TempCenter = RegionCenters[RoomIndex];
								float MinDis = 0.0;
								int TargetDoorIndex = 0;
								for (int J = 0; J < NumOfDoors; ++J)
								{
									FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
									FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
									float TempDis = FVector2D::Distance(RoomIDMapRegionCenters[LivingRoomID], TempDoorCenter2D) +
										FVector2D::Distance(RoomIDMapRegionCenters[DiningRoomID], TempDoorCenter2D);
									if ((MinDis == 0.0) || (TempDis < MinDis))
									{
										MinDis = TempDis;
										TargetDoorIndex = J;
									}
								}

								FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
								FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
								DirVec = DirVec.GetSafeNormal();
								DirVec = DirVec.GetRotated(90);
								FVector DoorCenter3D = 0.25*(DoorPoints[0 + 8 * TargetDoorIndex] + DoorPoints[1 + 8 * TargetDoorIndex]
									+ DoorPoints[2 + 8 * TargetDoorIndex] + DoorPoints[3 + 8 * TargetDoorIndex]);
								FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
								FVector2D TempVec1 = DoorCenter2D + 80 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
								{
									PanoramaWatchPoints.Add(TempRoomId, TempVec1);
									FVector2D TempDir = RoomIDMapRegionCenters[LivingRoomID] - TempVec1;
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
								else
								{
									FVector2D TempWatchP = DoorCenter2D - 80 * DirVec;
									if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempWatchP))
									{
										PanoramaWatchPoints.Add(TempRoomId, TempWatchP);
										FVector2D TempDir = RoomIDMapRegionCenters[LivingRoomID] - (DoorCenter2D - 80 * DirVec);
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
									}
									else
									{
										PanoramaWatchPoints.Add(LivingRoomID, RoomIDMapRegionCenters[LivingRoomID]);
										FVector2D TempDir = -RoomIDMapRegionCenters[LivingRoomID];
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
									}

								}
							}
						}
					}
				}
				else if ((LivingRoomPs.Num() != 0) && (DiningRoomPs.Num() == 0))
				{
					TArray<FVector>DoorPoints;
					bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
					if (!GetDoorSuccess)
					{
						PanoramaWatchPoints.Add(LivingRoomID, RoomIDMapRegionCenters[LivingRoomID]);
						FVector2D TempDir = -RoomIDMapRegionCenters[LivingRoomID];
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}
					else
					{
						int NumOfDoors = DoorPoints.Num() / 8;
						RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
						if (NumOfDoors == 1)
						{
							FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
							FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
							DirVec = DirVec.GetSafeNormal();
							DirVec = DirVec.GetRotated(90);
							FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
							FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
							FVector2D TempVec1 = DoorCenter2D + 80 * DirVec;
							if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
							{
								PanoramaWatchPoints.Add(TempRoomId, TempVec1);
								FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
							}
							else
							{
								FVector2D TempP = DoorCenter2D - 80 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
								{
									PanoramaWatchPoints.Add(TempRoomId, TempP);
									FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - (DoorCenter2D - 80 * DirVec);
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
								else
								{
									PanoramaWatchPoints.Add(LivingRoomID, RoomIDMapRegionCenters[LivingRoomID]);
									FVector2D TempDir = -RoomIDMapRegionCenters[LivingRoomID];
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}

							}
						}
						else if (NumOfDoors >= 2)
						{
							FVector2D TempCenter = RegionCenters[RoomIndex];
							float MinDis = 0.0;
							int TargetDoorIndex = 0;
							for (int J = 0; J < NumOfDoors; ++J)
							{
								FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
								FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
								float TempDis = FVector2D::Distance(TempCenter, TempDoorCenter2D);
								if ((MinDis == 0.0) || (TempDis < MinDis))
								{
									MinDis = TempDis;
									TargetDoorIndex = J;
								}
							}

							FVector TempDirVec = DoorPoints[1 + 8 * TargetDoorIndex] - DoorPoints[0 + 8 * TargetDoorIndex];
							FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
							DirVec = DirVec.GetSafeNormal();
							DirVec = DirVec.GetRotated(90);
							FVector DoorCenter3D = 0.25*(DoorPoints[0 + 8 * TargetDoorIndex] + DoorPoints[1 + 8 * TargetDoorIndex]
								+ DoorPoints[2 + 8 * TargetDoorIndex] + DoorPoints[3 + 8 * TargetDoorIndex]);
							FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
							FVector2D TempVec1 = DoorCenter2D + 80 * DirVec;
							if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
							{
								PanoramaWatchPoints.Add(TempRoomId, TempVec1);
								FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);

							}
							else
							{
								FVector2D TempP = DoorCenter2D - 80 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
								{
									PanoramaWatchPoints.Add(TempRoomId, TempP);
									FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempP;
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
								else
								{
									PanoramaWatchPoints.Add(LivingRoomID, RoomIDMapRegionCenters[LivingRoomID]);
									FVector2D TempDir = -RoomIDMapRegionCenters[LivingRoomID];
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
							}
						}
					}
				}
			}
			else
			{
				PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
				FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
				TempDir = TempDir.GetSafeNormal();
				RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
			}
		}
		else if (TempRoomName == TEXT("餐厅"))
		{
			if (TempRoomId == DiningRoomID)
			{
				if ((LivingRoomPs.Num() != 0) && (DiningRoomPs.Num() != 0))
				{
					if ((IFInterSect) || (HasCommonPoints))
					{
						TArray<FVector>DoorPoints;
						FVector2D TempCenter = 0.5*(RoomIDMapRegionCenters[LivingRoomID] + RoomIDMapRegionCenters[DiningRoomID]);
						if ((FPolygonAlg::JudgePointOnOrInPolygon(TempRegionPs, TempCenter)) || (FPolygonAlg::JudgePointOnOrInPolygon(LivingRoomPs, TempCenter)))
						{
							PanoramaWatchPoints.Add(TempRoomId, TempCenter);
							FVector2D TempDir = RoomIDMapRegionCenters[DiningRoomID] - TempCenter;
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						else
						{
							PanoramaWatchPoints.Add(DiningRoomID, RoomIDMapRegionCenters[DiningRoomID]);
							FVector2D TempDir = -RoomIDMapRegionCenters[DiningRoomID];
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}

						bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
						if (GetDoorSuccess)
						{
							RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
						}
					}
					else if ((!IFInterSect) && (!HasCommonPoints))
					{
						TArray<FVector>DoorPoints;
						bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
						if (!GetDoorSuccess)
						{
							PanoramaWatchPoints.Add(DiningRoomID, RoomIDMapRegionCenters[DiningRoomID]);
							FVector2D TempDir = -RoomIDMapRegionCenters[DiningRoomID];
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						else
						{
							int NumOfDoors = DoorPoints.Num() / 8;
							RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
							if (NumOfDoors == 1)
							{
								FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
								FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
								DirVec = DirVec.GetSafeNormal();
								DirVec = DirVec.GetRotated(90);
								FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
								FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
								FVector2D TempVec1 = DoorCenter2D + 80 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
								{
									PanoramaWatchPoints.Add(TempRoomId, TempVec1);

									FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
								else
								{
									FVector2D TempP = DoorCenter2D - 80 * DirVec;
									if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
									{
										PanoramaWatchPoints.Add(TempRoomId, TempP);
										FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempP;
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
									}
									else
									{
										PanoramaWatchPoints.Add(DiningRoomID, RoomIDMapRegionCenters[DiningRoomID]);
										FVector2D TempDir = -RoomIDMapRegionCenters[DiningRoomID];
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
									}
								}
							}
							else if (NumOfDoors >= 2)
							{
								FVector2D TempCenter = RegionCenters[RoomIndex];
								float MinDis = 0.0;
								int TargetDoorIndex = 0;
								for (int J = 0; J < NumOfDoors; ++J)
								{
									FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
									FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
									float TempDis = FVector2D::Distance(RoomIDMapRegionCenters[LivingRoomID], TempDoorCenter2D) +
										FVector2D::Distance(RoomIDMapRegionCenters[DiningRoomID], TempDoorCenter2D);
									if ((MinDis == 0.0) || (TempDis < MinDis))
									{
										MinDis = TempDis;
										TargetDoorIndex = J;
									}
								}

								FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
								FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
								DirVec = DirVec.GetSafeNormal();
								DirVec = DirVec.GetRotated(90);
								FVector DoorCenter3D = 0.25*(DoorPoints[0 + 8 * TargetDoorIndex] + DoorPoints[1 + 8 * TargetDoorIndex]
									+ DoorPoints[2 + 8 * TargetDoorIndex] + DoorPoints[3 + 8 * TargetDoorIndex]);
								FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
								FVector2D TempVec1 = DoorCenter2D + 80 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
								{
									PanoramaWatchPoints.Add(TempRoomId, TempVec1);
									FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
								else
								{
									FVector2D TempP = DoorCenter2D - 80 * DirVec;
									if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
									{
										PanoramaWatchPoints.Add(TempRoomId, DoorCenter2D - 80 * DirVec);
										FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - (DoorCenter2D - 80 * DirVec);
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
									}
									else
									{
										PanoramaWatchPoints.Add(DiningRoomID, RoomIDMapRegionCenters[DiningRoomID]);
										FVector2D TempDir = -RoomIDMapRegionCenters[DiningRoomID];
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
									}

								}
							}
						}
					}
				}
				else if ((LivingRoomPs.Num() == 0) && (DiningRoomPs.Num() != 0))
				{
					TArray<FVector>DoorPoints;
					bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
					if (!GetDoorSuccess)
					{
						PanoramaWatchPoints.Add(DiningRoomID, RoomIDMapRegionCenters[DiningRoomID]);
						FVector2D TempDir = -RoomIDMapRegionCenters[DiningRoomID];
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}
					else
					{
						int NumOfDoors = DoorPoints.Num() / 8;
						RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
						if (NumOfDoors == 1)
						{
							FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
							FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
							DirVec = DirVec.GetSafeNormal();
							DirVec = DirVec.GetRotated(90);
							FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
							FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
							FVector2D TempVec1 = DoorCenter2D + 80 * DirVec;
							if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
							{
								PanoramaWatchPoints.Add(TempRoomId, TempVec1);
								FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);

							}
							else
							{
								FVector2D TempP = DoorCenter2D - 80 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
								{
									PanoramaWatchPoints.Add(TempRoomId, TempP);
									FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempP;
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
								else
								{
									PanoramaWatchPoints.Add(DiningRoomID, RoomIDMapRegionCenters[DiningRoomID]);
									FVector2D TempDir = -RoomIDMapRegionCenters[DiningRoomID];
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}

							}
						}
						else if (NumOfDoors >= 2)
						{
							FVector2D TempCenter = RegionCenters[RoomIndex];
							float MinDis = 0.0;
							int TargetDoorIndex = 0;
							for (int J = 0; J < NumOfDoors; ++J)
							{
								FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
								FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
								float TempDis = FVector2D::Distance(TempCenter, TempDoorCenter2D);
								if ((MinDis == 0.0) || (TempDis < MinDis))
								{
									MinDis = TempDis;
									TargetDoorIndex = J;
								}
							}

							FVector TempDirVec = DoorPoints[1 + 8 * TargetDoorIndex] - DoorPoints[0 + 8 * TargetDoorIndex];
							FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
							DirVec = DirVec.GetSafeNormal();
							DirVec = DirVec.GetRotated(90);
							FVector DoorCenter3D = 0.25*(DoorPoints[0 + 8 * TargetDoorIndex] + DoorPoints[1 + 8 * TargetDoorIndex]
								+ DoorPoints[2 + 8 * TargetDoorIndex] + DoorPoints[3 + 8 * TargetDoorIndex]);
							FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
							FVector2D TempVec1 = DoorCenter2D + 80 * DirVec;
							if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
							{
								PanoramaWatchPoints.Add(TempRoomId, TempVec1);
								FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
							}
							else
							{
								FVector2D TempP = DoorCenter2D - 80 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
								{
									PanoramaWatchPoints.Add(TempRoomId, TempP);
									FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempP;
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
								else
								{
									PanoramaWatchPoints.Add(DiningRoomID, RoomIDMapRegionCenters[DiningRoomID]);
									FVector2D TempDir = -RoomIDMapRegionCenters[DiningRoomID];
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
							}
						}
					}
				}
			}
			else
			{
				PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
				FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
				TempDir = TempDir.GetSafeNormal();
				RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
			}
		}
		else if ((TempRoomName == TEXT("生活阳台")) || (TempRoomName == TEXT("休闲阳台")) || (TempRoomName == TEXT("卧室阳台")))
		{
			TArray<FVector>DoorPoints;
			bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
			if (!GetDoorSuccess)
			{
				PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
				FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
				TempDir = TempDir.GetSafeNormal();
				RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
			}
			else
			{
				int NumOfDoors = DoorPoints.Num() / 8;
				RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
				if (NumOfDoors == 1)
				{
					FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
					FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
					DirVec = DirVec.GetSafeNormal();
					DirVec = DirVec.GetRotated(90);
					FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
					FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
					FVector2D PCenterToDoorCenter = RoomIDMapRegionCenters[TempRoomId] - DoorCenter2D;
					float TempDotValue = FVector2D::DotProduct(PCenterToDoorCenter, DirVec);
					FVector2D TempNode = DoorCenter2D + TempDotValue * DirVec;

					if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempNode))
					{
						PanoramaWatchPoints.Add(TempRoomId, TempNode);
						if (TempDotValue > 0)
						{
							RoomIDMapWatchDirections.Add(TempRoomId, -DirVec);
						}
						else
						{
							RoomIDMapWatchDirections.Add(TempRoomId, DirVec);
						}
					}
					else
					{
						PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
						FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}
				}
				else if (NumOfDoors >= 2)
				{
					FVector2D TempCenter = RegionCenters[RoomIndex];
					float MinDis = 0.0;
					int TargetDoorIndex = 0;
					for (int J = 0; J < NumOfDoors; ++J)
					{
						FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
						FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
						float TempDis = FVector2D::Distance(TempCenter, TempDoorCenter2D);
						if ((MinDis == 0.0) || (TempDis < MinDis))
						{
							MinDis = TempDis;
							TargetDoorIndex = J;
						}
					}

					FVector TempDirVec = DoorPoints[1 + 8 * TargetDoorIndex] - DoorPoints[0 + 8 * TargetDoorIndex];
					FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
					DirVec = DirVec.GetSafeNormal();
					DirVec = DirVec.GetRotated(90);
					FVector DoorCenter3D = 0.25*(DoorPoints[0 + 8 * TargetDoorIndex] + DoorPoints[1 + 8 * TargetDoorIndex]
						+ DoorPoints[2 + 8 * TargetDoorIndex] + DoorPoints[3 + 8 * TargetDoorIndex]);
					FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);

					FVector2D PCenterToDoorCenter = RoomIDMapRegionCenters[TempRoomId] - DoorCenter2D;
					float TempDotValue = FVector2D::DotProduct(PCenterToDoorCenter, DirVec);
					FVector2D TempNode = DoorCenter2D + TempDotValue * DirVec;

					if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempNode))
					{
						PanoramaWatchPoints.Add(TempRoomId, TempNode);
						if (TempDotValue > 0)
						{
							RoomIDMapWatchDirections.Add(TempRoomId, -DirVec);
						}
						else
						{
							RoomIDMapWatchDirections.Add(TempRoomId, DirVec);
						}
					}
					else
					{
						PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
						FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}

				}
			}
		}
		else if ((TempRoomName == TEXT("主卫")) || (TempRoomName == TEXT("客卫")) || (TempRoomName == TEXT("卫生间")))
		{
			TArray<FVector2D> UpdateRegionPs;
			FPolygonAlg::MergeCollinearPoints(TempRegionPs, UpdateRegionPs);

			bool FindWall = false;
			int TargetIndex = 0;
			for (int _CurIndex = 0; _CurIndex < IndexMapWallCenter.Num(); ++_CurIndex)
			{
				bool JudgeIfInRegion = FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, IndexMapWallCenter[_CurIndex]);
				if (JudgeIfInRegion)
				{
					FindWall = true;
					TargetIndex = _CurIndex;
					break;
				}
			}
			if (FindWall)
			{
				TArray<FVector2D> ToiletWatchPoints;
				bool LocateSecondToiletSuccess = FPolygonAlg::LocateCentersOfSecondToilet(UpdateRegionPs, IndexMapWalls2D[TargetIndex], ToiletWatchPoints);
				if (LocateSecondToiletSuccess)
				{
					FVector2D DirOfWatchPoint = ToiletWatchPoints[0] - IndexMapWallCenter[TargetIndex];
					DirOfWatchPoint = DirOfWatchPoint.GetSafeNormal();
					PanoramaWatchPoints.Add(TempRoomId, ToiletWatchPoints[0]);
					RoomIDMapWatchDirections.Add(TempRoomId, DirOfWatchPoint);
				}
				else
				{
					TArray<FVector2D> TempWallPoints = IndexMapWalls2D[TargetIndex];
					FVector2D TempSide1 = TempWallPoints[1] - TempWallPoints[0];
					FVector2D TempSide2 = TempWallPoints[2] - TempWallPoints[1];
					float LengthOfSide1 = TempSide1.Size();
					float LengthOfSide2 = TempSide2.Size();
					if (LengthOfSide1 > LengthOfSide2)
					{
						FVector2D TempDir = TempSide1.GetSafeNormal();
						FVector2D TempRotatedDir = TempDir.GetRotated(90);
						FVector2D TempExtendP = IndexMapWallCenter[TargetIndex] + TempRotatedDir * 35;
						PanoramaWatchPoints.Add(TempRoomId, TempExtendP);
						RoomIDMapWatchDirections.Add(TempRoomId, TempRotatedDir);
					}
					else
					{
						FVector2D TempDir = TempSide2.GetSafeNormal();
						FVector2D TempRotatedDir = TempDir.GetRotated(90);
						FVector2D TempExtendP = IndexMapWallCenter[TargetIndex] + TempRotatedDir * 35;
						PanoramaWatchPoints.Add(TempRoomId, TempExtendP);
						RoomIDMapWatchDirections.Add(TempRoomId, TempRotatedDir);
					}
				}
				TArray<FVector>DoorPoints;
				bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
				if (GetDoorSuccess)
				{
					int TempNumOfDoors = DoorPoints.Num() / 8;
					if (TempNumOfDoors > 0)
					{
						RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
					}
				}
			}
			else
			{
				if (UpdateRegionPs.Num() <= 6)
				{
					TArray<FVector>DoorPoints;
					bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
					if (!GetDoorSuccess)
					{
						PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
						FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}
					else
					{
						int NumOfDoors = DoorPoints.Num() / 8;
						RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
						if (NumOfDoors == 1)
						{
							FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
							FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
							DirVec = DirVec.GetSafeNormal();
							DirVec = DirVec.GetRotated(90);
							FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
							FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
							FVector2D TempVec1 = DoorCenter2D + 50 * DirVec;
							if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, TempVec1))
							{
								PanoramaWatchPoints.Add(TempRoomId, TempVec1);
								FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
							}
							else
							{
								FVector2D TempP = DoorCenter2D - 50 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, TempP))
								{
									PanoramaWatchPoints.Add(TempRoomId, TempP);
									FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempP;
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
								else
								{
									PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
									FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}

							}
						}
						else if (NumOfDoors >= 2)
						{
							FVector2D TempCenter = RegionCenters[RoomIndex];
							if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, TempCenter))
							{
								PanoramaWatchPoints.Add(TempRoomId, TempCenter);
								float MinDis = 0.0;
								int TargetDoorIndex = 0;
								for (int J = 0; J < NumOfDoors; ++J)
								{
									FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
									FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
									float TempDis = FVector2D::Distance(TempCenter, TempDoorCenter2D);
									if ((MinDis == 0.0) || (TempDis < MinDis))
									{
										MinDis = TempDis;
										TargetDoorIndex = J;
									}
								}

								FVector TempDirVec = DoorPoints[1 + 8 * TargetDoorIndex] - DoorPoints[0 + 8 * TargetDoorIndex];
								FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
								DirVec = DirVec.GetSafeNormal();
								DirVec = DirVec.GetRotated(90);
								FVector DoorCenter3D = 0.25*(DoorPoints[0 + 8 * TargetDoorIndex] + DoorPoints[1 + 8 * TargetDoorIndex] + DoorPoints[2 + 8 * TargetDoorIndex]
									+ DoorPoints[3 + 8 * TargetDoorIndex]);
								FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
								FVector2D TestVec1 = TempCenter - DoorCenter2D;
								float TestValue1 = FVector2D::DotProduct(TestVec1, DirVec);
								if (TestValue1 > 0)
								{
									RoomIDMapWatchDirections.Add(TempRoomId, DirVec);

								}
								else
								{
									RoomIDMapWatchDirections.Add(TempRoomId, -DirVec);
								}
							}
							else
							{
								PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
								FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
							}
						}
					}
				}
				else if (UpdateRegionPs.Num() >= 7)
				{
					TArray<FVector>DoorPoints;
					bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
					if (!GetDoorSuccess)
					{
						PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
						FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}
					else
					{
						int NumOfDoors = DoorPoints.Num() / 8;
						RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
						if (NumOfDoors == 1)
						{
							FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
							FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
							DirVec = DirVec.GetSafeNormal();
							DirVec = DirVec.GetRotated(90);
							FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
							FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
							PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
							FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - DoorCenter2D;
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						else if (NumOfDoors >= 2)
						{
							FVector2D TempCenter = RegionCenters[RoomIndex];
							float MinDis = 0.0;
							int TargetDoorIndex = 0;
							for (int J = 0; J < NumOfDoors; ++J)
							{
								FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
								FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
								float TempDis = FVector2D::Distance(TempCenter, TempDoorCenter2D);
								if ((MinDis == 0.0) || (TempDis < MinDis))
								{
									MinDis = TempDis;
									TargetDoorIndex = J;
								}
							}

							FVector TempDirVec = DoorPoints[1 + 8 * TargetDoorIndex] - DoorPoints[0 + 8 * TargetDoorIndex];
							FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
							DirVec = DirVec.GetSafeNormal();
							DirVec = DirVec.GetRotated(90);
							FVector DoorCenter3D = 0.25*(DoorPoints[0 + 8 * TargetDoorIndex] + DoorPoints[1 + 8 * TargetDoorIndex] + DoorPoints[2 + 8 * TargetDoorIndex]
								+ DoorPoints[3 + 8 * TargetDoorIndex]);
							FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
							PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
							FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - DoorCenter2D;
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
					}
				}
			}
		}
		else if (TempRoomName == TEXT("厨房"))
		{
			if ((!IsOpenKitchen1) && (!IsOpenKitchen2))
			{
				TArray<FVector>DoorPoints;
				bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
				if (!GetDoorSuccess)
				{
					PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
					FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
					TempDir = TempDir.GetSafeNormal();
					RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
				}
				else
				{
					int NumOfDoors = DoorPoints.Num() / 8;
					RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
					if (NumOfDoors == 1)
					{
						FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
						FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
						DirVec = DirVec.GetSafeNormal();
						DirVec = DirVec.GetRotated(90);
						FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
						FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
						FVector2D TempVec1 = DoorCenter2D + 35 * DirVec;
						if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
						{
							PanoramaWatchPoints.Add(TempRoomId, TempVec1);
							FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						else
						{
							FVector2D TempP = DoorCenter2D - 35 * DirVec;
							if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
							{
								PanoramaWatchPoints.Add(TempRoomId, TempP);
								FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempP;
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
							}
							else
							{
								PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
								FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
							}

						}
					}
					else if (NumOfDoors >= 2)
					{
						FVector2D TempCenter = RegionCenters[RoomIndex];
						float MinDis = 0.0;
						int TargetDoorIndex = 0;
						for (int J = 0; J < NumOfDoors; ++J)
						{
							FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
							FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
							float TempDis = FVector2D::Distance(TempCenter, TempDoorCenter2D);
							if ((MinDis == 0.0) || (TempDis < MinDis))
							{
								MinDis = TempDis;
								TargetDoorIndex = J;
							}
						}

						FVector TempDirVec = DoorPoints[1 + 8 * TargetDoorIndex] - DoorPoints[0 + 8 * TargetDoorIndex];
						FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
						DirVec = DirVec.GetSafeNormal();
						DirVec = DirVec.GetRotated(90);
						FVector DoorCenter3D = 0.25*(DoorPoints[0 + 8 * TargetDoorIndex] + DoorPoints[1 + 8 * TargetDoorIndex]
							+ DoorPoints[2 + 8 * TargetDoorIndex] + DoorPoints[3 + 8 * TargetDoorIndex]);
						FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);

						FVector2D TempVec1 = DoorCenter2D + 35 * DirVec;
						if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
						{
							PanoramaWatchPoints.Add(TempRoomId, TempVec1);
							FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						else
						{
							FVector2D TempP = DoorCenter2D - 35 * DirVec;
							if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
							{
								PanoramaWatchPoints.Add(TempRoomId, TempP);
								FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempP;
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
							}
							else
							{
								PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
								FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
							}
						}
					}
				}
			}
			else if ((IsOpenKitchen1) || (IsOpenKitchen2))
			{
				TArray<FVector>DoorPoints;
				PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
				FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
				TempDir = TempDir.GetSafeNormal();
				RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
				bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
				if (GetDoorSuccess)
				{
					RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
				}
			}
		}
		else if (TempRoomName == TEXT("储藏间"))
		{
			TArray<FVector>DoorPoints;
			bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
			if (!GetDoorSuccess)
			{
				PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
				FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
				TempDir = TempDir.GetSafeNormal();
				RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
			}
			else
			{
				int NumOfDoors = DoorPoints.Num() / 8;
				RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
				if (NumOfDoors == 1)
				{
					FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
					FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
					DirVec = DirVec.GetSafeNormal();
					DirVec = DirVec.GetRotated(90);
					FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
					FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
					FVector2D TempVec1 = DoorCenter2D + 20 * DirVec;
					if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
					{
						PanoramaWatchPoints.Add(TempRoomId, TempVec1);
						FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}
					else
					{
						FVector2D TempP = DoorCenter2D - 20 * DirVec;
						if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
						{
							PanoramaWatchPoints.Add(TempRoomId, TempP);
							FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempP;
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						else
						{
							PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
							FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}

					}
				}
				else if (NumOfDoors >= 2)
				{
					FVector2D TempCenter = RegionCenters[RoomIndex];
					float MaxDis = 0.0;
					int TargetDoorIndex = 0;
					for (int J = 0; J < NumOfDoors; ++J)
					{
						FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
						FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
						float TempDis = FVector2D::Distance(TempCenter, TempDoorCenter2D);
						if ((MaxDis == 0.0) || (TempDis > MaxDis))
						{
							MaxDis = TempDis;
							TargetDoorIndex = J;
						}
					}

					FVector TempDirVec = DoorPoints[1 + 8 * TargetDoorIndex] - DoorPoints[0 + 8 * TargetDoorIndex];
					FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
					DirVec = DirVec.GetSafeNormal();
					DirVec = DirVec.GetRotated(90);
					FVector DoorCenter3D = 0.25*(DoorPoints[0 + 8 * TargetDoorIndex] + DoorPoints[1 + 8 * TargetDoorIndex] +
						DoorPoints[2 + 8 * TargetDoorIndex] + DoorPoints[3 + 8 * TargetDoorIndex]);
					FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
					FVector2D TempVec1 = DoorCenter2D + 20 * DirVec;
					if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
					{
						PanoramaWatchPoints.Add(TempRoomId, TempVec1);
						FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}
					else
					{
						FVector2D TempP = DoorCenter2D - 20 * DirVec;
						if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
						{
							PanoramaWatchPoints.Add(TempRoomId, TempP);
							FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempP;
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						else
						{
							PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
							FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}

					}
				}
			}
		}
		else if ((TempRoomName == TEXT("衣帽间")) || (TempRoomName == TEXT("茶室")))
		{
			TArray<FVector>DoorPoints;
			bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
			if (!GetDoorSuccess)
			{
				PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
				FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
				TempDir = TempDir.GetSafeNormal();
				RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
			}
			else
			{
				int NumOfDoors = DoorPoints.Num() / 8;
				RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
				if (NumOfDoors == 1)
				{
					FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
					FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
					DirVec = DirVec.GetSafeNormal();
					DirVec = DirVec.GetRotated(90);
					FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
					FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
					FVector2D TempVec1 = DoorCenter2D + 35 * DirVec;
					if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
					{
						PanoramaWatchPoints.Add(TempRoomId, TempVec1);
						FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}
					else
					{
						FVector2D TempP = DoorCenter2D - 35 * DirVec;
						if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
						{
							PanoramaWatchPoints.Add(TempRoomId, TempP);
							FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempP;
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						else
						{
							PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
							FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}

					}
				}
				else if (NumOfDoors >= 2)
				{
					FVector2D TempCenter = RegionCenters[RoomIndex];
					float MaxDis = 0.0;
					int TargetDoorIndex = 0;
					for (int J = 0; J < NumOfDoors; ++J)
					{
						FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
						FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
						float TempDis = FVector2D::Distance(TempCenter, TempDoorCenter2D);
						if ((MaxDis == 0.0) || (TempDis > MaxDis))
						{
							MaxDis = TempDis;
							TargetDoorIndex = J;
						}
					}

					FVector TempDirVec = DoorPoints[1 + 8 * TargetDoorIndex] - DoorPoints[0 + 8 * TargetDoorIndex];
					FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
					DirVec = DirVec.GetSafeNormal();
					DirVec = DirVec.GetRotated(90);
					FVector DoorCenter3D = 0.25*(DoorPoints[0 + 8 * TargetDoorIndex] + DoorPoints[1 + 8 * TargetDoorIndex] +
						DoorPoints[2 + 8 * TargetDoorIndex] + DoorPoints[3 + 8 * TargetDoorIndex]);
					FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
					FVector2D TempVec1 = DoorCenter2D + 35 * DirVec;
					if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
					{
						PanoramaWatchPoints.Add(TempRoomId, TempVec1);
						FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}
					else
					{
						FVector2D TempP = DoorCenter2D - 35 * DirVec;
						if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
						{
							PanoramaWatchPoints.Add(TempRoomId, TempP);
							FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempP;
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						else
						{
							PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
							FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}

					}
				}
			}
		}
	}
	//////////////////修正客厅以及餐厅观察点///////////////////////////////
	if ((IFInterSect) || (HasCommonPoints))
	{
		FVector2D LivingPickP = RoomIDMapRegionCenters[LivingRoomID];
		FVector2D DiningPickP = RoomIDMapRegionCenters[DiningRoomID];
		FVector2D UpdateFirstPoint, UpdateSecondPoint, UpdateWatchPoint;
		bool IsAdjusted = FPolygonAlg::AdjustWatchAndPickPoints(LivingPickP, DiningPickP, LivingRoomPs, DiningRoomPs, UpdateFirstPoint, UpdateSecondPoint, UpdateWatchPoint);
		if (IsAdjusted)
		{
			PanoramaWatchPoints[LivingRoomID] = UpdateWatchPoint;
			PanoramaWatchPoints[DiningRoomID] = UpdateWatchPoint;
			RoomIDMapRegionCenters[LivingRoomID] = UpdateFirstPoint;
			RoomIDMapRegionCenters[DiningRoomID] = UpdateSecondPoint;
			FVector2D TempDir = UpdateWatchPoint - UpdateFirstPoint;
			TempDir = TempDir.GetSafeNormal();
			RoomIDMapWatchDirections[LivingRoomID] = -TempDir;
			RoomIDMapWatchDirections[DiningRoomID] = TempDir;
		}
	}
	/////////////////////修正第三厅与第四厅的观察点////////////////////////
	if ((IFInterSectOfThirdAndFourth) || (HasCommonPointsOfThirdAndFourth))
	{
		FVector2D ThirdPickP = RoomIDMapRegionCenters[ThirdDingingRoomID];
		FVector2D FourthPickP = RoomIDMapRegionCenters[FourthDiningRoomID];
		FVector2D UpdateFirstPoint, UpdateSecondPoint, UpdateWatchPoint;
		bool IsChangedThirdAndFourth = FPolygonAlg::AdjustWatchAndPickPoints(ThirdPickP, FourthPickP, ThirdDinging, FourthDining, UpdateFirstPoint, UpdateSecondPoint, UpdateWatchPoint);
		if (IsChangedThirdAndFourth)
		{
			PanoramaWatchPoints[ThirdDingingRoomID] = UpdateWatchPoint;
			PanoramaWatchPoints[FourthDiningRoomID] = UpdateWatchPoint;
			RoomIDMapRegionCenters[ThirdDingingRoomID] = UpdateFirstPoint;
			RoomIDMapRegionCenters[FourthDiningRoomID] = UpdateSecondPoint;
			FVector2D TempDir = UpdateWatchPoint - UpdateFirstPoint;
			TempDir = TempDir.GetSafeNormal();
			RoomIDMapWatchDirections[ThirdDingingRoomID] = -TempDir;
			RoomIDMapWatchDirections[FourthDiningRoomID] = TempDir;
		}
	}

	/////////////////计算空间区域母子关系//////////////////////////////////
	TArray<FParentRoom>  ParentRooms;
	TMap<int, TArray<int>> ParentMapChildren;
	TArray<int> PossibleParentRoomIDs;
	bool PreCalSuccess = CalculateParentRelation(WorldContextObject, InJson, PossibleParentRoomIDs, ParentRooms);
	if (PreCalSuccess)
	{
		for (int _CurPar = 0; _CurPar < ParentRooms.Num(); ++_CurPar)
		{
			TArray<int> TempChildren = ParentRooms[_CurPar].RoomIDs;
			ParentMapChildren.Add(ParentRooms[_CurPar].ParentRoomID, TempChildren);
		}
	}

	////////////设置全景图观察点以及门洞数据的Json
	TArray<UVaRestJsonObject*> PanoramaWatchPointArray;
	int PanoraPointOrder = NumOfTotalPickPs;

	int NumOfFloors = GroupRoomIDs.Num();
	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}

		if (TempString == TEXT("客厅"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);
			SinglePointObj->SetNumberField("parentroomid", 0);
			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			SinglePointObj->SetNumberField("z", 130);
			if (NumOfFloors == 1)
			{
				SinglePointObj->SetNumberField("floor", 1);
			}
			else if (NumOfFloors == 2)
			{
				for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
				{
					TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
					if (TempRoomIDs.Contains(AllRoomIDs[Index]))
					{
						SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
					}
				}
			}

			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);
			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("客厅"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);

			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);

			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}

	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("餐厅"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);
			SinglePointObj->SetNumberField("parentroomid", 0);
			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			SinglePointObj->SetNumberField("z", 130);

			if (NumOfFloors == 1)
			{
				SinglePointObj->SetNumberField("floor", 1);
			}
			else if (NumOfFloors == 2)
			{
				for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
				{
					TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
					if (TempRoomIDs.Contains(AllRoomIDs[Index]))
					{
						SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
					}
				}
			}

			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);
			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("餐厅"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);

			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}


	TMap<int, int> SpecialRoomIDMapPointID;
	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("主卧"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);
			SpecialRoomIDMapPointID.Add(TempRoomID, PanoraPointOrder);
			SinglePointObj->SetNumberField("parentroomid", 0);
			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			if (SpecialRoomIDs.Contains(AllRoomIDs[Index]))
			{
				SinglePointObj->SetNumberField("z", 120);
			}
			else
			{
				SinglePointObj->SetNumberField("z", 130);
			}


			if (NumOfFloors == 1)
			{
				SinglePointObj->SetNumberField("floor", 1);
			}
			else if (NumOfFloors == 2)
			{
				for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
				{
					TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
					if (TempRoomIDs.Contains(AllRoomIDs[Index]))
					{
						SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
					}
				}
			}

			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("主卧"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);


			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}

	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];

		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("次卧"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);
			SinglePointObj->SetNumberField("parentroomid", 0);
			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			if (SpecialRoomIDs.Contains(AllRoomIDs[Index]))
			{
				SinglePointObj->SetNumberField("z", 120);
			}
			else
			{
				SinglePointObj->SetNumberField("z", 130);
			}

			if (NumOfFloors == 1)
			{
				SinglePointObj->SetNumberField("floor", 1);
			}
			else if (NumOfFloors == 2)
			{
				for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
				{
					TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
					if (TempRoomIDs.Contains(AllRoomIDs[Index]))
					{
						SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
					}
				}
			}

			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("次卧"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);


			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}

	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("儿童房"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);
			SinglePointObj->SetNumberField("parentroomid", 0);
			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			if (SpecialRoomIDs.Contains(AllRoomIDs[Index]))
			{
				SinglePointObj->SetNumberField("z", 120);
			}
			else
			{
				SinglePointObj->SetNumberField("z", 130);
			}

			if (NumOfFloors == 1)
			{
				SinglePointObj->SetNumberField("floor", 1);
			}
			else if (NumOfFloors == 2)
			{
				for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
				{
					TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
					if (TempRoomIDs.Contains(AllRoomIDs[Index]))
					{
						SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
					}
				}
			}

			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("儿童房"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);

			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}

	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("老人房"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);
			SinglePointObj->SetNumberField("parentroomid", 0);
			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			if (SpecialRoomIDs.Contains(AllRoomIDs[Index]))
			{
				SinglePointObj->SetNumberField("z", 120);
			}
			else
			{
				SinglePointObj->SetNumberField("z", 130);
			}

			if (NumOfFloors == 1)
			{
				SinglePointObj->SetNumberField("floor", 1);
			}
			else if (NumOfFloors == 2)
			{
				for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
				{
					TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
					if (TempRoomIDs.Contains(AllRoomIDs[Index]))
					{
						SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
					}
				}
			}

			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("老人房"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);


			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}


	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("书房"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);
			SinglePointObj->SetNumberField("parentroomid", 0);
			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			if (SpecialRoomIDs.Contains(AllRoomIDs[Index]))
			{
				SinglePointObj->SetNumberField("z", 120);
			}
			else
			{
				SinglePointObj->SetNumberField("z", 130);
			}

			if (NumOfFloors == 1)
			{
				SinglePointObj->SetNumberField("floor", 1);
			}
			else if (NumOfFloors == 2)
			{
				for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
				{
					TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
					if (TempRoomIDs.Contains(AllRoomIDs[Index]))
					{
						SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
					}
				}
			}

			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("书房"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);


			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}

	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("榻榻米房"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);
			SinglePointObj->SetNumberField("parentroomid", 0);
			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			if (SpecialRoomIDs.Contains(AllRoomIDs[Index]))
			{
				SinglePointObj->SetNumberField("z", 120);
			}
			else
			{
				SinglePointObj->SetNumberField("z", 130);
			}

			if (NumOfFloors == 1)
			{
				SinglePointObj->SetNumberField("floor", 1);
			}
			else if (NumOfFloors == 2)
			{
				for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
				{
					TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
					if (TempRoomIDs.Contains(AllRoomIDs[Index]))
					{
						SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
					}
				}
			}

			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("榻榻米房"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);


			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}


	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("客人房"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);
			SinglePointObj->SetNumberField("parentroomid", 0);
			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			if (SpecialRoomIDs.Contains(AllRoomIDs[Index]))
			{
				SinglePointObj->SetNumberField("z", 120);
			}
			else
			{
				SinglePointObj->SetNumberField("z", 130);
			}

			if (NumOfFloors == 1)
			{
				SinglePointObj->SetNumberField("floor", 1);
			}
			else if (NumOfFloors == 2)
			{
				for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
				{
					TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
					if (TempRoomIDs.Contains(AllRoomIDs[Index]))
					{
						SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
					}
				}
			}


			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("客人房"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);


			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}




	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("健身房"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);
			SinglePointObj->SetNumberField("parentroomid", 0);
			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			if (SpecialRoomIDs.Contains(AllRoomIDs[Index]))
			{
				SinglePointObj->SetNumberField("z", 120);
			}
			else
			{
				SinglePointObj->SetNumberField("z", 130);
			}

			if (NumOfFloors == 1)
			{
				SinglePointObj->SetNumberField("floor", 1);
			}
			else if (NumOfFloors == 2)
			{
				for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
				{
					TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
					if (TempRoomIDs.Contains(AllRoomIDs[Index]))
					{
						SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
					}
				}
			}

			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("健身房"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);


			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}


	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("衣帽间"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);

			bool LocalFindParent = false;
			for (int _CurPar = 0; _CurPar < ParentMapChildren.Num(); ++_CurPar)
			{
				for (int Index = 0; Index < PossibleParentRoomIDs.Num(); ++Index)
				{
					if (ParentMapChildren.Contains(PossibleParentRoomIDs[Index]))
					{
						TArray<int> TempChildren = ParentMapChildren[PossibleParentRoomIDs[Index]];
						if (TempChildren.Contains(TempRoomID))
						{
							SinglePointObj->SetNumberField("parentroomid", PossibleParentRoomIDs[Index]);
							LocalFindParent = true;
							break;
						}
					}
				}
			}
			if (!LocalFindParent)
			{
				SinglePointObj->SetNumberField("parentroomid", 0);
			}

			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			SinglePointObj->SetNumberField("z", 130);

			if (NumOfFloors == 1)
			{
				SinglePointObj->SetNumberField("floor", 1);
			}
			else if (NumOfFloors == 2)
			{
				for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
				{
					TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
					if (TempRoomIDs.Contains(AllRoomIDs[Index]))
					{
						SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
					}
				}
			}

			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("衣帽间"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);


			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}

			PanoramaWatchPointArray.Add(TempPoint);
		}
	}

	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("储藏间"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);
			SinglePointObj->SetNumberField("parentroomid", 0);
			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			SinglePointObj->SetNumberField("z", 130);

			if (NumOfFloors == 1)
			{
				SinglePointObj->SetNumberField("floor", 1);
			}
			else if (NumOfFloors == 2)
			{
				for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
				{
					TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
					if (TempRoomIDs.Contains(AllRoomIDs[Index]))
					{
						SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
					}
				}
			}

			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("储藏间"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);


			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}

	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}

		if (TempString == TEXT("起居室"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);
			SinglePointObj->SetNumberField("parentroomid", 0);
			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			SinglePointObj->SetNumberField("z", 130);
			if (NumOfFloors == 1)
			{
				SinglePointObj->SetNumberField("floor", 1);
			}
			else if (NumOfFloors == 2)
			{
				for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
				{
					TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
					if (TempRoomIDs.Contains(AllRoomIDs[Index]))
					{
						SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
					}
				}
			}

			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);
			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("起居室"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);

			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}

	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("多功能房"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);
			SinglePointObj->SetNumberField("parentroomid", 0);
			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			if (SpecialRoomIDs.Contains(AllRoomIDs[Index]))
			{
				SinglePointObj->SetNumberField("z", 120);
			}
			else
			{
				SinglePointObj->SetNumberField("z", 130);
			}

			if (NumOfFloors == 1)
			{
				SinglePointObj->SetNumberField("floor", 1);
			}
			else if (NumOfFloors == 2)
			{
				for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
				{
					TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
					if (TempRoomIDs.Contains(AllRoomIDs[Index]))
					{
						SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
					}
				}
			}

			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("多功能房"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);


			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}

	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("茶室"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);
			SinglePointObj->SetNumberField("parentroomid", 0);
			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			SinglePointObj->SetNumberField("z", 130);

			if (NumOfFloors == 1)
			{
				SinglePointObj->SetNumberField("floor", 1);
			}
			else if (NumOfFloors == 2)
			{
				for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
				{
					TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
					if (TempRoomIDs.Contains(AllRoomIDs[Index]))
					{
						SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
					}
				}
			}

			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("茶室"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);

			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}



	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("厨房"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);
			SinglePointObj->SetNumberField("parentroomid", 0);
			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			SinglePointObj->SetNumberField("z", 130);

			if (NumOfFloors == 1)
			{
				SinglePointObj->SetNumberField("floor", 1);
			}
			else if (NumOfFloors == 2)
			{
				for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
				{
					TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
					if (TempRoomIDs.Contains(AllRoomIDs[Index]))
					{
						SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
					}
				}
			}

			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("厨房"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);

			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}


	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("主卫"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);

			bool LocalFindParent = false;
			for (int _CurPar = 0; _CurPar < ParentMapChildren.Num(); ++_CurPar)
			{
				for (int Index = 0; Index < PossibleParentRoomIDs.Num(); ++Index)
				{
					if (ParentMapChildren.Contains(PossibleParentRoomIDs[Index]))
					{
						TArray<int> TempChildren = ParentMapChildren[PossibleParentRoomIDs[Index]];
						if (TempChildren.Contains(TempRoomID))
						{
							SinglePointObj->SetIntegerField("parentroomid", PossibleParentRoomIDs[Index]);
							LocalFindParent = true;
							break;
						}
					}
				}
			}
			if (!LocalFindParent)
			{
				SinglePointObj->SetNumberField("parentroomid", 0);
			}

			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			SinglePointObj->SetNumberField("z", 130);

			if (NumOfFloors == 1)
			{
				SinglePointObj->SetNumberField("floor", 1);
			}
			else if (NumOfFloors == 2)
			{
				for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
				{
					TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
					if (TempRoomIDs.Contains(AllRoomIDs[Index]))
					{
						SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
					}
				}
			}

			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("主卫"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);

			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}


	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("客卫"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);
			SinglePointObj->SetNumberField("parentroomid", 0);

			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			SinglePointObj->SetNumberField("z", 130);

			if (NumOfFloors == 1)
			{
				SinglePointObj->SetNumberField("floor", 1);
			}
			else if (NumOfFloors == 2)
			{
				for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
				{
					TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
					if (TempRoomIDs.Contains(AllRoomIDs[Index]))
					{
						SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
					}
				}
			}

			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("客卫"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);


			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}


	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("卫生间"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);

			bool LocalFindParent = false;
			for (int _CurPar = 0; _CurPar < ParentMapChildren.Num(); ++_CurPar)
			{
				for (int Index = 0; Index < PossibleParentRoomIDs.Num(); ++Index)
				{
					if (ParentMapChildren.Contains(PossibleParentRoomIDs[Index]))
					{
						TArray<int> TempChildren = ParentMapChildren[PossibleParentRoomIDs[Index]];
						if (TempChildren.Contains(TempRoomID))
						{
							SinglePointObj->SetNumberField("parentroomid", PossibleParentRoomIDs[Index]);
							LocalFindParent = true;
							break;
						}
					}
				}
			}
			if (!LocalFindParent)
			{
				SinglePointObj->SetNumberField("parentroomid", 0);
			}

			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			SinglePointObj->SetNumberField("z", 130);

			if (NumOfFloors == 1)
			{
				SinglePointObj->SetNumberField("floor", 1);
			}
			else if (NumOfFloors == 2)
			{
				for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
				{
					TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
					if (TempRoomIDs.Contains(AllRoomIDs[Index]))
					{
						SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
					}
				}
			}

			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);
			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("卫生间"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);

			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}




	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("生活阳台"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);

			bool LocalFindParent = false;
			for (int _CurPar = 0; _CurPar < ParentMapChildren.Num(); ++_CurPar)
			{
				for (int Index = 0; Index < PossibleParentRoomIDs.Num(); ++Index)
				{
					if (ParentMapChildren.Contains(PossibleParentRoomIDs[Index]))
					{
						TArray<int> TempChildren = ParentMapChildren[PossibleParentRoomIDs[Index]];
						if (TempChildren.Contains(TempRoomID))
						{
							SinglePointObj->SetNumberField("parentroomid", PossibleParentRoomIDs[Index]);
							LocalFindParent = true;
							break;
						}
					}
				}
			}
			if (!LocalFindParent)
			{
				SinglePointObj->SetNumberField("parentroomid", 0);
			}


			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			SinglePointObj->SetNumberField("z", 130);

			if (NumOfFloors == 1)
			{
				SinglePointObj->SetNumberField("floor", 1);
			}
			else if (NumOfFloors == 2)
			{
				for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
				{
					TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
					if (TempRoomIDs.Contains(AllRoomIDs[Index]))
					{
						SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
					}
				}
			}

			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("生活阳台"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);

			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}


	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("休闲阳台"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);

			bool LocalFindParent = false;
			for (int _CurPar = 0; _CurPar < ParentMapChildren.Num(); ++_CurPar)
			{
				for (int Index = 0; Index < PossibleParentRoomIDs.Num(); ++Index)
				{
					if (ParentMapChildren.Contains(PossibleParentRoomIDs[Index]))
					{
						TArray<int> TempChildren = ParentMapChildren[PossibleParentRoomIDs[Index]];
						if (TempChildren.Contains(TempRoomID))
						{
							SinglePointObj->SetNumberField("parentroomid", PossibleParentRoomIDs[Index]);
							LocalFindParent = true;
							break;
						}
					}
				}
			}
			if (!LocalFindParent)
			{
				SinglePointObj->SetNumberField("parentroomid", 0);
			}

			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			SinglePointObj->SetNumberField("z", 130);

			if (NumOfFloors == 1)
			{
				SinglePointObj->SetNumberField("floor", 1);
			}
			else if (NumOfFloors == 2)
			{
				for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
				{
					TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
					if (TempRoomIDs.Contains(AllRoomIDs[Index]))
					{
						SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
					}
				}
			}

			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("休闲阳台"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);

			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}


	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("卧室阳台"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);

			bool LocalFindParent = false;
			for (int _CurPar = 0; _CurPar < ParentMapChildren.Num(); ++_CurPar)
			{
				for (int Index = 0; Index < PossibleParentRoomIDs.Num(); ++Index)
				{
					if (ParentMapChildren.Contains(PossibleParentRoomIDs[Index]))
					{
						TArray<int> TempChildren = ParentMapChildren[PossibleParentRoomIDs[Index]];
						if (TempChildren.Contains(TempRoomID))
						{
							SinglePointObj->SetNumberField("parentroomid", PossibleParentRoomIDs[Index]);
							LocalFindParent = true;
							break;
						}
					}
				}
			}
			if (!LocalFindParent)
			{
				SinglePointObj->SetNumberField("parentroomid", 0);
			}


			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			SinglePointObj->SetNumberField("z", 130);

			if (NumOfFloors == 1)
			{
				SinglePointObj->SetNumberField("floor", 1);
			}
			else if (NumOfFloors == 2)
			{
				for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
				{
					TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
					if (TempRoomIDs.Contains(AllRoomIDs[Index]))
					{
						SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
					}
				}
			}

			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("卧室阳台"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);

			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}

			PanoramaWatchPointArray.Add(TempPoint);
		}
	}


	OutPanoramaJson->SetObjectArrayField("panoramaLocation", PanoramaWatchPointArray);
	//////////////计算客厅走廊以及玄关位置//////////////////
	UVaRestJsonObject *SegmentsJson = UVaRestJsonObject::ConstructJsonObject(WorldContextObject);
	if (RoomIDMapHoleData.Contains(LivingRoomID))
	{
		TArray<FVector> LivingRoomHoleData = RoomIDMapHoleData[LivingRoomID];
		bool CreateSegsSuccess = CreateSegmentsJson(WorldContextObject, LivingRoomPs, LivingRoomID, LivingRoomHoleData, SegmentsJson);
		if (CreateSegsSuccess)
		{
			OutPanoramaJson->MergeJsonObject(SegmentsJson, true);
		}
	}
	/////////////////////////////计算墙体上下前后四个面归属区域的关系///////////////////////////////
	////////////////////////////////////////定位边界墙///////////////////////////////////////////////
	TArray<int> BoundaryWallIndexs;
	TMap<int, int> BoundaryWallIndexMapRoomID, FirstGroupWallIndexMapRoomID, SecondGroupWallIndexMapRoomID;
	for (int _CurWall = 0; _CurWall < IndexMapWalls2D.Num(); ++_CurWall)
	{
		TArray<FVector2D> MapWallPs = IndexMapWalls2D[_CurWall];
		FVector2D LocalWallCenter = 0.25*(MapWallPs[0] + MapWallPs[1] + MapWallPs[2] + MapWallPs[3]);
		FVector2D CenterOfSide1 = 0.5*(MapWallPs[0] + MapWallPs[3]);
		FVector2D CenterOfSide2 = 0.5*(MapWallPs[1] + MapWallPs[2]);
		FVector2D DirOfSide1 = MapWallPs[3] - MapWallPs[0];
		FVector2D DirOfSide2 = MapWallPs[2] - MapWallPs[1];
		float LengthOfSide1 = DirOfSide1.Size();
		float LengthOfSide2 = DirOfSide2.Size();
		DirOfSide1.Normalize();
		DirOfSide2.Normalize();
		FVector2D TempCenter1 = 0.5*(MapWallPs[0] + MapWallPs[3]);
		FVector2D TempCenter2 = 0.5*(MapWallPs[1] + MapWallPs[2]);
		FVector2D TempBaseDir = DirOfSide2;
		FVector2D TempBaseCenter = TempCenter2;
		if (DirOfSide1 < DirOfSide2)
		{
			TempBaseDir = DirOfSide1;
		}
		FVector2D TempRotatedDirOfLine = TempBaseDir.GetRotated(90);

		FVector2D TempExtendP1 = TempBaseCenter + 30 * TempRotatedDirOfLine;
		FVector2D TempExtendP2 = TempBaseCenter - 30 * TempRotatedDirOfLine;

		FVector2D WallCenterPointToFirst = MapWallPs[0] - LocalWallCenter;
		int TempCount1 = 0;
		int TempCount2 = 0;
		bool IsP1InRegion = false;
		bool IsP2InRegion = false;
		int TempRoomId1 = 0;
		int TempRoomId2 = 0;
		for (int _CurRoom = 0; _CurRoom < AllRoomIDs.Num(); ++_CurRoom)
		{
			if (RoomIDMapRegions.Contains(AllRoomIDs[_CurRoom]))
			{
				IsP1InRegion = FPolygonAlg::JudgePointInPolygon(RoomIDMapRegions[AllRoomIDs[_CurRoom]], TempExtendP1);
				IsP2InRegion = FPolygonAlg::JudgePointInPolygon(RoomIDMapRegions[AllRoomIDs[_CurRoom]], TempExtendP2);
				if (IsP1InRegion)
				{
					TempCount1++;
					TempRoomId1 = AllRoomIDs[_CurRoom];
				}
				if (IsP2InRegion)
				{
					TempCount2++;
					TempRoomId2 = AllRoomIDs[_CurRoom];
				}
			}
		}
		if (TempCount1 + TempCount2 == 1)
		{
			BoundaryWallIndexs.Add(_CurWall);
			if (TempRoomId1 != 0)
			{
				BoundaryWallIndexMapRoomID.Add(_CurWall, TempRoomId1);
			}
			if (TempRoomId2 != 0)
			{
				BoundaryWallIndexMapRoomID.Add(_CurWall, TempRoomId2);
			}
		}
		else if ((TempCount1 == 1) && (TempCount2 == 1))
		{
			float VecDotValue = FVector2D::DotProduct(WallCenterPointToFirst, TempRotatedDirOfLine);
			if (VecDotValue > 0.0f)
			{
				FirstGroupWallIndexMapRoomID.Add(_CurWall, TempRoomId1);
				SecondGroupWallIndexMapRoomID.Add(_CurWall, TempRoomId2);
			}
			else
			{
				FirstGroupWallIndexMapRoomID.Add(_CurWall, TempRoomId2);
				SecondGroupWallIndexMapRoomID.Add(_CurWall, TempRoomId1);
			}
		}
	}

	///////////////////////////增加墙体归属关系到json数据里/////////////////////////////////////////

	TArray<UVaRestJsonObject*> WallRelationJson;
	for (int WallIndex = 0; WallIndex < IndexMapWalls.Num(); ++WallIndex)
	{
		TArray<UVaRestJsonObject*> TempJsonArr;
		//////////边界墙体的面归属信息塞进json///////////////////////////
		if (BoundaryWallIndexs.Contains(WallIndex))
		{
			for (int _CurFace = 0; _CurFace < 4; ++_CurFace)
			{
				UVaRestJsonObject* EachJson = NewObject<UVaRestJsonObject>();
				if (_CurFace == 0)
				{
					TArray<int> TempFaceIDArray1;
					TempFaceIDArray1.Add(0);
					TempFaceIDArray1.Add(1);
					TempFaceIDArray1.Add(2);
					TempFaceIDArray1.Add(3);
					EachJson->SetIntegerArrayField("index", TempFaceIDArray1);
					int TempMappedRoom = 0;
					if (BoundaryWallIndexMapRoomID.Contains(WallIndex))
					{
						TempMappedRoom = BoundaryWallIndexMapRoomID[WallIndex];
					}

					EachJson->SetIntegerField("roomId", TempMappedRoom);
					TempJsonArr.Add(EachJson);
				}
				else if (_CurFace == 1)
				{
					TArray<int> TempFaceIDArray2;
					TempFaceIDArray2.Add(4);
					TempFaceIDArray2.Add(5);
					TempFaceIDArray2.Add(6);
					TempFaceIDArray2.Add(7);
					EachJson->SetIntegerArrayField("index", TempFaceIDArray2);
					int TempMappedRoom = 0;
					if (BoundaryWallIndexMapRoomID.Contains(WallIndex))
					{
						TempMappedRoom = BoundaryWallIndexMapRoomID[WallIndex];
					}

					EachJson->SetIntegerField("roomId", TempMappedRoom);
					TempJsonArr.Add(EachJson);
				}
				else if (_CurFace == 2)
				{
					TArray<int> TempFaceIDArray3;
					TempFaceIDArray3.Add(5);
					TempFaceIDArray3.Add(0);
					TempFaceIDArray3.Add(3);
					TempFaceIDArray3.Add(6);
					EachJson->SetIntegerArrayField("index", TempFaceIDArray3);
					int TempMappedRoom = 0;
					if (BoundaryWallIndexMapRoomID.Contains(WallIndex))
					{
						TempMappedRoom = BoundaryWallIndexMapRoomID[WallIndex];
					}

					EachJson->SetIntegerField("roomId", TempMappedRoom);
					TempJsonArr.Add(EachJson);
				}
				else if (_CurFace == 3)
				{
					TArray<int> TempFaceIDArray4;
					TempFaceIDArray4.Add(2);
					TempFaceIDArray4.Add(1);
					TempFaceIDArray4.Add(4);
					TempFaceIDArray4.Add(7);
					EachJson->SetIntegerArrayField("index", TempFaceIDArray4);
					int TempMappedRoom = 0;
					if (BoundaryWallIndexMapRoomID.Contains(WallIndex))
					{
						TempMappedRoom = BoundaryWallIndexMapRoomID[WallIndex];
					}

					EachJson->SetIntegerField("roomId", TempMappedRoom);
					TempJsonArr.Add(EachJson);
				}
			}
		}
		//////////第一类类型的墙体面归属信息塞进json//////////////////////
		if (FirstGroupWallIndexMapRoomID.Contains(WallIndex))
		{
			UVaRestJsonObject* EachJson = NewObject<UVaRestJsonObject>();
			TArray<int> TempFaceIDArray;
			TempFaceIDArray.Add(5);
			TempFaceIDArray.Add(0);
			TempFaceIDArray.Add(3);
			TempFaceIDArray.Add(6);

			int TempMappedRoom = 0;
			TempMappedRoom = FirstGroupWallIndexMapRoomID[WallIndex];
			EachJson->SetIntegerArrayField("index", TempFaceIDArray);
			EachJson->SetIntegerField("roomId", TempMappedRoom);
			TempJsonArr.Add(EachJson);
		}
		//////////第二类类型的墙体面归属信息塞进json/////////////////////
		if (SecondGroupWallIndexMapRoomID.Contains(WallIndex))
		{
			UVaRestJsonObject* EachJson = NewObject<UVaRestJsonObject>();
			TArray<int> TempFaceIDArray;
			TempFaceIDArray.Add(2);
			TempFaceIDArray.Add(1);
			TempFaceIDArray.Add(4);
			TempFaceIDArray.Add(7);
			int TempMappedRoom = 0;
			TempMappedRoom = SecondGroupWallIndexMapRoomID[WallIndex];
			EachJson->SetIntegerArrayField("index", TempFaceIDArray);
			EachJson->SetIntegerField("roomId", TempMappedRoom);
			TempJsonArr.Add(EachJson);
		}

		UVaRestJsonObject* EachJsonInfo = NewObject<UVaRestJsonObject>();
		if (TempJsonArr.Num() > 0)
		{
			EachJsonInfo->SetObjectArrayField("faceRelation", TempJsonArr);
		}

		if (IndexMapWalls.Contains(WallIndex))
		{
			TArray<UVaRestJsonObject*> NewWallPs;
			TArray<FVector> WallPs = IndexMapWalls[WallIndex];
			for (int _CurWallP = 0; _CurWallP < WallPs.Num(); ++_CurWallP)
			{
				UVaRestJsonObject* TempWallXYZ = NewObject<UVaRestJsonObject>();
				TempWallXYZ->SetNumberField("x", WallPs[_CurWallP].X);
				TempWallXYZ->SetNumberField("y", WallPs[_CurWallP].Y);
				TempWallXYZ->SetNumberField("z", WallPs[_CurWallP].Z);
				NewWallPs.Add(TempWallXYZ);
			}
			EachJsonInfo->SetObjectArrayField("wallPoints", NewWallPs);
		}
		WallRelationJson.Add(EachJsonInfo);
	}


	UVaRestJsonObject* RelationJson = NewObject<UVaRestJsonObject>();
	RelationJson->SetObjectArrayField("wallRelation", WallRelationJson);
	OutPanoramaJson->MergeJsonObject(RelationJson, true);
	return true;
}



bool  UWriteMeshObj_FunctionLibrary::CreateAdvancedPanoramaOfDNA(UObject* WorldContextObject, UVaRestJsonObject* InJson, UVaRestJsonObject* &OutPanoramaJson)
{
	if (InJson == nullptr)
	{
		return false;
	}

	TArray<FRoomGroup> RoomGroups;
	bool IsSeperated = SeperateRoomsIntoGroups(WorldContextObject, InJson, RoomGroups);
	if (!IsSeperated)
	{
		return false;
	}
	int MainIndex = 0;
	int MaxGroupNum = 0;
	for (int _CurIndex = 0; _CurIndex < RoomGroups.Num(); ++_CurIndex)
	{
		TArray<int> RoomIDArr = RoomGroups[_CurIndex].RoomIDs;
		if (RoomIDArr.Num() > MaxGroupNum)
		{
			MaxGroupNum = RoomIDArr.Num();
			MainIndex = _CurIndex;
		}
	}
	TArray<int> MainRoomIDs;
	MainRoomIDs = RoomGroups[MainIndex].RoomIDs;


	if (!OutPanoramaJson)
		OutPanoramaJson = UVaRestJsonObject::ConstructJsonObject(WorldContextObject);

	int SolutionID = 0;
	SolutionID = InJson->GetNumberField("solutionId");
	OutPanoramaJson->SetNumberField("solutionId", SolutionID);

	FString SolutionName = InJson->GetStringField("solutionName");
	OutPanoramaJson->SetStringField("name", SolutionName);

	int UserId = InJson->GetNumberField("userId");
	OutPanoramaJson->SetNumberField("userId", UserId);

	TArray<UVaRestJsonObject*> RoomJsonObj = InJson->GetObjectArrayField("roomList");
	TArray<UVaRestJsonObject*> NewRoomJsonObj;
	TArray<int> AreaIndexsToRemove;
	TMap<int, TArray<FVector2D>> AreaMapPsToRemove;
	TArray<int> AllRoomIDs;
	TMap<int, TArray<FVector2D>> RoomIDMapRegions;
	TMap<int, FString> RoomIDMapName;
	TMap<int, FString> RoomIDMapUseageName;
	TMap<int, int> RoomIDMapUsageID;

	for (int RoomIndex = 0; RoomIndex < RoomJsonObj.Num(); RoomIndex++)
	{
		TArray<UVaRestJsonObject*> EachRoomRegion = RoomJsonObj[RoomIndex]->GetObjectArrayField("areas");

		int RoomId = RoomJsonObj[RoomIndex]->GetIntegerField("roomId");

		FString RoomName = RoomJsonObj[RoomIndex]->GetStringField("roomName");
		if (!MainRoomIDs.Contains(RoomId))
		{
			TArray<FVector2D> TempAreaToRemove;
			for (int NumIndex = 0; NumIndex < EachRoomRegion.Num(); NumIndex++)
			{
				float TempX = EachRoomRegion[NumIndex]->GetNumberField("x");
				float TempY = EachRoomRegion[NumIndex]->GetNumberField("y");
				TempAreaToRemove.AddUnique(FVector2D(TempX, TempY));
			}
			AreaIndexsToRemove.AddUnique(RoomIndex);
			AreaMapPsToRemove.Add(RoomIndex, TempAreaToRemove);
		}
		else
		{
			UVaRestJsonObject* NewRoomJson = NewObject<UVaRestJsonObject>();
			TArray<UVaRestJsonObject*> NewEachRoomRegion;

			AllRoomIDs.Add(RoomId);
			TArray<FVector2D> TempRegionPs;
			for (int NumIndex = 0; NumIndex < EachRoomRegion.Num(); NumIndex++)
			{
				UVaRestJsonObject* TempXY = NewObject<UVaRestJsonObject>();
				float TempX = EachRoomRegion[NumIndex]->GetNumberField("x");
				float TempY = EachRoomRegion[NumIndex]->GetNumberField("y");
				TempRegionPs.AddUnique(FVector2D(TempX, TempY));
				TempXY->SetNumberField("x", TempX);
				TempXY->SetNumberField("y", TempY);
				NewEachRoomRegion.Add(TempXY);
			}

			NewRoomJson->SetObjectArrayField("areas", NewEachRoomRegion);
			FString RoomName = RoomJsonObj[RoomIndex]->GetStringField("roomName");

			NewRoomJson->SetStringField("roomName", RoomName);

			RoomIDMapRegions.Add(RoomId, TempRegionPs);
			RoomIDMapName.Add(RoomId, RoomName);

			NewRoomJson->SetIntegerField("roomId", RoomId);
			FString RoomUsageName = RoomJsonObj[RoomIndex]->GetStringField("roomUsageName");
			RoomIDMapUseageName.Add(RoomId, RoomUsageName);

			NewRoomJson->SetStringField("roomUsageName", RoomUsageName);
			int RoomUsageId = RoomJsonObj[RoomIndex]->GetNumberField("usageId");
			RoomIDMapUsageID.Add(RoomId, RoomUsageId);
			NewRoomJson->SetNumberField("usageId", RoomUsageId);
			NewRoomJsonObj.Add(NewRoomJson);
		}
	}

	TArray<UVaRestJsonObject*> WallJsonObj = InJson->GetObjectArrayField("walls");


	//////////Filter WallPS2D/////////////////////
	TArray<int> UpdatedWalls, ToBeRemovedWallIndexs;

	TArray<Polygon_2> AreaPolygon2Ds;
	for (int RoomIndex = 0; RoomIndex < RoomJsonObj.Num(); ++RoomIndex)
	{
		if (AreaIndexsToRemove.Contains(RoomIndex))
		{
			Polygon_2 TempPolygon;
			for (int I = 0; I < AreaMapPsToRemove[RoomIndex].Num(); ++I)
			{
				TempPolygon.push_back(Point_2(AreaMapPsToRemove[RoomIndex][I].X, AreaMapPsToRemove[RoomIndex][I].Y));
			}
			if (TempPolygon.area() < 0)
			{
				TempPolygon.reverse_orientation();
			}
			AreaPolygon2Ds.Add(TempPolygon);
		}
	}


	for (int WallIndex = 0; WallIndex < WallJsonObj.Num(); WallIndex++)
	{
		TArray<UVaRestJsonObject*> WallPs = WallJsonObj[WallIndex]->GetObjectArrayField("wallPoints");
		TArray<FVector2D> StoredWallPs2D;
		for (int NumIndex = 0; NumIndex < WallPs.Num(); NumIndex++)
		{
			UVaRestJsonObject* TempWallXYZ = NewObject<UVaRestJsonObject>();
			float TempX = WallPs[NumIndex]->GetNumberField("x");
			float TempY = WallPs[NumIndex]->GetNumberField("y");
			StoredWallPs2D.Add(FVector2D(TempX, TempY));
		}

		float Dis1 = FVector2D::Distance(StoredWallPs2D[0], StoredWallPs2D[1]);
		float Dis2 = FVector2D::Distance(StoredWallPs2D[1], StoredWallPs2D[2]);
		FVector2D SegStart, SegEnd, SegMiddle;
		if (Dis1 < Dis2)
		{
			SegStart = StoredWallPs2D[1];
			SegEnd = StoredWallPs2D[2];
		}
		else
		{
			SegStart = StoredWallPs2D[0];
			SegEnd = StoredWallPs2D[1];
		}
		SegMiddle = 0.5*(SegStart + SegEnd);
		FVector2D Dir1 = SegStart - SegMiddle;
		Dir1.Normalize();
		FVector2D DirVertical = Dir1.GetRotated(90);
		FVector2D Extend1 = SegMiddle + DirVertical * 40;
		FVector2D Extend2 = SegMiddle - DirVertical * 40;
		bool PointInRegion = false;
		for (int J = 0; J < AreaPolygon2Ds.Num(); J++)
		{
			if (AreaPolygon2Ds[J].has_on_bounded_side(Point_2(Extend1.X, Extend1.Y)))
			{
				PointInRegion = true;
				ToBeRemovedWallIndexs.AddUnique(WallIndex);
				break;
			}
			if (AreaPolygon2Ds[J].has_on_bounded_side(Point_2(Extend2.X, Extend2.Y)))
			{
				PointInRegion = true;
				ToBeRemovedWallIndexs.AddUnique(WallIndex);
				break;
			}
			if (!PointInRegion)
			{
				UpdatedWalls.AddUnique(WallIndex);
			}
		}
	}
	////////////////////////////////////////////////////////////////////////////////////////
	TArray<UVaRestJsonObject*> NewWallJsonObj;
	TMap<int, FVector2D> IndexMapWallCenter;
	TMap<int, TArray<FVector2D>> IndexMapWalls2D;
	TMap<int, TArray<FVector>> IndexMapWalls;
	for (int WallIndex = 0; WallIndex < WallJsonObj.Num(); WallIndex++)
	{
		UVaRestJsonObject* NewWallJson = NewObject<UVaRestJsonObject>();
		if (!ToBeRemovedWallIndexs.Contains(WallIndex))
		{
			TArray<UVaRestJsonObject*> WallPs = WallJsonObj[WallIndex]->GetObjectArrayField("wallPoints");
			TArray<UVaRestJsonObject*> NewWallPs;
			float TempCenterX = 0.0, TempCenterY = 0.0;
			TArray<FVector2D> TempWallPs2D;
			TArray<FVector> TempWall;
			for (int NumIndex = 0; NumIndex < WallPs.Num(); NumIndex++)
			{
				UVaRestJsonObject* TempWallXYZ = NewObject<UVaRestJsonObject>();
				float TempX = WallPs[NumIndex]->GetNumberField("x");
				float TempY = WallPs[NumIndex]->GetNumberField("y");
				float TempZ = WallPs[NumIndex]->GetNumberField("z");
				TempWallXYZ->SetNumberField("x", TempX);
				TempWallXYZ->SetNumberField("y", TempY);
				TempWallXYZ->SetNumberField("z", TempZ);
				NewWallPs.Add(TempWallXYZ);
				TempCenterX = TempCenterX + TempX;
				TempCenterY = TempCenterY + TempY;
				TempWallPs2D.Add(FVector2D(TempX, TempY));
				TempWall.Add(FVector(TempX, TempY, TempZ));
			}
			TempCenterX = TempCenterX / WallPs.Num();
			TempCenterY = TempCenterY / WallPs.Num();
			FVector2D TempWallCenter(TempCenterX, TempCenterY);
			IndexMapWallCenter.Add(WallIndex, TempWallCenter);
			IndexMapWalls2D.Add(WallIndex, TempWallPs2D);
			IndexMapWalls.Add(WallIndex, TempWall);
			NewWallJson->SetObjectArrayField("wallPoints", NewWallPs);
			NewWallJsonObj.Add(NewWallJson);
		}
	}
	//////////////////////////////////////////////////////////////////////////////////////////
	UVaRestJsonObject* ObjData = NewObject<UVaRestJsonObject>();
	ObjData->SetObjectArrayField("roomList", NewRoomJsonObj);
	ObjData->SetObjectArrayField("walls", NewWallJsonObj);
	OutPanoramaJson->SetObjectField("objData", ObjData);

	UVaRestJsonObject	*LocationJson = UVaRestJsonObject::ConstructJsonObject(WorldContextObject);
	TArray<FVector2D> RegionCenters;
	int NumOfTotalPickPs = 0;
	bool  IsSuccess = CreateDNALocationJsonWithCenters(WorldContextObject, InJson, AreaIndexsToRemove, LocationJson, RegionCenters, NumOfTotalPickPs);
	if (!IsSuccess)
	{
		return false;
	}
	OutPanoramaJson->MergeJsonObject(LocationJson, true);
	///////////////Match RoomID with RegionCenters
	if (AllRoomIDs.Num() != RegionCenters.Num())
	{
		return false;
	}
	TMap<int, FVector2D> RoomIDMapRegionCenters;
	for (int I = 0; I < AllRoomIDs.Num(); ++I)
	{
		RoomIDMapRegionCenters.Add(AllRoomIDs[I], RegionCenters[I]);
	}
	///////获取全景图观察点
	//////////预处理客餐厅数据////////////////////////////
	TArray<FVector2D> LivingRoomPs, DiningRoomPs, KitchenRoomPs;
	int LivingRoomID = 0, DiningRoomID = 0, KitchenRoomID = 0;
	bool IsLivingRoom = false;
	bool IsDiningRoom = false;
	bool IsKitchenRoom = false;
	for (int I = 0; I < AllRoomIDs.Num(); ++I)
	{
		int TempRoomId = AllRoomIDs[I];
		FString TempRoomName = RoomIDMapName[TempRoomId];
		if ((TempRoomName == TEXT("客厅")) && (!IsLivingRoom))
		{
			LivingRoomPs = RoomIDMapRegions[TempRoomId];
			LivingRoomID = TempRoomId;
			IsLivingRoom = true;
		}
		else if ((TempRoomName == TEXT("餐厅")) && (!IsDiningRoom))
		{
			DiningRoomPs = RoomIDMapRegions[TempRoomId];
			DiningRoomID = TempRoomId;
			IsDiningRoom = true;
		}
		else if ((TempRoomName == TEXT("厨房")) && (!IsKitchenRoom))
		{
			KitchenRoomID = TempRoomId;
			KitchenRoomPs = RoomIDMapRegions[TempRoomId];
			IsKitchenRoom = true;
		}
	}
	bool IFInterSect = false;
	bool HasCommonPoints = false;
	if ((LivingRoomPs.Num() != 0) && (DiningRoomPs.Num() != 0))
	{
		IFInterSect = FPolygonAlg::JudgePolygonInterSect(LivingRoomPs, DiningRoomPs);
		HasCommonPoints = FPolygonAlg::JudgeHasClosePoint(LivingRoomPs, DiningRoomPs);
	}
	//////////////预处理第三厅以及第四厅数据///////////////////////////
	TArray<FVector2D> ThirdDinging, FourthDining;
	int ThirdDingingRoomID = 0, FourthDiningRoomID = 0;
	bool IsThirdDining = false;
	bool IsFourthDining = false;
	for (int I = 0; I < AllRoomIDs.Num(); ++I)
	{
		int TempRoomId = AllRoomIDs[I];
		FString TempRoomName = RoomIDMapName[TempRoomId];
		if (((TempRoomName == TEXT("客厅")) || (TempRoomName == TEXT("起居室"))) && (TempRoomId != LivingRoomID) && (!IsThirdDining))
		{
			ThirdDinging = RoomIDMapRegions[TempRoomId];
			ThirdDingingRoomID = TempRoomId;
			IsThirdDining = true;
		}
		else if ((TempRoomName == TEXT("餐厅")) && (TempRoomId != DiningRoomID) && (!IsFourthDining))
		{
			FourthDining = RoomIDMapRegions[TempRoomId];
			FourthDiningRoomID = TempRoomId;
			IsFourthDining = true;
		}
	}
	bool IFInterSectOfThirdAndFourth = false;
	bool HasCommonPointsOfThirdAndFourth = false;
	if ((ThirdDinging.Num() != 0) && (FourthDining.Num() != 0))
	{
		IFInterSectOfThirdAndFourth = FPolygonAlg::JudgePolygonInterSect(ThirdDinging, FourthDining);
		HasCommonPointsOfThirdAndFourth = FPolygonAlg::JudgeHasClosePoint(ThirdDinging, FourthDining);
	}
	/////////////预处理厨房数据,判断厨房是否是开放式厨房//////////////////
	bool IsOpenKitchen1 = false;
	bool IsOpenKitchen2 = false;

	for (int Index = 0; Index < AllRoomIDs.Num(); ++Index)
	{
		if (AllRoomIDs[Index] != KitchenRoomID)
		{
			TArray<FVector2D> TempRoomPs;
			TempRoomPs = RoomIDMapRegions[AllRoomIDs[Index]];
			IsOpenKitchen1 = FPolygonAlg::JudgePolygonInterSect(KitchenRoomPs, TempRoomPs);
			if (IsOpenKitchen1)
			{
				break;
			}
			TArray<FVector2D> UpdateKitchenRoomPs, UpdateTempRoomPs, TempInterSectPs, TempCombinedPolygon;
			IsOpenKitchen2 = FPolygonAlg::CalculateTwoPolygonInterSect(KitchenRoomPs, TempRoomPs, UpdateKitchenRoomPs, UpdateTempRoomPs, TempInterSectPs, TempCombinedPolygon);
			if (IsOpenKitchen2)
			{
				break;
			}
		}
	}
	TMap<int, FVector2D> PanoramaWatchPoints;
	TMap<int, FVector2D> RoomIDMapWatchDirections;
	TMap<int, TArray<FVector>> RoomIDMapHoleData;
	TArray<int> SpecialRoomIDs;
	for (int RoomIndex = 0; RoomIndex < AllRoomIDs.Num(); RoomIndex++)
	{
		int TempRoomId = AllRoomIDs[RoomIndex];
		FString TempRoomName = RoomIDMapName[TempRoomId];
		TArray<FVector2D> TempRegionPs;
		TempRegionPs = RoomIDMapRegions[TempRoomId];
		if ((TempRoomName == TEXT("主卧")) || (TempRoomName == TEXT("次卧")) || (TempRoomName == TEXT("儿童房")) || (TempRoomName == TEXT("老人房"))
			|| (TempRoomName == TEXT("榻榻米房")) || (TempRoomName == TEXT("客人房")) || (TempRoomName == TEXT("书房")) || (TempRoomName == TEXT("健身房"))
			|| (TempRoomName == TEXT("多功能房")))
		{
			TArray<FVector2D> UpdateRegionPs;
			FPolygonAlg::MergeCollinearPoints(TempRegionPs, UpdateRegionPs);
			TArray<AFurnitureModelActor*> ModelsOfRoom;
			FindModelsOfRoom(WorldContextObject, UpdateRegionPs, ModelsOfRoom);
			AFurnitureModelActor* FindFur = nullptr;
			bool FindModel = false;
			bool IsSame = false;
			for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
			{
				AFurnitureModelActor* TempFur = ModelsOfRoom[_CurM];
				int TempID = 0;
				TempFur->GetModelCategory(TempID);
				if ((TempID == 5009) || (TempID == 5010))
				{
					FindFur = TempFur;
					FindModel = true;
					break;
				}
			}
			if (FindModel)
			{
				FBox TempBox = FindFur->GetComponentsBoundingBox(true);
				FVector FMin = TempBox.Min;
				FVector FMax = TempBox.Max;
				FVector2D P1(FMin.X, FMin.Y);
				FVector2D P2(FMax.X, FMin.Y);
				FVector2D P3(FMax.X, FMax.Y);
				FVector2D P4(FMin.X, FMax.Y);
				FVector2D BoxCenter = 0.25*(P1 + P2 + P3 + P4);
				float Dis1 = FVector2D::Distance(P1, P2);
				float Dis2 = FVector2D::Distance(P2, P3);
				FVector2D TempWatchP;
				FVector2D TempDir;
				const float ExtendL = 20;
				if (Dis1 > Dis2)
				{
					FVector2D TempPointVec = P2 - P1;
					TempPointVec = TempPointVec.GetSafeNormal();
					FVector2D TryP1 = BoxCenter + TempPointVec * (0.5*Dis1 + ExtendL);
					FVector2D TryP2 = BoxCenter - TempPointVec * (0.5*Dis1 + ExtendL);
					bool JudgeTryP1 = FPolygonAlg::JudgePointOnOrInPolygon(UpdateRegionPs, TryP1);
					bool JudgeTryP2 = FPolygonAlg::JudgePointOnOrInPolygon(UpdateRegionPs, TryP2);
					if (JudgeTryP1&&JudgeTryP2)
					{
						//IsSame = true;
						TempPointVec = P3 - P2;
						TempPointVec = TempPointVec.GetSafeNormal();
						TryP1 = BoxCenter + TempPointVec * (0.5*Dis2 + ExtendL);
						TryP2 = BoxCenter - TempPointVec * (0.5*Dis2 + ExtendL);
						JudgeTryP1 = FPolygonAlg::JudgePointOnOrInPolygon(UpdateRegionPs, TryP1);
						JudgeTryP2 = FPolygonAlg::JudgePointOnOrInPolygon(UpdateRegionPs, TryP2);
						if (JudgeTryP1&&JudgeTryP2)
						{
							IsSame = true;
						}
						else
						{
							FVector2D TempInterSectP1, TempInterSectP2;
							FPolygonAlg::CalculateRayToInterSectP(UpdateRegionPs, BoxCenter, TempPointVec, TempInterSectP1);
							FPolygonAlg::CalculateRayToInterSectP(UpdateRegionPs, BoxCenter, -TempPointVec, TempInterSectP2);
							float DisToInterSectP1 = FVector2D::Distance(BoxCenter, TempInterSectP1);
							float DisToInterSectP2 = FVector2D::Distance(BoxCenter, TempInterSectP2);
							if ((DisToInterSectP1 >= 20) || (DisToInterSectP2 >= 20))
							{
								if (DisToInterSectP1 > DisToInterSectP2)
								{
									TempWatchP = 0.5*(0.5*(P3 + P4) + TempInterSectP1);
									TempDir = -TempPointVec;
								}
								else
								{
									TempWatchP = 0.5*(0.5*(P1 + P2) + TempInterSectP2);
									TempDir = TempPointVec;
								}
							}
						}
					}
					else
					{
						FVector2D TempInterSectP1, TempInterSectP2;
						FPolygonAlg::CalculateRayToInterSectP(UpdateRegionPs, BoxCenter, TempPointVec, TempInterSectP1);
						FPolygonAlg::CalculateRayToInterSectP(UpdateRegionPs, BoxCenter, -TempPointVec, TempInterSectP2);
						float DisToInterSectP1 = FVector2D::Distance(BoxCenter, TempInterSectP1);
						float DisToInterSectP2 = FVector2D::Distance(BoxCenter, TempInterSectP2);
						if ((DisToInterSectP1 >= 20) || (DisToInterSectP2 >= 20))
						{
							if (DisToInterSectP1 > DisToInterSectP2)
							{
								TempWatchP = 0.5*(0.5*(P2 + P3) + TempInterSectP1);
								TempDir = -TempPointVec;
							}
							else
							{
								TempWatchP = 0.5*(0.5*(P4 + P1) + TempInterSectP2);
								TempDir = TempPointVec;
							}
						}
					}
				}
				else
				{
					FVector2D TempPointVec = P3 - P2;
					TempPointVec = TempPointVec.GetSafeNormal();
					FVector2D TryP1 = BoxCenter + TempPointVec * (0.5*Dis2 + ExtendL);
					FVector2D TryP2 = BoxCenter - TempPointVec * (0.5*Dis2 + ExtendL);
					bool JudgeTryP1 = FPolygonAlg::JudgePointOnOrInPolygon(UpdateRegionPs, TryP1);
					bool JudgeTryP2 = FPolygonAlg::JudgePointOnOrInPolygon(UpdateRegionPs, TryP2);
					if (JudgeTryP1 && JudgeTryP2)
					{
						//IsSame = true;
						TempPointVec = P2 - P1;
						TempPointVec = TempPointVec.GetSafeNormal();
						TryP1 = BoxCenter + TempPointVec * (0.5*Dis1 + ExtendL);
						TryP2 = BoxCenter - TempPointVec * (0.5*Dis1 + ExtendL);
						JudgeTryP1 = FPolygonAlg::JudgePointOnOrInPolygon(UpdateRegionPs, TryP1);
						JudgeTryP2 = FPolygonAlg::JudgePointOnOrInPolygon(UpdateRegionPs, TryP2);
						if (JudgeTryP1&&JudgeTryP2)
						{
							IsSame = true;
						}
						else
						{
							FVector2D TempInterSectP1, TempInterSectP2;
							FPolygonAlg::CalculateRayToInterSectP(UpdateRegionPs, BoxCenter, TempPointVec, TempInterSectP1);
							FPolygonAlg::CalculateRayToInterSectP(UpdateRegionPs, BoxCenter, -TempPointVec, TempInterSectP2);
							float DisToInterSectP1 = FVector2D::Distance(BoxCenter, TempInterSectP1);
							float DisToInterSectP2 = FVector2D::Distance(BoxCenter, TempInterSectP2);
							if ((DisToInterSectP1 >= 20) || (DisToInterSectP2 >= 20))
							{
								if (DisToInterSectP1 > DisToInterSectP2)
								{
									TempWatchP = 0.5*(0.5*(P3 + P4) + TempInterSectP1);
									TempDir = -TempPointVec;
								}
								else
								{
									TempWatchP = 0.5*(0.5*(P1 + P2) + TempInterSectP2);
									TempDir = TempPointVec;
								}
							}
						}
					}
					else
					{
						FVector2D TempInterSectP1, TempInterSectP2;
						FPolygonAlg::CalculateRayToInterSectP(UpdateRegionPs, BoxCenter, TempPointVec, TempInterSectP1);
						FPolygonAlg::CalculateRayToInterSectP(UpdateRegionPs, BoxCenter, -TempPointVec, TempInterSectP2);
						float DisToInterSectP1 = FVector2D::Distance(BoxCenter, TempInterSectP1);
						float DisToInterSectP2 = FVector2D::Distance(BoxCenter, TempInterSectP2);
						if ((DisToInterSectP1 >= 20) || (DisToInterSectP2 >= 20))
						{
							if (DisToInterSectP1 > DisToInterSectP2)
							{
								TempWatchP = 0.5*(0.5*(P3 + P4) + TempInterSectP1);
								TempDir = -TempPointVec;
							}
							else
							{
								TempWatchP = 0.5*(0.5*(P1 + P2) + TempInterSectP2);
								TempDir = TempPointVec;
							}
						}
					}
				}

				if (!IsSame)
				{
					bool FindPointInModel = false;
					for (auto TempModelInRoom : ModelsOfRoom)
					{
						FBox TempBox = TempModelInRoom->GetComponentsBoundingBox(true);
						FString ModelName = TempModelInRoom->GetName();
						if (!ModelName.Contains(TEXT("Light")))
						{
							bool IfInModel = TempBox.IsInsideOrOn(FVector(TempWatchP, 130));
							if (IfInModel)
							{
								FVector FMin = TempBox.Min;
								FVector FMax = TempBox.Max;
								bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, UpdateRegionPs);
								if (ModelBoxIsUseful)
								{
									FindPointInModel = true;
									break;
								}
							}
						}
					}
					bool IsInSide = false;
					IsInSide = FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, TempWatchP);

					if ((!FindPointInModel) && (IsInSide))
					{
						PanoramaWatchPoints.Add(TempRoomId, TempWatchP);
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						SpecialRoomIDs.AddUnique(TempRoomId);
						TArray<FVector>DoorPoints;
						bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
						if (GetDoorSuccess)
						{
							int TempNumOfDoors = DoorPoints.Num() / 8;
							if (TempNumOfDoors > 0)
							{
								RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
							}
						}
					}
					else
					{
						IsSame = true;
					}
				}
			}
			else
			{
				IsSame = true;
			}
			if (IsSame)
			{
				TArray<FVector>DoorPoints;
				if (UpdateRegionPs.Num() <= 5)
				{
					bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
					if (!GetDoorSuccess)
					{
						PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
						FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}
					else
					{

						int NumOfDoors = DoorPoints.Num() / 8;
						RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
						FVector2D SuitPoint;
						TArray<FVector2D> RoomWallPs;
						bool GetWallSuccess = GetWallPointsOfRoom(WorldContextObject, TempRoomId, RoomWallPs);
						if (GetWallSuccess)
						{
							bool GetSpecialSuccess = FPolygonAlg::GetRegionOfFourCornerSpecialRoom(UpdateRegionPs, SuitPoint, RoomWallPs, DoorPoints, 0.01);
							if (GetSpecialSuccess)
							{
								if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, SuitPoint))
								{
									PanoramaWatchPoints.Add(TempRoomId, SuitPoint);
									FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - SuitPoint;
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
								else
								{
									PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
									FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}

							}
							else
							{
								if (NumOfDoors == 1)
								{
									FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
									FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
									DirVec = DirVec.GetSafeNormal();
									DirVec = DirVec.GetRotated(90);
									FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
									FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
									FVector2D TempVec1 = DoorCenter2D + 100 * DirVec;
									if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, TempVec1))
									{
										PanoramaWatchPoints.Add(TempRoomId, TempVec1);
										FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
									}
									else
									{
										if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, DoorCenter2D - 100 * DirVec))
										{
											PanoramaWatchPoints.Add(TempRoomId, DoorCenter2D - 100 * DirVec);
											FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - (DoorCenter2D - 100 * DirVec);
											TempDir = TempDir.GetSafeNormal();
											RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
										}
										else
										{
											PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
											FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
											TempDir = TempDir.GetSafeNormal();
											RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
										}

									}
								}
								else if (NumOfDoors >= 2)
								{
									FVector2D TempCenter = RegionCenters[RoomIndex];
									float MaxDis = 0.0;
									int TargetDoorIndex = 0;
									for (int J = 0; J < NumOfDoors; ++J)
									{
										FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
										FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
										float TempDis = FVector2D::Distance(TempCenter, TempDoorCenter2D);
										if ((MaxDis == 0.0) || (TempDis > MaxDis))
										{
											MaxDis = TempDis;
											TargetDoorIndex = J;
										}
									}
									FVector2D PStart = FVector2D(DoorPoints[0 + 8 * TargetDoorIndex].X, DoorPoints[1 + 8 * TargetDoorIndex].Y);
									FVector2D PEnd = FVector2D(DoorPoints[2 + 8 * TargetDoorIndex].X, DoorPoints[3 + 8 * TargetDoorIndex].Y);
									FVector2D ParallelPStart, ParallelPEnd;
									const float DisValue = 30;
									int ParallelEdgeIndex = 0;
									bool FindSuccess = FPolygonAlg::FindParallelEdge(UpdateRegionPs, PStart, PEnd, ParallelPStart, ParallelPEnd, ParallelEdgeIndex, DisValue);
									if (!FindSuccess)
									{
										FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
										FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
										DirVec = DirVec.GetSafeNormal();
										DirVec = DirVec.GetRotated(90);
										FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
										FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
										FVector2D TempVec1 = DoorCenter2D + 100 * DirVec;
										if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, TempVec1))
										{
											PanoramaWatchPoints.Add(TempRoomId, TempVec1);
											FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
											TempDir = TempDir.GetSafeNormal();
											RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
										}
										else
										{
											if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, DoorCenter2D - 100 * DirVec))
											{
												PanoramaWatchPoints.Add(TempRoomId, DoorCenter2D - 100 * DirVec);
												FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - (DoorCenter2D - 100 * DirVec);
												TempDir = TempDir.GetSafeNormal();
												RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
											}
											else
											{
												PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
												FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
												TempDir = TempDir.GetSafeNormal();
												RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
											}

										}
									}
									else
									{
										FVector TempDirVec = DoorPoints[1 + 8 * TargetDoorIndex] - DoorPoints[0 + 8 * TargetDoorIndex];
										FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
										DirVec = DirVec.GetSafeNormal();
										DirVec = DirVec.GetRotated(90);
										FVector DoorCenter3D = 0.25*(DoorPoints[0 + 8 * TargetDoorIndex] + DoorPoints[1 + 8 * TargetDoorIndex] + DoorPoints[2 + 8 * TargetDoorIndex]
											+ DoorPoints[3 + 8 * TargetDoorIndex]);
										FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
										FVector2D TempVec1 = DoorCenter2D + 100 * DirVec;
										if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, TempVec1))
										{
											PanoramaWatchPoints.Add(TempRoomId, TempVec1);
											FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
											TempDir = TempDir.GetSafeNormal();
											RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
										}
										else
										{
											if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, DoorCenter2D - 100 * DirVec))
											{
												PanoramaWatchPoints.Add(TempRoomId, DoorCenter2D - 100 * DirVec);
												FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - (DoorCenter2D - 100 * DirVec);
												TempDir = TempDir.GetSafeNormal();
												RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
											}
											else
											{
												PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
												FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
												TempDir = TempDir.GetSafeNormal();
												RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
											}

										}
									}
								}
							}
						}
						else
						{
							PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
							FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
					}
				}
				else if (UpdateRegionPs.Num() >= 6)
				{
					bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
					if (!GetDoorSuccess)
					{
						PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
						FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}
					else
					{
						int NumOfDoors = DoorPoints.Num() / 8;
						RoomIDMapHoleData.Add(TempRoomId, DoorPoints);

						TArray<FVector2D> MaxAreaRegion;
						FVector2D SuitPoint;

						bool GetSuccess = FPolygonAlg::GetMaxRegionOfSpecialRoom(UpdateRegionPs, MaxAreaRegion, SuitPoint, DoorPoints);
						if (GetSuccess)
						{
							if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, SuitPoint))
							{
								PanoramaWatchPoints.Add(TempRoomId, SuitPoint);
								FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - SuitPoint;
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
							}
							else
							{
								PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
								FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
							}

						}
						else
						{
							const float DisBound = 180;
							if (NumOfDoors == 1)
							{
								///////////////////////////////////////////////////计算从门中心出发射线与区域的交点/////////////////////////////////////////////////
								FVector2D TempDoorLoc = 0.25*FVector2D(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
								FVector2D TempDoorVec = FVector2D(DoorPoints[1] - DoorPoints[0]);
								TempDoorVec = TempDoorVec.GetSafeNormal();
								FVector2D TempRotateOfVec = TempDoorVec.GetRotated(90);
								FVector2D TempExtendP = TempDoorLoc + 40 * TempRotateOfVec;
								bool IfInArea = FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, TempExtendP);
								bool HasLocated = false;
								if (IfInArea)
								{
									FVector2D TempInterP;
									bool IsLocated = FPolygonAlg::CalculateRayInterSectPoly(UpdateRegionPs, TempDoorLoc, TempRotateOfVec, TempInterP, DisBound);
									if (IsLocated)
									{
										FVector2D SuitLoc = 0.5*(TempInterP + TempDoorLoc);
										PanoramaWatchPoints.Add(TempRoomId, SuitLoc);
										FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - SuitLoc;
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
										HasLocated = true;
									}
								}
								else
								{
									FVector2D TempInterP;
									bool IsLocated = FPolygonAlg::CalculateRayInterSectPoly(UpdateRegionPs, TempDoorLoc, -TempRotateOfVec, TempInterP, DisBound);
									if (IsLocated)
									{
										FVector2D SuitLoc = 0.5*(TempInterP + TempDoorLoc);
										PanoramaWatchPoints.Add(TempRoomId, SuitLoc);
										FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - SuitLoc;
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
										HasLocated = true;
									}
								}

								if (!HasLocated)
								{
									PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
									FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}

							}
							else if (NumOfDoors >= 2)
							{
								FVector2D TempCenter = RegionCenters[RoomIndex];
								float MaxDis = 0.0;
								int TargetDoorIndex = 0;
								for (int J = 0; J < NumOfDoors; ++J)
								{
									FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
									FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
									float TempDis = FVector2D::Distance(TempCenter, TempDoorCenter2D);
									if ((MaxDis == 0.0) || (TempDis > MaxDis))
									{
										MaxDis = TempDis;
										TargetDoorIndex = J;
									}
								}

								FVector2D TempDoorLoc = 0.25*FVector2D(DoorPoints[8 * TargetDoorIndex + 0] + DoorPoints[8 * TargetDoorIndex + 1] + DoorPoints[8 * TargetDoorIndex + 2] + DoorPoints[8 * TargetDoorIndex + 3]);
								FVector2D TempDoorVec = FVector2D(DoorPoints[8 * TargetDoorIndex + 1] - DoorPoints[8 * TargetDoorIndex + 0]);
								TempDoorVec = TempDoorVec.GetSafeNormal();
								FVector2D TempRotateOfVec = TempDoorVec.GetRotated(90);
								FVector2D TempExtendP = TempDoorLoc + 40 * TempRotateOfVec;
								bool IfInArea = FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, TempExtendP);
								bool HasLocated = false;
								if (IfInArea)
								{
									FVector2D TempInterP;
									bool IsLocated = FPolygonAlg::CalculateRayInterSectPoly(UpdateRegionPs, TempDoorLoc, TempRotateOfVec, TempInterP, DisBound);
									if (IsLocated)
									{
										FVector2D SuitLoc = 0.5*(TempInterP + TempDoorLoc);
										PanoramaWatchPoints.Add(TempRoomId, SuitLoc);
										FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - SuitLoc;
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
										HasLocated = true;
									}
								}
								else
								{
									FVector2D TempInterP;
									bool IsLocated = FPolygonAlg::CalculateRayInterSectPoly(UpdateRegionPs, TempDoorLoc, -TempRotateOfVec, TempInterP, DisBound);
									if (IsLocated)
									{
										FVector2D SuitLoc = 0.5*(TempInterP + TempDoorLoc);
										PanoramaWatchPoints.Add(TempRoomId, SuitLoc);
										FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - SuitLoc;
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
										HasLocated = true;
									}
								}

								if (!HasLocated)
								{
									PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
									FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
							}
						}
					}
				}
			}
		}
		else if ((TempRoomName == TEXT("客厅")) || (TempRoomName == TEXT("起居室")))
		{
			if (TempRoomId == LivingRoomID)
			{
				if ((LivingRoomPs.Num() != 0) && (DiningRoomPs.Num() != 0))
				{
					if ((IFInterSect) || (HasCommonPoints))
					{
						FVector2D TempCenter = 0.5*(RoomIDMapRegionCenters[LivingRoomID] + RoomIDMapRegionCenters[DiningRoomID]);
						if ((FPolygonAlg::JudgePointOnOrInPolygon(TempRegionPs, TempCenter)) || (FPolygonAlg::JudgePointOnOrInPolygon(DiningRoomPs, TempCenter)))
						{
							PanoramaWatchPoints.Add(TempRoomId, TempCenter);
							FVector2D TempDir = RoomIDMapRegionCenters[LivingRoomID] - TempCenter;
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						else
						{
							PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
							FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						TArray<FVector>DoorPoints;
						bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
						if (GetDoorSuccess)
						{
							RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
						}
					}
					else if ((!IFInterSect) && (!HasCommonPoints))
					{
						TArray<FVector>DoorPoints;
						bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
						if (!GetDoorSuccess)
						{
							PanoramaWatchPoints.Add(LivingRoomID, RoomIDMapRegionCenters[LivingRoomID]);
							FVector2D TempDir = -RoomIDMapRegionCenters[LivingRoomID];
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						else
						{
							int NumOfDoors = DoorPoints.Num() / 8;
							RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
							if (NumOfDoors == 1)
							{
								FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
								FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
								DirVec = DirVec.GetSafeNormal();
								DirVec = DirVec.GetRotated(90);
								FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
								FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
								FVector2D TempVec1 = DoorCenter2D + 80 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
								{
									PanoramaWatchPoints.Add(TempRoomId, TempVec1);
									FVector2D TempDir = RoomIDMapRegionCenters[LivingRoomID] - TempVec1;
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
								else
								{
									FVector2D TempWatchP = DoorCenter2D - 80 * DirVec;
									if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempWatchP))
									{
										PanoramaWatchPoints.Add(TempRoomId, TempWatchP);
										FVector2D TempDir = RoomIDMapRegionCenters[LivingRoomID] - TempWatchP;
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
									}
									else
									{
										PanoramaWatchPoints.Add(LivingRoomID, RoomIDMapRegionCenters[LivingRoomID]);
										FVector2D TempDir = -RoomIDMapRegionCenters[LivingRoomID];
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
									}

								}
							}
							else if (NumOfDoors >= 2)
							{
								FVector2D TempCenter = RegionCenters[RoomIndex];
								float MinDis = 0.0;
								int TargetDoorIndex = 0;
								for (int J = 0; J < NumOfDoors; ++J)
								{
									FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
									FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
									float TempDis = FVector2D::Distance(RoomIDMapRegionCenters[LivingRoomID], TempDoorCenter2D) +
										FVector2D::Distance(RoomIDMapRegionCenters[DiningRoomID], TempDoorCenter2D);
									if ((MinDis == 0.0) || (TempDis < MinDis))
									{
										MinDis = TempDis;
										TargetDoorIndex = J;
									}
								}

								FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
								FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
								DirVec = DirVec.GetSafeNormal();
								DirVec = DirVec.GetRotated(90);
								FVector DoorCenter3D = 0.25*(DoorPoints[0 + 8 * TargetDoorIndex] + DoorPoints[1 + 8 * TargetDoorIndex]
									+ DoorPoints[2 + 8 * TargetDoorIndex] + DoorPoints[3 + 8 * TargetDoorIndex]);
								FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
								FVector2D TempVec1 = DoorCenter2D + 80 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
								{
									PanoramaWatchPoints.Add(TempRoomId, TempVec1);
									FVector2D TempDir = RoomIDMapRegionCenters[LivingRoomID] - TempVec1;
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
								else
								{
									FVector2D TempWatchP = DoorCenter2D - 80 * DirVec;
									if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempWatchP))
									{
										PanoramaWatchPoints.Add(TempRoomId, TempWatchP);
										FVector2D TempDir = RoomIDMapRegionCenters[LivingRoomID] - (DoorCenter2D - 80 * DirVec);
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
									}
									else
									{
										PanoramaWatchPoints.Add(LivingRoomID, RoomIDMapRegionCenters[LivingRoomID]);
										FVector2D TempDir = -RoomIDMapRegionCenters[LivingRoomID];
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
									}

								}
							}
						}
					}
				}
				else if ((LivingRoomPs.Num() != 0) && (DiningRoomPs.Num() == 0))
				{
					TArray<FVector>DoorPoints;
					bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
					if (!GetDoorSuccess)
					{
						PanoramaWatchPoints.Add(LivingRoomID, RoomIDMapRegionCenters[LivingRoomID]);
						FVector2D TempDir = -RoomIDMapRegionCenters[LivingRoomID];
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}
					else
					{
						int NumOfDoors = DoorPoints.Num() / 8;
						RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
						if (NumOfDoors == 1)
						{
							FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
							FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
							DirVec = DirVec.GetSafeNormal();
							DirVec = DirVec.GetRotated(90);
							FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
							FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
							FVector2D TempVec1 = DoorCenter2D + 80 * DirVec;
							if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
							{
								PanoramaWatchPoints.Add(TempRoomId, TempVec1);
								FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
							}
							else
							{
								FVector2D TempP = DoorCenter2D - 80 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
								{
									PanoramaWatchPoints.Add(TempRoomId, TempP);
									FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - (DoorCenter2D - 80 * DirVec);
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
								else
								{
									PanoramaWatchPoints.Add(LivingRoomID, RoomIDMapRegionCenters[LivingRoomID]);
									FVector2D TempDir = -RoomIDMapRegionCenters[LivingRoomID];
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}

							}
						}
						else if (NumOfDoors >= 2)
						{
							FVector2D TempCenter = RegionCenters[RoomIndex];
							float MinDis = 0.0;
							int TargetDoorIndex = 0;
							for (int J = 0; J < NumOfDoors; ++J)
							{
								FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
								FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
								float TempDis = FVector2D::Distance(TempCenter, TempDoorCenter2D);
								if ((MinDis == 0.0) || (TempDis < MinDis))
								{
									MinDis = TempDis;
									TargetDoorIndex = J;
								}
							}

							FVector TempDirVec = DoorPoints[1 + 8 * TargetDoorIndex] - DoorPoints[0 + 8 * TargetDoorIndex];
							FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
							DirVec = DirVec.GetSafeNormal();
							DirVec = DirVec.GetRotated(90);
							FVector DoorCenter3D = 0.25*(DoorPoints[0 + 8 * TargetDoorIndex] + DoorPoints[1 + 8 * TargetDoorIndex]
								+ DoorPoints[2 + 8 * TargetDoorIndex] + DoorPoints[3 + 8 * TargetDoorIndex]);
							FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
							FVector2D TempVec1 = DoorCenter2D + 80 * DirVec;
							if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
							{
								PanoramaWatchPoints.Add(TempRoomId, TempVec1);
								FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);

							}
							else
							{
								FVector2D TempP = DoorCenter2D - 80 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
								{
									PanoramaWatchPoints.Add(TempRoomId, TempP);
									FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempP;
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
								else
								{
									PanoramaWatchPoints.Add(LivingRoomID, RoomIDMapRegionCenters[LivingRoomID]);
									FVector2D TempDir = -RoomIDMapRegionCenters[LivingRoomID];
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
							}
						}
					}
				}
			}
			else
			{
				PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
				FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
				TempDir = TempDir.GetSafeNormal();
				RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
			}
		}
		else if (TempRoomName == TEXT("餐厅"))
		{
			if (TempRoomId == DiningRoomID)
			{
				if ((LivingRoomPs.Num() != 0) && (DiningRoomPs.Num() != 0))
				{
					if ((IFInterSect) || (HasCommonPoints))
					{
						TArray<FVector>DoorPoints;
						FVector2D TempCenter = 0.5*(RoomIDMapRegionCenters[LivingRoomID] + RoomIDMapRegionCenters[DiningRoomID]);
						if ((FPolygonAlg::JudgePointOnOrInPolygon(TempRegionPs, TempCenter)) || (FPolygonAlg::JudgePointOnOrInPolygon(LivingRoomPs, TempCenter)))
						{
							PanoramaWatchPoints.Add(TempRoomId, TempCenter);
							FVector2D TempDir = RoomIDMapRegionCenters[DiningRoomID] - TempCenter;
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						else
						{
							PanoramaWatchPoints.Add(DiningRoomID, RoomIDMapRegionCenters[DiningRoomID]);
							FVector2D TempDir = -RoomIDMapRegionCenters[DiningRoomID];
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}

						bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
						if (GetDoorSuccess)
						{
							RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
						}
					}
					else if ((!IFInterSect) && (!HasCommonPoints))
					{
						TArray<FVector>DoorPoints;
						bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
						if (!GetDoorSuccess)
						{
							PanoramaWatchPoints.Add(DiningRoomID, RoomIDMapRegionCenters[DiningRoomID]);
							FVector2D TempDir = -RoomIDMapRegionCenters[DiningRoomID];
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						else
						{
							int NumOfDoors = DoorPoints.Num() / 8;
							RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
							if (NumOfDoors == 1)
							{
								FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
								FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
								DirVec = DirVec.GetSafeNormal();
								DirVec = DirVec.GetRotated(90);
								FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
								FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
								FVector2D TempVec1 = DoorCenter2D + 80 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
								{
									PanoramaWatchPoints.Add(TempRoomId, TempVec1);

									FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
								else
								{
									FVector2D TempP = DoorCenter2D - 80 * DirVec;
									if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
									{
										PanoramaWatchPoints.Add(TempRoomId, TempP);
										FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempP;
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
									}
									else
									{
										PanoramaWatchPoints.Add(DiningRoomID, RoomIDMapRegionCenters[DiningRoomID]);
										FVector2D TempDir = -RoomIDMapRegionCenters[DiningRoomID];
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
									}
								}
							}
							else if (NumOfDoors >= 2)
							{
								FVector2D TempCenter = RegionCenters[RoomIndex];
								float MinDis = 0.0;
								int TargetDoorIndex = 0;
								for (int J = 0; J < NumOfDoors; ++J)
								{
									FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
									FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
									float TempDis = FVector2D::Distance(RoomIDMapRegionCenters[LivingRoomID], TempDoorCenter2D) +
										FVector2D::Distance(RoomIDMapRegionCenters[DiningRoomID], TempDoorCenter2D);
									if ((MinDis == 0.0) || (TempDis < MinDis))
									{
										MinDis = TempDis;
										TargetDoorIndex = J;
									}
								}

								FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
								FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
								DirVec = DirVec.GetSafeNormal();
								DirVec = DirVec.GetRotated(90);
								FVector DoorCenter3D = 0.25*(DoorPoints[0 + 8 * TargetDoorIndex] + DoorPoints[1 + 8 * TargetDoorIndex]
									+ DoorPoints[2 + 8 * TargetDoorIndex] + DoorPoints[3 + 8 * TargetDoorIndex]);
								FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
								FVector2D TempVec1 = DoorCenter2D + 80 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
								{
									PanoramaWatchPoints.Add(TempRoomId, TempVec1);
									FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
								else
								{
									FVector2D TempP = DoorCenter2D - 80 * DirVec;
									if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
									{
										PanoramaWatchPoints.Add(TempRoomId, DoorCenter2D - 80 * DirVec);
										FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - (DoorCenter2D - 80 * DirVec);
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
									}
									else
									{
										PanoramaWatchPoints.Add(DiningRoomID, RoomIDMapRegionCenters[DiningRoomID]);
										FVector2D TempDir = -RoomIDMapRegionCenters[DiningRoomID];
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
									}

								}
							}
						}
					}
				}
				else if ((LivingRoomPs.Num() == 0) && (DiningRoomPs.Num() != 0))
				{
					TArray<FVector>DoorPoints;
					bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
					if (!GetDoorSuccess)
					{
						PanoramaWatchPoints.Add(DiningRoomID, RoomIDMapRegionCenters[DiningRoomID]);
						FVector2D TempDir = -RoomIDMapRegionCenters[DiningRoomID];
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}
					else
					{
						int NumOfDoors = DoorPoints.Num() / 8;
						RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
						if (NumOfDoors == 1)
						{
							FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
							FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
							DirVec = DirVec.GetSafeNormal();
							DirVec = DirVec.GetRotated(90);
							FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
							FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
							FVector2D TempVec1 = DoorCenter2D + 80 * DirVec;
							if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
							{
								PanoramaWatchPoints.Add(TempRoomId, TempVec1);
								FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);

							}
							else
							{
								FVector2D TempP = DoorCenter2D - 80 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
								{
									PanoramaWatchPoints.Add(TempRoomId, TempP);
									FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempP;
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
								else
								{
									PanoramaWatchPoints.Add(DiningRoomID, RoomIDMapRegionCenters[DiningRoomID]);
									FVector2D TempDir = -RoomIDMapRegionCenters[DiningRoomID];
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}

							}
						}
						else if (NumOfDoors >= 2)
						{
							FVector2D TempCenter = RegionCenters[RoomIndex];
							float MinDis = 0.0;
							int TargetDoorIndex = 0;
							for (int J = 0; J < NumOfDoors; ++J)
							{
								FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
								FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
								float TempDis = FVector2D::Distance(TempCenter, TempDoorCenter2D);
								if ((MinDis == 0.0) || (TempDis < MinDis))
								{
									MinDis = TempDis;
									TargetDoorIndex = J;
								}
							}

							FVector TempDirVec = DoorPoints[1 + 8 * TargetDoorIndex] - DoorPoints[0 + 8 * TargetDoorIndex];
							FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
							DirVec = DirVec.GetSafeNormal();
							DirVec = DirVec.GetRotated(90);
							FVector DoorCenter3D = 0.25*(DoorPoints[0 + 8 * TargetDoorIndex] + DoorPoints[1 + 8 * TargetDoorIndex]
								+ DoorPoints[2 + 8 * TargetDoorIndex] + DoorPoints[3 + 8 * TargetDoorIndex]);
							FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
							FVector2D TempVec1 = DoorCenter2D + 80 * DirVec;
							if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
							{
								PanoramaWatchPoints.Add(TempRoomId, TempVec1);
								FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
							}
							else
							{
								FVector2D TempP = DoorCenter2D - 80 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
								{
									PanoramaWatchPoints.Add(TempRoomId, TempP);
									FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempP;
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
								else
								{
									PanoramaWatchPoints.Add(DiningRoomID, RoomIDMapRegionCenters[DiningRoomID]);
									FVector2D TempDir = -RoomIDMapRegionCenters[DiningRoomID];
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
							}
						}
					}
				}
			}
			else
			{
				PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
				FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
				TempDir = TempDir.GetSafeNormal();
				RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
			}
		}
		else if ((TempRoomName == TEXT("生活阳台")) || (TempRoomName == TEXT("休闲阳台")) || (TempRoomName == TEXT("卧室阳台")))
		{
			TArray<FVector>DoorPoints;
			bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
			if (!GetDoorSuccess)
			{
				PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
				FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
				TempDir = TempDir.GetSafeNormal();
				RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
			}
			else
			{
				int NumOfDoors = DoorPoints.Num() / 8;
				RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
				if (NumOfDoors == 1)
				{
					FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
					FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
					DirVec = DirVec.GetSafeNormal();
					DirVec = DirVec.GetRotated(90);
					FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
					FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
					FVector2D PCenterToDoorCenter = RoomIDMapRegionCenters[TempRoomId] - DoorCenter2D;
					float TempDotValue = FVector2D::DotProduct(PCenterToDoorCenter, DirVec);
					FVector2D TempNode = DoorCenter2D + TempDotValue * DirVec;

					if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempNode))
					{
						PanoramaWatchPoints.Add(TempRoomId, TempNode);
						if (TempDotValue > 0)
						{
							RoomIDMapWatchDirections.Add(TempRoomId, -DirVec);
						}
						else
						{
							RoomIDMapWatchDirections.Add(TempRoomId, DirVec);
						}
					}
					else
					{
						PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
						FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}
				}
				else if (NumOfDoors >= 2)
				{
					FVector2D TempCenter = RegionCenters[RoomIndex];
					float MinDis = 0.0;
					int TargetDoorIndex = 0;
					for (int J = 0; J < NumOfDoors; ++J)
					{
						FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
						FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
						float TempDis = FVector2D::Distance(TempCenter, TempDoorCenter2D);
						if ((MinDis == 0.0) || (TempDis < MinDis))
						{
							MinDis = TempDis;
							TargetDoorIndex = J;
						}
					}

					FVector TempDirVec = DoorPoints[1 + 8 * TargetDoorIndex] - DoorPoints[0 + 8 * TargetDoorIndex];
					FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
					DirVec = DirVec.GetSafeNormal();
					DirVec = DirVec.GetRotated(90);
					FVector DoorCenter3D = 0.25*(DoorPoints[0 + 8 * TargetDoorIndex] + DoorPoints[1 + 8 * TargetDoorIndex]
						+ DoorPoints[2 + 8 * TargetDoorIndex] + DoorPoints[3 + 8 * TargetDoorIndex]);
					FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);

					FVector2D PCenterToDoorCenter = RoomIDMapRegionCenters[TempRoomId] - DoorCenter2D;
					float TempDotValue = FVector2D::DotProduct(PCenterToDoorCenter, DirVec);
					FVector2D TempNode = DoorCenter2D + TempDotValue * DirVec;

					if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempNode))
					{
						PanoramaWatchPoints.Add(TempRoomId, TempNode);
						if (TempDotValue > 0)
						{
							RoomIDMapWatchDirections.Add(TempRoomId, -DirVec);
						}
						else
						{
							RoomIDMapWatchDirections.Add(TempRoomId, DirVec);
						}
					}
					else
					{
						PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
						FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}

				}
			}
		}
		else if ((TempRoomName == TEXT("主卫")) || (TempRoomName == TEXT("客卫")) || (TempRoomName == TEXT("卫生间")))
		{
			TArray<FVector2D> UpdateRegionPs;
			FPolygonAlg::MergeCollinearPoints(TempRegionPs, UpdateRegionPs);

			bool FindWall = false;
			int TargetIndex = 0;

			for (int _CurIndex = 0; _CurIndex < WallJsonObj.Num(); ++_CurIndex)
			{
				if (IndexMapWallCenter.Contains(_CurIndex))
				{
					bool JudgeIfInRegion = FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, IndexMapWallCenter[_CurIndex]);
					if (JudgeIfInRegion)
					{
						FindWall = true;
						TargetIndex = _CurIndex;
						break;
					}
				}
			}
			if (FindWall)
			{
				TArray<FVector2D> ToiletWatchPoints;
				bool LocateSecondToiletSuccess = FPolygonAlg::LocateCentersOfSecondToilet(UpdateRegionPs, IndexMapWalls2D[TargetIndex], ToiletWatchPoints);
				if (LocateSecondToiletSuccess)
				{
					FVector2D DirOfWatchPoint = ToiletWatchPoints[0] - IndexMapWallCenter[TargetIndex];
					DirOfWatchPoint = DirOfWatchPoint.GetSafeNormal();
					PanoramaWatchPoints.Add(TempRoomId, ToiletWatchPoints[0]);
					RoomIDMapWatchDirections.Add(TempRoomId, DirOfWatchPoint);
				}
				else
				{
					TArray<FVector2D> TempWallPoints = IndexMapWalls2D[TargetIndex];
					FVector2D TempSide1 = TempWallPoints[1] - TempWallPoints[0];
					FVector2D TempSide2 = TempWallPoints[2] - TempWallPoints[1];
					float LengthOfSide1 = TempSide1.Size();
					float LengthOfSide2 = TempSide2.Size();
					if (LengthOfSide1 > LengthOfSide2)
					{
						FVector2D TempDir = TempSide1.GetSafeNormal();
						FVector2D TempRotatedDir = TempDir.GetRotated(90);
						FVector2D TempExtendP = IndexMapWallCenter[TargetIndex] + TempRotatedDir * 35;
						PanoramaWatchPoints.Add(TempRoomId, TempExtendP);
						RoomIDMapWatchDirections.Add(TempRoomId, TempRotatedDir);
					}
					else
					{
						FVector2D TempDir = TempSide2.GetSafeNormal();
						FVector2D TempRotatedDir = TempDir.GetRotated(90);
						FVector2D TempExtendP = IndexMapWallCenter[TargetIndex] + TempRotatedDir * 35;
						PanoramaWatchPoints.Add(TempRoomId, TempExtendP);
						RoomIDMapWatchDirections.Add(TempRoomId, TempRotatedDir);
					}
				}
				TArray<FVector>DoorPoints;
				bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
				if (GetDoorSuccess)
				{
					int TempNumOfDoors = DoorPoints.Num() / 8;
					if (TempNumOfDoors > 0)
					{
						RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
					}
				}
			}
			else
			{
				if (UpdateRegionPs.Num() <= 6)
				{
					TArray<FVector>DoorPoints;
					bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
					if (!GetDoorSuccess)
					{
						PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
						FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}
					else
					{
						int NumOfDoors = DoorPoints.Num() / 8;
						RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
						if (NumOfDoors == 1)
						{
							FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
							FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
							DirVec = DirVec.GetSafeNormal();
							DirVec = DirVec.GetRotated(90);
							FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
							FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
							FVector2D TempVec1 = DoorCenter2D + 50 * DirVec;
							if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, TempVec1))
							{
								PanoramaWatchPoints.Add(TempRoomId, TempVec1);
								FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
							}
							else
							{
								FVector2D TempP = DoorCenter2D - 50 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, TempP))
								{
									PanoramaWatchPoints.Add(TempRoomId, TempP);
									FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempP;
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
								else
								{
									PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
									FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}

							}
						}
						else if (NumOfDoors >= 2)
						{
							FVector2D TempCenter = RegionCenters[RoomIndex];
							if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, TempCenter))
							{
								PanoramaWatchPoints.Add(TempRoomId, TempCenter);
								float MinDis = 0.0;
								int TargetDoorIndex = 0;
								for (int J = 0; J < NumOfDoors; ++J)
								{
									FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
									FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
									float TempDis = FVector2D::Distance(TempCenter, TempDoorCenter2D);
									if ((MinDis == 0.0) || (TempDis < MinDis))
									{
										MinDis = TempDis;
										TargetDoorIndex = J;
									}
								}

								FVector TempDirVec = DoorPoints[1 + 8 * TargetDoorIndex] - DoorPoints[0 + 8 * TargetDoorIndex];
								FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
								DirVec = DirVec.GetSafeNormal();
								DirVec = DirVec.GetRotated(90);
								FVector DoorCenter3D = 0.25*(DoorPoints[0 + 8 * TargetDoorIndex] + DoorPoints[1 + 8 * TargetDoorIndex] + DoorPoints[2 + 8 * TargetDoorIndex]
									+ DoorPoints[3 + 8 * TargetDoorIndex]);
								FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
								FVector2D TestVec1 = TempCenter - DoorCenter2D;
								float TestValue1 = FVector2D::DotProduct(TestVec1, DirVec);
								if (TestValue1 > 0)
								{
									RoomIDMapWatchDirections.Add(TempRoomId, DirVec);

								}
								else
								{
									RoomIDMapWatchDirections.Add(TempRoomId, -DirVec);
								}
							}
							else
							{
								PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
								FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
							}
						}
					}
				}
				else if (UpdateRegionPs.Num() >= 7)
				{
					TArray<FVector>DoorPoints;
					bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
					if (!GetDoorSuccess)
					{
						PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
						FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}
					else
					{
						int NumOfDoors = DoorPoints.Num() / 8;
						RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
						if (NumOfDoors == 1)
						{
							FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
							FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
							DirVec = DirVec.GetSafeNormal();
							DirVec = DirVec.GetRotated(90);
							FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
							FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
							PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
							FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - DoorCenter2D;
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						else if (NumOfDoors >= 2)
						{
							FVector2D TempCenter = RegionCenters[RoomIndex];
							float MinDis = 0.0;
							int TargetDoorIndex = 0;
							for (int J = 0; J < NumOfDoors; ++J)
							{
								FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
								FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
								float TempDis = FVector2D::Distance(TempCenter, TempDoorCenter2D);
								if ((MinDis == 0.0) || (TempDis < MinDis))
								{
									MinDis = TempDis;
									TargetDoorIndex = J;
								}
							}

							FVector TempDirVec = DoorPoints[1 + 8 * TargetDoorIndex] - DoorPoints[0 + 8 * TargetDoorIndex];
							FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
							DirVec = DirVec.GetSafeNormal();
							DirVec = DirVec.GetRotated(90);
							FVector DoorCenter3D = 0.25*(DoorPoints[0 + 8 * TargetDoorIndex] + DoorPoints[1 + 8 * TargetDoorIndex] + DoorPoints[2 + 8 * TargetDoorIndex]
								+ DoorPoints[3 + 8 * TargetDoorIndex]);
							FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
							PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
							FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - DoorCenter2D;
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
					}
				}
			}
		}
		else if (TempRoomName == TEXT("厨房"))
		{
			if ((!IsOpenKitchen1) && (!IsOpenKitchen2))
			{
				TArray<FVector>DoorPoints;
				bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
				if (!GetDoorSuccess)
				{
					PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
					FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
					TempDir = TempDir.GetSafeNormal();
					RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
				}
				else
				{
					int NumOfDoors = DoorPoints.Num() / 8;
					RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
					if (NumOfDoors == 1)
					{
						FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
						FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
						DirVec = DirVec.GetSafeNormal();
						DirVec = DirVec.GetRotated(90);
						FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
						FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
						FVector2D TempVec1 = DoorCenter2D + 35 * DirVec;
						if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
						{
							PanoramaWatchPoints.Add(TempRoomId, TempVec1);
							FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						else
						{
							FVector2D TempP = DoorCenter2D - 35 * DirVec;
							if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
							{
								PanoramaWatchPoints.Add(TempRoomId, TempP);
								FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempP;
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
							}
							else
							{
								PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
								FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
							}

						}
					}
					else if (NumOfDoors >= 2)
					{
						FVector2D TempCenter = RegionCenters[RoomIndex];
						float MinDis = 0.0;
						int TargetDoorIndex = 0;
						for (int J = 0; J < NumOfDoors; ++J)
						{
							FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
							FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
							float TempDis = FVector2D::Distance(TempCenter, TempDoorCenter2D);
							if ((MinDis == 0.0) || (TempDis < MinDis))
							{
								MinDis = TempDis;
								TargetDoorIndex = J;
							}
						}

						FVector TempDirVec = DoorPoints[1 + 8 * TargetDoorIndex] - DoorPoints[0 + 8 * TargetDoorIndex];
						FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
						DirVec = DirVec.GetSafeNormal();
						DirVec = DirVec.GetRotated(90);
						FVector DoorCenter3D = 0.25*(DoorPoints[0 + 8 * TargetDoorIndex] + DoorPoints[1 + 8 * TargetDoorIndex]
							+ DoorPoints[2 + 8 * TargetDoorIndex] + DoorPoints[3 + 8 * TargetDoorIndex]);
						FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);

						FVector2D TempVec1 = DoorCenter2D + 35 * DirVec;
						if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
						{
							PanoramaWatchPoints.Add(TempRoomId, TempVec1);
							FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						else
						{
							FVector2D TempP = DoorCenter2D - 35 * DirVec;
							if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
							{
								PanoramaWatchPoints.Add(TempRoomId, TempP);
								FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempP;
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
							}
							else
							{
								PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
								FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
							}
						}
					}
				}
			}
			else if ((IsOpenKitchen1) || (IsOpenKitchen2))
			{
				TArray<FVector>DoorPoints;
				PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
				FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
				TempDir = TempDir.GetSafeNormal();
				RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
				bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
				if (GetDoorSuccess)
				{
					RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
				}
			}
		}
		else if (TempRoomName == TEXT("储藏间"))
		{
			TArray<FVector>DoorPoints;
			bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
			if (!GetDoorSuccess)
			{
				PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
				FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
				TempDir = TempDir.GetSafeNormal();
				RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
			}
			else
			{
				int NumOfDoors = DoorPoints.Num() / 8;
				RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
				if (NumOfDoors == 1)
				{
					FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
					FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
					DirVec = DirVec.GetSafeNormal();
					DirVec = DirVec.GetRotated(90);
					FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
					FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
					FVector2D TempVec1 = DoorCenter2D + 20 * DirVec;
					if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
					{
						PanoramaWatchPoints.Add(TempRoomId, TempVec1);
						FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}
					else
					{
						FVector2D TempP = DoorCenter2D - 20 * DirVec;
						if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
						{
							PanoramaWatchPoints.Add(TempRoomId, TempP);
							FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempP;
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						else
						{
							PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
							FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}

					}
				}
				else if (NumOfDoors >= 2)
				{
					FVector2D TempCenter = RegionCenters[RoomIndex];
					float MaxDis = 0.0;
					int TargetDoorIndex = 0;
					for (int J = 0; J < NumOfDoors; ++J)
					{
						FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
						FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
						float TempDis = FVector2D::Distance(TempCenter, TempDoorCenter2D);
						if ((MaxDis == 0.0) || (TempDis > MaxDis))
						{
							MaxDis = TempDis;
							TargetDoorIndex = J;
						}
					}

					FVector TempDirVec = DoorPoints[1 + 8 * TargetDoorIndex] - DoorPoints[0 + 8 * TargetDoorIndex];
					FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
					DirVec = DirVec.GetSafeNormal();
					DirVec = DirVec.GetRotated(90);
					FVector DoorCenter3D = 0.25*(DoorPoints[0 + 8 * TargetDoorIndex] + DoorPoints[1 + 8 * TargetDoorIndex] +
						DoorPoints[2 + 8 * TargetDoorIndex] + DoorPoints[3 + 8 * TargetDoorIndex]);
					FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
					FVector2D TempVec1 = DoorCenter2D + 20 * DirVec;
					if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
					{
						PanoramaWatchPoints.Add(TempRoomId, TempVec1);
						FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}
					else
					{
						FVector2D TempP = DoorCenter2D - 20 * DirVec;
						if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
						{
							PanoramaWatchPoints.Add(TempRoomId, TempP);
							FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempP;
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						else
						{
							PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
							FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}

					}
				}
			}
		}
		else if ((TempRoomName == TEXT("衣帽间")) || (TempRoomName == TEXT("茶室")))
		{
			TArray<FVector>DoorPoints;
			bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
			if (!GetDoorSuccess)
			{
				PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
				FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
				TempDir = TempDir.GetSafeNormal();
				RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
			}
			else
			{
				int NumOfDoors = DoorPoints.Num() / 8;
				RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
				if (NumOfDoors == 1)
				{
					FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
					FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
					DirVec = DirVec.GetSafeNormal();
					DirVec = DirVec.GetRotated(90);
					FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
					FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
					FVector2D TempVec1 = DoorCenter2D + 35 * DirVec;
					if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
					{
						PanoramaWatchPoints.Add(TempRoomId, TempVec1);
						FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}
					else
					{
						FVector2D TempP = DoorCenter2D - 35 * DirVec;
						if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
						{
							PanoramaWatchPoints.Add(TempRoomId, TempP);
							FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempP;
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						else
						{
							PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
							FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}

					}
				}
				else if (NumOfDoors >= 2)
				{
					FVector2D TempCenter = RegionCenters[RoomIndex];
					float MaxDis = 0.0;
					int TargetDoorIndex = 0;
					for (int J = 0; J < NumOfDoors; ++J)
					{
						FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
						FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
						float TempDis = FVector2D::Distance(TempCenter, TempDoorCenter2D);
						if ((MaxDis == 0.0) || (TempDis > MaxDis))
						{
							MaxDis = TempDis;
							TargetDoorIndex = J;
						}
					}

					FVector TempDirVec = DoorPoints[1 + 8 * TargetDoorIndex] - DoorPoints[0 + 8 * TargetDoorIndex];
					FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
					DirVec = DirVec.GetSafeNormal();
					DirVec = DirVec.GetRotated(90);
					FVector DoorCenter3D = 0.25*(DoorPoints[0 + 8 * TargetDoorIndex] + DoorPoints[1 + 8 * TargetDoorIndex] +
						DoorPoints[2 + 8 * TargetDoorIndex] + DoorPoints[3 + 8 * TargetDoorIndex]);
					FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
					FVector2D TempVec1 = DoorCenter2D + 35 * DirVec;
					if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
					{
						PanoramaWatchPoints.Add(TempRoomId, TempVec1);
						FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}
					else
					{
						FVector2D TempP = DoorCenter2D - 35 * DirVec;
						if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
						{
							PanoramaWatchPoints.Add(TempRoomId, TempP);
							FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempP;
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						else
						{
							PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
							FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}

					}
				}
			}
		}
	}
	//////////////////修正客厅以及餐厅观察点///////////////////////////////
	if ((IFInterSect) || (HasCommonPoints))
	{
		FVector2D LivingPickP = RoomIDMapRegionCenters[LivingRoomID];
		FVector2D DiningPickP = RoomIDMapRegionCenters[DiningRoomID];
		FVector2D UpdateFirstPoint, UpdateSecondPoint, UpdateWatchPoint;
		bool IsAdjusted = FPolygonAlg::AdjustWatchAndPickPoints(LivingPickP, DiningPickP, LivingRoomPs, DiningRoomPs, UpdateFirstPoint, UpdateSecondPoint, UpdateWatchPoint);
		if (IsAdjusted)
		{
			PanoramaWatchPoints[LivingRoomID] = UpdateWatchPoint;
			PanoramaWatchPoints[DiningRoomID] = UpdateWatchPoint;
			RoomIDMapRegionCenters[LivingRoomID] = UpdateFirstPoint;
			RoomIDMapRegionCenters[DiningRoomID] = UpdateSecondPoint;
			FVector2D TempDir = UpdateWatchPoint - UpdateFirstPoint;
			TempDir = TempDir.GetSafeNormal();
			RoomIDMapWatchDirections[LivingRoomID] = -TempDir;
			RoomIDMapWatchDirections[DiningRoomID] = TempDir;
		}
	}
	/////////////////////修正第三厅与第四厅的观察点////////////////////////
	if ((IFInterSectOfThirdAndFourth) || (HasCommonPointsOfThirdAndFourth))
	{
		FVector2D ThirdPickP = RoomIDMapRegionCenters[ThirdDingingRoomID];
		FVector2D FourthPickP = RoomIDMapRegionCenters[FourthDiningRoomID];
		FVector2D UpdateFirstPoint, UpdateSecondPoint, UpdateWatchPoint;
		bool IsChangedThirdAndFourth = FPolygonAlg::AdjustWatchAndPickPoints(ThirdPickP, FourthPickP, ThirdDinging, FourthDining, UpdateFirstPoint, UpdateSecondPoint, UpdateWatchPoint);
		if (IsChangedThirdAndFourth)
		{
			PanoramaWatchPoints[ThirdDingingRoomID] = UpdateWatchPoint;
			PanoramaWatchPoints[FourthDiningRoomID] = UpdateWatchPoint;
			RoomIDMapRegionCenters[ThirdDingingRoomID] = UpdateFirstPoint;
			RoomIDMapRegionCenters[FourthDiningRoomID] = UpdateSecondPoint;
			FVector2D TempDir = UpdateWatchPoint - UpdateFirstPoint;
			TempDir = TempDir.GetSafeNormal();
			RoomIDMapWatchDirections[ThirdDingingRoomID] = -TempDir;
			RoomIDMapWatchDirections[FourthDiningRoomID] = TempDir;
		}
	}

	/////////////////计算空间区域母子关系//////////////////////////////////
	TArray<FParentRoom>  ParentRooms;
	TMap<int, TArray<int>> ParentMapChildren;
	TArray<int> PossibleParentRoomIDs;
	bool PreCalSuccess = CalculateParentRelation(WorldContextObject, InJson, PossibleParentRoomIDs, ParentRooms);
	if (PreCalSuccess)
	{
		for (int _CurPar = 0; _CurPar < ParentRooms.Num(); ++_CurPar)
		{
			TArray<int> TempChildren = ParentRooms[_CurPar].RoomIDs;
			ParentMapChildren.Add(ParentRooms[_CurPar].ParentRoomID, TempChildren);
		}
	}

	////////////设置全景图观察点以及门洞数据的Json
	TArray<UVaRestJsonObject*> PanoramaWatchPointArray;
	int PanoraPointOrder = NumOfTotalPickPs;

	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}

		if (TempString == TEXT("客厅"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);
			SinglePointObj->SetNumberField("parentroomid", 0);
			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			SinglePointObj->SetNumberField("z", 130);
			SinglePointObj->SetNumberField("floor", 1);
			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);
			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("客厅"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);

			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}

	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("餐厅"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);
			SinglePointObj->SetNumberField("parentroomid", 0);
			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			SinglePointObj->SetNumberField("z", 130);
			SinglePointObj->SetNumberField("floor", 1);
			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);
			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("餐厅"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);

			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}


	TMap<int, int> SpecialRoomIDMapPointID;
	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("主卧"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);
			SpecialRoomIDMapPointID.Add(TempRoomID, PanoraPointOrder);
			SinglePointObj->SetNumberField("parentroomid", 0);
			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			if (SpecialRoomIDs.Contains(AllRoomIDs[Index]))
			{
				SinglePointObj->SetNumberField("z", 120);
			}
			else
			{
				SinglePointObj->SetNumberField("z", 130);
			}

			SinglePointObj->SetNumberField("floor", 1);
			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("主卧"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);


			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}

	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];

		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("次卧"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);
			SinglePointObj->SetNumberField("parentroomid", 0);
			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			if (SpecialRoomIDs.Contains(AllRoomIDs[Index]))
			{
				SinglePointObj->SetNumberField("z", 120);
			}
			else
			{
				SinglePointObj->SetNumberField("z", 130);
			}


			SinglePointObj->SetNumberField("floor", 1);
			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("次卧"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);


			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}

	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("儿童房"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);
			SinglePointObj->SetNumberField("parentroomid", 0);
			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			if (SpecialRoomIDs.Contains(AllRoomIDs[Index]))
			{
				SinglePointObj->SetNumberField("z", 120);
			}
			else
			{
				SinglePointObj->SetNumberField("z", 130);
			}


			SinglePointObj->SetNumberField("floor", 1);
			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("儿童房"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);

			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}

	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("老人房"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);
			SinglePointObj->SetNumberField("parentroomid", 0);
			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			if (SpecialRoomIDs.Contains(AllRoomIDs[Index]))
			{
				SinglePointObj->SetNumberField("z", 120);
			}
			else
			{
				SinglePointObj->SetNumberField("z", 130);
			}


			SinglePointObj->SetNumberField("floor", 1);
			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("老人房"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);


			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}

	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("书房"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);
			SinglePointObj->SetNumberField("parentroomid", 0);
			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			if (SpecialRoomIDs.Contains(AllRoomIDs[Index]))
			{
				SinglePointObj->SetNumberField("z", 120);
			}
			else
			{
				SinglePointObj->SetNumberField("z", 130);
			}

			SinglePointObj->SetNumberField("floor", 1);
			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("书房"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);


			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}

	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("榻榻米房"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);
			SinglePointObj->SetNumberField("parentroomid", 0);
			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			if (SpecialRoomIDs.Contains(AllRoomIDs[Index]))
			{
				SinglePointObj->SetNumberField("z", 120);
			}
			else
			{
				SinglePointObj->SetNumberField("z", 130);
			}


			SinglePointObj->SetNumberField("floor", 1);
			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("榻榻米房"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);


			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}


	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("客人房"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);
			SinglePointObj->SetNumberField("parentroomid", 0);
			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			if (SpecialRoomIDs.Contains(AllRoomIDs[Index]))
			{
				SinglePointObj->SetNumberField("z", 120);
			}
			else
			{
				SinglePointObj->SetNumberField("z", 130);
			}


			SinglePointObj->SetNumberField("floor", 1);
			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("客人房"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);


			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}


	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("健身房"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);
			SinglePointObj->SetNumberField("parentroomid", 0);
			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			if (SpecialRoomIDs.Contains(AllRoomIDs[Index]))
			{
				SinglePointObj->SetNumberField("z", 120);
			}
			else
			{
				SinglePointObj->SetNumberField("z", 130);
			}


			SinglePointObj->SetNumberField("floor", 1);
			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("健身房"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);


			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}

	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("衣帽间"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);

			bool LocalFindParent = false;
			for (int _CurPar = 0; _CurPar < ParentMapChildren.Num(); ++_CurPar)
			{
				for (int Index = 0; Index < PossibleParentRoomIDs.Num(); ++Index)
				{
					if (ParentMapChildren.Contains(PossibleParentRoomIDs[Index]))
					{
						TArray<int> TempChildren = ParentMapChildren[PossibleParentRoomIDs[Index]];
						if (TempChildren.Contains(TempRoomID))
						{
							SinglePointObj->SetNumberField("parentroomid", PossibleParentRoomIDs[Index]);
							LocalFindParent = true;
							break;
						}
					}
				}
			}
			if (!LocalFindParent)
			{
				SinglePointObj->SetNumberField("parentroomid", 0);
			}

			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			SinglePointObj->SetNumberField("z", 130);


			SinglePointObj->SetNumberField("floor", 1);
			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("衣帽间"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);


			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}

			PanoramaWatchPointArray.Add(TempPoint);
		}
	}

	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("储藏间"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);
			SinglePointObj->SetNumberField("parentroomid", 0);
			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			SinglePointObj->SetNumberField("z", 130);


			SinglePointObj->SetNumberField("floor", 1);
			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("储藏间"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);


			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}

	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("起居室"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);
			SinglePointObj->SetNumberField("parentroomid", 0);
			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			SinglePointObj->SetNumberField("z", 130);
			SinglePointObj->SetNumberField("floor", 1);
			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);
			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("起居室"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);

			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}

	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("多功能房"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);
			SinglePointObj->SetNumberField("parentroomid", 0);
			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			if (SpecialRoomIDs.Contains(AllRoomIDs[Index]))
			{
				SinglePointObj->SetNumberField("z", 120);
			}
			else
			{
				SinglePointObj->SetNumberField("z", 130);
			}


			SinglePointObj->SetNumberField("floor", 1);
			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("多功能房"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);


			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}


	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("茶室"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);
			SinglePointObj->SetNumberField("parentroomid", 0);
			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			SinglePointObj->SetNumberField("z", 130);
			SinglePointObj->SetNumberField("floor", 1);
			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("茶室"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);

			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}


	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("厨房"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);
			SinglePointObj->SetNumberField("parentroomid", 0);
			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			SinglePointObj->SetNumberField("z", 130);


			SinglePointObj->SetNumberField("floor", 1);
			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("厨房"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);

			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}


	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("主卫"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);

			bool LocalFindParent = false;
			for (int _CurPar = 0; _CurPar < ParentMapChildren.Num(); ++_CurPar)
			{
				for (int Index = 0; Index < PossibleParentRoomIDs.Num(); ++Index)
				{
					if (ParentMapChildren.Contains(PossibleParentRoomIDs[Index]))
					{
						TArray<int> TempChildren = ParentMapChildren[PossibleParentRoomIDs[Index]];
						if (TempChildren.Contains(TempRoomID))
						{
							SinglePointObj->SetIntegerField("parentroomid", PossibleParentRoomIDs[Index]);
							LocalFindParent = true;
							break;
						}
					}
				}
			}
			if (!LocalFindParent)
			{
				SinglePointObj->SetNumberField("parentroomid", 0);
			}

			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			SinglePointObj->SetNumberField("z", 130);
			SinglePointObj->SetNumberField("floor", 1);
			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("主卫"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);

			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}


	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("客卫"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);
			SinglePointObj->SetNumberField("parentroomid", 0);

			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			SinglePointObj->SetNumberField("z", 130);
			SinglePointObj->SetNumberField("floor", 1);
			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("客卫"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);


			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}


	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("卫生间"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);

			bool LocalFindParent = false;
			for (int _CurPar = 0; _CurPar < ParentMapChildren.Num(); ++_CurPar)
			{
				for (int Index = 0; Index < PossibleParentRoomIDs.Num(); ++Index)
				{
					if (ParentMapChildren.Contains(PossibleParentRoomIDs[Index]))
					{
						TArray<int> TempChildren = ParentMapChildren[PossibleParentRoomIDs[Index]];
						if (TempChildren.Contains(TempRoomID))
						{
							SinglePointObj->SetNumberField("parentroomid", PossibleParentRoomIDs[Index]);
							LocalFindParent = true;
							break;
						}
					}
				}
			}
			if (!LocalFindParent)
			{
				SinglePointObj->SetNumberField("parentroomid", 0);
			}

			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			SinglePointObj->SetNumberField("z", 130);
			SinglePointObj->SetNumberField("floor", 1);
			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);
			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("卫生间"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);

			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}


	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("生活阳台"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);

			bool LocalFindParent = false;
			for (int _CurPar = 0; _CurPar < ParentMapChildren.Num(); ++_CurPar)
			{
				for (int Index = 0; Index < PossibleParentRoomIDs.Num(); ++Index)
				{
					if (ParentMapChildren.Contains(PossibleParentRoomIDs[Index]))
					{
						TArray<int> TempChildren = ParentMapChildren[PossibleParentRoomIDs[Index]];
						if (TempChildren.Contains(TempRoomID))
						{
							SinglePointObj->SetNumberField("parentroomid", PossibleParentRoomIDs[Index]);
							LocalFindParent = true;
							break;
						}
					}
				}
			}
			if (!LocalFindParent)
			{
				SinglePointObj->SetNumberField("parentroomid", 0);
			}


			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			SinglePointObj->SetNumberField("z", 130);
			SinglePointObj->SetNumberField("floor", 1);

			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("生活阳台"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);

			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}


	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("休闲阳台"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);

			bool LocalFindParent = false;
			for (int _CurPar = 0; _CurPar < ParentMapChildren.Num(); ++_CurPar)
			{
				for (int Index = 0; Index < PossibleParentRoomIDs.Num(); ++Index)
				{
					if (ParentMapChildren.Contains(PossibleParentRoomIDs[Index]))
					{
						TArray<int> TempChildren = ParentMapChildren[PossibleParentRoomIDs[Index]];
						if (TempChildren.Contains(TempRoomID))
						{
							SinglePointObj->SetNumberField("parentroomid", PossibleParentRoomIDs[Index]);
							LocalFindParent = true;
							break;
						}
					}
				}
			}
			if (!LocalFindParent)
			{
				SinglePointObj->SetNumberField("parentroomid", 0);
			}

			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			SinglePointObj->SetNumberField("z", 130);
			SinglePointObj->SetNumberField("floor", 1);
			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("休闲阳台"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);

			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}
			PanoramaWatchPointArray.Add(TempPoint);
		}
	}


	for (int Index = 0; Index < AllRoomIDs.Num(); Index++)
	{
		int TempRoomID = AllRoomIDs[Index];
		FString TempString = RoomIDMapName[TempRoomID];
		TArray<FVector> TempDoorHolePoints;
		int NumOfDoors = 0;
		if (RoomIDMapHoleData.Contains(TempRoomID))
		{
			TempDoorHolePoints = RoomIDMapHoleData[TempRoomID];
			NumOfDoors = TempDoorHolePoints.Num() / 8;
		}
		if (TempString == TEXT("卧室阳台"))
		{
			PanoraPointOrder++;
			UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", PanoraPointOrder);

			bool LocalFindParent = false;
			for (int _CurPar = 0; _CurPar < ParentMapChildren.Num(); ++_CurPar)
			{
				for (int Index = 0; Index < PossibleParentRoomIDs.Num(); ++Index)
				{
					if (ParentMapChildren.Contains(PossibleParentRoomIDs[Index]))
					{
						TArray<int> TempChildren = ParentMapChildren[PossibleParentRoomIDs[Index]];
						if (TempChildren.Contains(TempRoomID))
						{
							SinglePointObj->SetNumberField("parentroomid", PossibleParentRoomIDs[Index]);
							LocalFindParent = true;
							break;
						}
					}
				}
			}
			if (!LocalFindParent)
			{
				SinglePointObj->SetNumberField("parentroomid", 0);
			}


			SinglePointObj->SetNumberField("x", PanoramaWatchPoints[TempRoomID].X);
			SinglePointObj->SetNumberField("y", PanoramaWatchPoints[TempRoomID].Y);
			SinglePointObj->SetNumberField("z", 130);
			SinglePointObj->SetNumberField("floor", 1);
			SinglePointObj->SetNumberField("x_direction", RoomIDMapWatchDirections[TempRoomID].X);
			SinglePointObj->SetNumberField("y_direction", RoomIDMapWatchDirections[TempRoomID].Y);
			SinglePointObj->SetNumberField("z_direction", 0.0);

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Add(SinglePointObj);
			TempPoint->SetObjectArrayField("point", PointObjArrTemp);
			TempPoint->SetStringField("roomName", RoomIDMapName[TempRoomID]);
			TempPoint->SetIntegerField("roomId", TempRoomID);
			TempPoint->SetStringField("roomOldUsageName", TEXT("卧室阳台"));
			TempPoint->SetStringField("roomUsageName", RoomIDMapUseageName[TempRoomID]);
			TempPoint->SetNumberField("usageId", RoomIDMapUsageID[TempRoomID]);

			if (NumOfDoors != 0)
			{
				TArray<UVaRestJsonObject*> CollectHoleJson;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					UVaRestJsonObject* EachHoleData = NewObject<UVaRestJsonObject>();
					TArray<UVaRestJsonObject*> EachHoleObjAttr;
					for (int I = 0; I < 8; ++I)
					{
						UVaRestJsonObject* TempHolePs = NewObject<UVaRestJsonObject>();
						TempHolePs->SetNumberField("x", TempDoorHolePoints[8 * DoorIndex + I].X);
						TempHolePs->SetNumberField("y", TempDoorHolePoints[8 * DoorIndex + I].Y);
						TempHolePs->SetNumberField("z", TempDoorHolePoints[8 * DoorIndex + I].Z);
						EachHoleObjAttr.Add(TempHolePs);
					}
					EachHoleData->SetObjectArrayField("holepoint", EachHoleObjAttr);
					CollectHoleJson.Add(EachHoleData);
				}
				TempPoint->SetObjectArrayField("hole", CollectHoleJson);
			}

			PanoramaWatchPointArray.Add(TempPoint);
		}
	}


	OutPanoramaJson->SetObjectArrayField("panoramaLocation", PanoramaWatchPointArray);
	//////////////计算客厅走廊以及玄关位置//////////////////
	UVaRestJsonObject *SegmentsJson = UVaRestJsonObject::ConstructJsonObject(WorldContextObject);
	if (RoomIDMapHoleData.Contains(LivingRoomID))
	{
		TArray<FVector> LivingRoomHoleData = RoomIDMapHoleData[LivingRoomID];
		bool CreateSegsSuccess = CreateSegmentsJson(WorldContextObject, LivingRoomPs, LivingRoomID, LivingRoomHoleData, SegmentsJson);
		if (CreateSegsSuccess)
		{
			OutPanoramaJson->MergeJsonObject(SegmentsJson, true);
		}
	}
	/////////////////////////////计算墙体上下前后四个面归属区域的关系///////////////////////////////
////////////////////////////////////////定位边界墙///////////////////////////////////////////////
	TArray<int> BoundaryWallIndexs;
	TMap<int, int> BoundaryWallIndexMapRoomID, FirstGroupWallIndexMapRoomID, SecondGroupWallIndexMapRoomID;


	for (int _CurWall = 0; _CurWall < WallJsonObj.Num(); ++_CurWall)
	{
		if (IndexMapWalls2D.Contains(_CurWall))
		{
			TArray<FVector2D> MapWallPs = IndexMapWalls2D[_CurWall];
			FVector2D LocalWallCenter = 0.25*(MapWallPs[0] + MapWallPs[1] + MapWallPs[2] + MapWallPs[3]);
			FVector2D CenterOfSide1 = 0.5*(MapWallPs[0] + MapWallPs[3]);
			FVector2D CenterOfSide2 = 0.5*(MapWallPs[1] + MapWallPs[2]);
			FVector2D DirOfSide1 = MapWallPs[3] - MapWallPs[0];
			FVector2D DirOfSide2 = MapWallPs[2] - MapWallPs[1];
			float LengthOfSide1 = DirOfSide1.Size();
			float LengthOfSide2 = DirOfSide2.Size();
			DirOfSide1.Normalize();
			DirOfSide2.Normalize();
			FVector2D TempCenter1 = 0.5*(MapWallPs[0] + MapWallPs[3]);
			FVector2D TempCenter2 = 0.5*(MapWallPs[1] + MapWallPs[2]);
			FVector2D TempBaseDir = DirOfSide2;
			FVector2D TempBaseCenter = TempCenter2;
			if (DirOfSide1 < DirOfSide2)
			{
				TempBaseDir = DirOfSide1;
			}
			FVector2D TempRotatedDirOfLine = TempBaseDir.GetRotated(90);

			FVector2D TempExtendP1 = TempBaseCenter + 30 * TempRotatedDirOfLine;
			FVector2D TempExtendP2 = TempBaseCenter - 30 * TempRotatedDirOfLine;

			FVector2D WallCenterPointToFirst = MapWallPs[0] - LocalWallCenter;
			int TempCount1 = 0;
			int TempCount2 = 0;
			bool IsP1InRegion = false;
			bool IsP2InRegion = false;
			int TempRoomId1 = 0;
			int TempRoomId2 = 0;
			for (int _CurRoom = 0; _CurRoom < AllRoomIDs.Num(); ++_CurRoom)
			{
				if (RoomIDMapRegions.Contains(AllRoomIDs[_CurRoom]))
				{
					IsP1InRegion = FPolygonAlg::JudgePointInPolygon(RoomIDMapRegions[AllRoomIDs[_CurRoom]], TempExtendP1);
					IsP2InRegion = FPolygonAlg::JudgePointInPolygon(RoomIDMapRegions[AllRoomIDs[_CurRoom]], TempExtendP2);
					if (IsP1InRegion)
					{
						TempCount1++;
						TempRoomId1 = AllRoomIDs[_CurRoom];
					}
					if (IsP2InRegion)
					{
						TempCount2++;
						TempRoomId2 = AllRoomIDs[_CurRoom];
					}
				}
			}
			if (TempCount1 + TempCount2 == 1)
			{
				BoundaryWallIndexs.Add(_CurWall);
				if (TempRoomId1 != 0)
				{
					BoundaryWallIndexMapRoomID.Add(_CurWall, TempRoomId1);
				}
				if (TempRoomId2 != 0)
				{
					BoundaryWallIndexMapRoomID.Add(_CurWall, TempRoomId2);
				}
			}
			else if ((TempCount1 == 1) && (TempCount2 == 1))
			{
				float VecDotValue = FVector2D::DotProduct(WallCenterPointToFirst, TempRotatedDirOfLine);
				if (VecDotValue > 0.0f)
				{
					FirstGroupWallIndexMapRoomID.Add(_CurWall, TempRoomId1);
					SecondGroupWallIndexMapRoomID.Add(_CurWall, TempRoomId2);
				}
				else
				{
					FirstGroupWallIndexMapRoomID.Add(_CurWall, TempRoomId2);
					SecondGroupWallIndexMapRoomID.Add(_CurWall, TempRoomId1);
				}
			}
		}
	}

	///////////////////////////增加墙体归属关系到json数据里/////////////////////////////////////////
	TArray<UVaRestJsonObject*> WallRelationJson;
	for (int WallIndex = 0; WallIndex < WallJsonObj.Num(); ++WallIndex)
	{
		if (IndexMapWalls.Contains(WallIndex))
		{
			TArray<UVaRestJsonObject*> TempJsonArr;
			//////////边界墙体的面归属信息塞进json///////////////////////////
			if (BoundaryWallIndexs.Contains(WallIndex))
			{
				for (int _CurFace = 0; _CurFace < 4; ++_CurFace)
				{
					UVaRestJsonObject* EachJson = NewObject<UVaRestJsonObject>();
					if (_CurFace == 0)
					{
						TArray<int> TempFaceIDArray1;
						TempFaceIDArray1.Add(0);
						TempFaceIDArray1.Add(1);
						TempFaceIDArray1.Add(2);
						TempFaceIDArray1.Add(3);
						EachJson->SetIntegerArrayField("index", TempFaceIDArray1);
						int TempMappedRoom = 0;
						if (BoundaryWallIndexMapRoomID.Contains(WallIndex))
						{
							TempMappedRoom = BoundaryWallIndexMapRoomID[WallIndex];
						}

						EachJson->SetIntegerField("roomId", TempMappedRoom);
						TempJsonArr.Add(EachJson);
					}
					else if (_CurFace == 1)
					{
						TArray<int> TempFaceIDArray2;
						TempFaceIDArray2.Add(4);
						TempFaceIDArray2.Add(5);
						TempFaceIDArray2.Add(6);
						TempFaceIDArray2.Add(7);
						EachJson->SetIntegerArrayField("index", TempFaceIDArray2);
						int TempMappedRoom = 0;
						if (BoundaryWallIndexMapRoomID.Contains(WallIndex))
						{
							TempMappedRoom = BoundaryWallIndexMapRoomID[WallIndex];
						}

						EachJson->SetIntegerField("roomId", TempMappedRoom);
						TempJsonArr.Add(EachJson);
					}
					else if (_CurFace == 2)
					{
						TArray<int> TempFaceIDArray3;
						TempFaceIDArray3.Add(5);
						TempFaceIDArray3.Add(0);
						TempFaceIDArray3.Add(3);
						TempFaceIDArray3.Add(6);
						EachJson->SetIntegerArrayField("index", TempFaceIDArray3);
						int TempMappedRoom = 0;
						if (BoundaryWallIndexMapRoomID.Contains(WallIndex))
						{
							TempMappedRoom = BoundaryWallIndexMapRoomID[WallIndex];
						}

						EachJson->SetIntegerField("roomId", TempMappedRoom);
						TempJsonArr.Add(EachJson);
					}
					else if (_CurFace == 3)
					{
						TArray<int> TempFaceIDArray4;
						TempFaceIDArray4.Add(2);
						TempFaceIDArray4.Add(1);
						TempFaceIDArray4.Add(4);
						TempFaceIDArray4.Add(7);
						EachJson->SetIntegerArrayField("index", TempFaceIDArray4);
						int TempMappedRoom = 0;
						if (BoundaryWallIndexMapRoomID.Contains(WallIndex))
						{
							TempMappedRoom = BoundaryWallIndexMapRoomID[WallIndex];
						}

						EachJson->SetIntegerField("roomId", TempMappedRoom);
						TempJsonArr.Add(EachJson);
					}
				}
			}
			//////////第一类类型的墙体面归属信息塞进json//////////////////////
			if (FirstGroupWallIndexMapRoomID.Contains(WallIndex))
			{
				UVaRestJsonObject* EachJson = NewObject<UVaRestJsonObject>();
				TArray<int> TempFaceIDArray;
				TempFaceIDArray.Add(5);
				TempFaceIDArray.Add(0);
				TempFaceIDArray.Add(3);
				TempFaceIDArray.Add(6);

				int TempMappedRoom = 0;
				TempMappedRoom = FirstGroupWallIndexMapRoomID[WallIndex];
				EachJson->SetIntegerArrayField("index", TempFaceIDArray);
				EachJson->SetIntegerField("roomId", TempMappedRoom);
				TempJsonArr.Add(EachJson);
			}
			//////////第二类类型的墙体面归属信息塞进json/////////////////////
			if (SecondGroupWallIndexMapRoomID.Contains(WallIndex))
			{
				UVaRestJsonObject* EachJson = NewObject<UVaRestJsonObject>();
				TArray<int> TempFaceIDArray;
				TempFaceIDArray.Add(2);
				TempFaceIDArray.Add(1);
				TempFaceIDArray.Add(4);
				TempFaceIDArray.Add(7);

				int TempMappedRoom = 0;
				TempMappedRoom = SecondGroupWallIndexMapRoomID[WallIndex];
				EachJson->SetIntegerArrayField("index", TempFaceIDArray);
				EachJson->SetIntegerField("roomId", TempMappedRoom);
				TempJsonArr.Add(EachJson);
			}

			UVaRestJsonObject* EachJsonInfo = NewObject<UVaRestJsonObject>();
			if (TempJsonArr.Num() > 0)
			{
				EachJsonInfo->SetObjectArrayField("faceRelation", TempJsonArr);
			}

			if (IndexMapWalls.Contains(WallIndex))
			{
				TArray<UVaRestJsonObject*> NewWallPs;
				TArray<FVector> WallPs = IndexMapWalls[WallIndex];
				for (int _CurWallP = 0; _CurWallP < WallPs.Num(); ++_CurWallP)
				{
					UVaRestJsonObject* TempWallXYZ = NewObject<UVaRestJsonObject>();
					TempWallXYZ->SetNumberField("x", WallPs[_CurWallP].X);
					TempWallXYZ->SetNumberField("y", WallPs[_CurWallP].Y);
					TempWallXYZ->SetNumberField("z", WallPs[_CurWallP].Z);
					NewWallPs.Add(TempWallXYZ);
				}
				EachJsonInfo->SetObjectArrayField("wallPoints", NewWallPs);
			}
			WallRelationJson.Add(EachJsonInfo);
		}
	}


	UVaRestJsonObject* RelationJson = NewObject<UVaRestJsonObject>();
	RelationJson->SetObjectArrayField("wallRelation", WallRelationJson);
	OutPanoramaJson->MergeJsonObject(RelationJson, true);
	return true;
}



bool UWriteMeshObj_FunctionLibrary::WriteLocationPointsToOFF(UObject* WorldContextObject, UVaRestJsonObject* InJson, const FString FilePath)
{
	if ((InJson == nullptr) || (*FilePath == NULL))
	{
		return false;
	}
	TArray<FVector> LocationPoints;

	TArray<UVaRestJsonObject*> PointObjArrTemp = InJson->GetObjectArrayField("cameraLocation");

	for (int I = 0; I < PointObjArrTemp.Num(); ++I)
	{
		TArray<UVaRestJsonObject*> Points = PointObjArrTemp[I]->GetObjectArrayField("point");
		for (int J = 0; J < Points.Num(); ++J)
		{
			float TempX = Points[J]->GetNumberField("x");
			float TempY = Points[J]->GetNumberField("y");
			float TempZ = Points[J]->GetNumberField("z");
			LocationPoints.Add(FVector(TempX, TempY, TempZ));
		}
	}
	if (LocationPoints.Num() == 0)
	{
		return false;
	}
	int SolutionID = InJson->GetNumberField("solutionId");
	FString FileName = FString::FromInt(SolutionID);
	FString ObjFileName = FilePath + FileName + "_locationPs.OFF";
	std::ofstream OutFile(*ObjFileName);
	OutFile << "OFF" << std::endl;
	OutFile << LocationPoints.Num() << " " << 0 << " " << 0 << std::endl;
	for (int Index = 0; Index < LocationPoints.Num(); Index++)
	{
		OutFile << LocationPoints[Index].X << " " << LocationPoints[Index].Y << " " << LocationPoints[Index].Z << std::endl;

	}
	OutFile.close();
	return true;
}


bool UWriteMeshObj_FunctionLibrary::WritePanoraWatchPointsToOFF(UObject* WorldContextObject, UVaRestJsonObject* InJson, const FString FilePath)
{
	if ((InJson == nullptr) || (*FilePath == NULL))
	{
		return false;
	}
	TArray<FVector> PanoramaWatchPoints;

	TArray<UVaRestJsonObject*> PointObjArrTemp = InJson->GetObjectArrayField("panoramaLocation");

	for (int I = 0; I < PointObjArrTemp.Num(); ++I)
	{
		TArray<UVaRestJsonObject*> Points = PointObjArrTemp[I]->GetObjectArrayField("point");
		for (int J = 0; J < Points.Num(); ++J)
		{
			float TempX = Points[J]->GetNumberField("x");
			float TempY = Points[J]->GetNumberField("y");
			float TempZ = Points[J]->GetNumberField("z");
			PanoramaWatchPoints.Add(FVector(TempX, TempY, TempZ));
		}
	}
	if (PanoramaWatchPoints.Num() == 0)
	{
		return false;
	}

	int SolutionID = InJson->GetNumberField("solutionId");
	FString FileName = FString::FromInt(SolutionID);
	FString ObjFileName = FilePath + FileName + "_panoramaWatch.OFF";
	std::ofstream OutFile(*ObjFileName);
	OutFile << "OFF" << std::endl;
	OutFile << PanoramaWatchPoints.Num() << " " << 0 << " " << 0 << std::endl;
	for (int Index = 0; Index < PanoramaWatchPoints.Num(); Index++)
	{
		OutFile << PanoramaWatchPoints[Index].X << " " << PanoramaWatchPoints[Index].Y << " " << PanoramaWatchPoints[Index].Z << std::endl;

	}
	OutFile.close();
	return true;



}

bool UWriteMeshObj_FunctionLibrary::CreateMapWatchPoints(UObject* WorldContextObject, UVaRestJsonObject* InJson, int SolutionID, int RoomID,
	FVector& WatchPoint, FVector& LookDir)
{
	UVaRestJsonObject* OutPanoramaJson = nullptr;
	TMap<int, FVector> WatchPoints;
	TMap<int, FVector> LookDirs;
	const float WatchPointgHeight = 130;
	bool CreateSuccess = CreatePanoramaWithInformation(WorldContextObject, InJson, OutPanoramaJson, WatchPoints, LookDirs, WatchPointgHeight);
	if (!CreateSuccess)
	{
		return false;
	}
	int TempSolutionID = 0;
	TempSolutionID = OutPanoramaJson->GetNumberField("solutionId");
	if (TempSolutionID != SolutionID)
	{
		return false;
	}
	if (!WatchPoints.Contains(RoomID))
	{
		return false;
	}
	WatchPoint = WatchPoints[RoomID];
	LookDir = LookDirs[RoomID];
	return true;
}


bool  UWriteMeshObj_FunctionLibrary::CreatePanoramaWithInformation(UObject* WorldContextObject, UVaRestJsonObject* InJson, UVaRestJsonObject* &OutPanoramaJson,
	TMap<int, FVector>& WatchPoints, TMap<int, FVector>& LookDirs, const float WatchPointHeight)
{
	if (InJson == nullptr)
	{
		return false;
	}
	if (!OutPanoramaJson)
		OutPanoramaJson = UVaRestJsonObject::ConstructJsonObject(WorldContextObject);

	int SolutionID = 0;
	SolutionID = InJson->GetNumberField("solutionId");
	OutPanoramaJson->SetNumberField("solutionId", SolutionID);

	FString SolutionName = InJson->GetStringField("solutionName");
	OutPanoramaJson->SetStringField("name", SolutionName);

	int UserId = InJson->GetNumberField("userId");
	OutPanoramaJson->SetNumberField("userId", UserId);

	TArray<UVaRestJsonObject*> RoomJsonObj = InJson->GetObjectArrayField("roomList");
	TArray<UVaRestJsonObject*> NewRoomJsonObj;
	TMap<int, TArray<FVector2D>> RoomIDMapRegions;
	TMap<int, FString> RoomIDMapName;
	TArray<int> AllRoomIDs;
	TMap<int, FString> RoomIDMapUseageName;
	TMap<int, int> RoomIDMapUsageID;
	for (int RoomIndex = 0; RoomIndex < RoomJsonObj.Num(); RoomIndex++)
	{
		UVaRestJsonObject* NewRoomJson = NewObject<UVaRestJsonObject>();
		TArray<UVaRestJsonObject*> EachRoomRegion = RoomJsonObj[RoomIndex]->GetObjectArrayField("areas");
		TArray<UVaRestJsonObject*> NewEachRoomRegion;
		TArray<FVector2D> TempRegionPs;


		int RoomId = RoomJsonObj[RoomIndex]->GetIntegerField("roomId");
		NewRoomJson->SetIntegerField("roomId", RoomId);
		AllRoomIDs.Add(RoomId);


		for (int NumIndex = 0; NumIndex < EachRoomRegion.Num(); NumIndex++)
		{
			UVaRestJsonObject* TempXY = NewObject<UVaRestJsonObject>();
			float TempX = EachRoomRegion[NumIndex]->GetNumberField("x");
			float TempY = EachRoomRegion[NumIndex]->GetNumberField("y");
			TempRegionPs.AddUnique(FVector2D(TempX, TempY));
			TempXY->SetNumberField("x", TempX);
			TempXY->SetNumberField("y", TempY);
			NewEachRoomRegion.Add(TempXY);
		}
		NewRoomJson->SetObjectArrayField("areas", NewEachRoomRegion);

		FString RoomName = RoomJsonObj[RoomIndex]->GetStringField("roomName");
		NewRoomJson->SetStringField("roomName", RoomName);

		RoomIDMapRegions.Add(RoomId, TempRegionPs);
		RoomIDMapName.Add(RoomId, RoomName);
		FString RoomUsageName = RoomJsonObj[RoomIndex]->GetStringField("roomUsageName");
		NewRoomJson->SetStringField("roomUsageName", RoomUsageName);
		RoomIDMapUseageName.Add(RoomId, RoomUsageName);
		int RoomUsageId = RoomJsonObj[RoomIndex]->GetNumberField("usageId");
		RoomIDMapUsageID.Add(RoomId, RoomUsageId);
		NewRoomJson->SetNumberField("usageId", RoomUsageId);
		NewRoomJsonObj.Add(NewRoomJson);
	}

	TArray<UVaRestJsonObject*> WallJsonObj = InJson->GetObjectArrayField("walls");
	TArray<UVaRestJsonObject*> NewWallJsonObj;

	TMap<int, TArray<FVector>> IndexMapWalls;
	TMap<int, FVector2D>IndexMapWallCenter;
	TMap<int, TArray<FVector2D>> IndexMapWalls2D;
	for (int WallIndex = 0; WallIndex < WallJsonObj.Num(); WallIndex++)
	{
		UVaRestJsonObject* NewWallJson = NewObject<UVaRestJsonObject>();
		TArray<UVaRestJsonObject*> WallPs = WallJsonObj[WallIndex]->GetObjectArrayField("wallPoints");
		TArray<UVaRestJsonObject*> NewWallPs;
		TArray<FVector> TempWall;
		TArray<FVector2D> TempWall2D;
		FVector2D TempWallCenter(0.0, 0.0);
		for (int NumIndex = 0; NumIndex < WallPs.Num(); NumIndex++)
		{
			UVaRestJsonObject* TempWallXYZ = NewObject<UVaRestJsonObject>();
			float TempX = WallPs[NumIndex]->GetNumberField("x");
			float TempY = WallPs[NumIndex]->GetNumberField("y");
			float TempZ = WallPs[NumIndex]->GetNumberField("z");
			TempWallXYZ->SetNumberField("x", TempX);
			TempWallXYZ->SetNumberField("y", TempY);
			TempWallXYZ->SetNumberField("z", TempZ);
			NewWallPs.Add(TempWallXYZ);
			TempWall.Add(FVector(TempX, TempY, TempZ));
			TempWall2D.Add(FVector2D(TempX, TempY));
			TempWallCenter = TempWallCenter + FVector2D(TempX, TempY);
		}
		TempWallCenter = TempWallCenter / WallPs.Num();
		IndexMapWalls.Add(WallIndex, TempWall);
		IndexMapWalls2D.Add(WallIndex, TempWall2D);
		IndexMapWallCenter.Add(WallIndex, TempWallCenter);
		NewWallJson->SetObjectArrayField("wallPoints", NewWallPs);
		NewWallJsonObj.Add(NewWallJson);
	}


	UVaRestJsonObject* ObjData = NewObject<UVaRestJsonObject>();
	ObjData->SetObjectArrayField("roomList", NewRoomJsonObj);
	ObjData->SetObjectArrayField("walls", NewWallJsonObj);
	OutPanoramaJson->SetObjectField("objData", ObjData);

	UVaRestJsonObject	*LocationJson = UVaRestJsonObject::ConstructJsonObject(WorldContextObject);
	TArray<FVector2D> RegionCenters;
	int NumOfTotalPickPs = 0;
	TMap<int, FloorGroup> GroupRoomIDs;
	bool  IsSuccess = CreateAdvancedLocationJsonWithFloors(WorldContextObject, InJson, LocationJson, RegionCenters, NumOfTotalPickPs, GroupRoomIDs);
	if (!IsSuccess)
	{
		return false;
	}
	OutPanoramaJson->MergeJsonObject(LocationJson, true);
	///////////////Match RoomID with RegionCenters//////////////////////////
	if (AllRoomIDs.Num() != RegionCenters.Num())
	{
		return false;
	}

	TMap<int, FVector2D> RoomIDMapRegionCenters;
	for (int I = 0; I < AllRoomIDs.Num(); ++I)
	{
		RoomIDMapRegionCenters.Add(AllRoomIDs[I], RegionCenters[I]);
	}
	///////获取全景图观察点
		//////////预处理客餐厅数据////////////////////////////
	TArray<FVector2D> LivingRoomPs, DiningRoomPs, KitchenRoomPs;
	int LivingRoomID = 0, DiningRoomID = 0, KitchenRoomID = 0;
	bool IsLivingRoom = false;
	bool IsDiningRoom = false;
	bool IsKitchenRoom = false;
	for (int I = 0; I < AllRoomIDs.Num(); ++I)
	{
		int TempRoomId = AllRoomIDs[I];
		FString TempRoomName = RoomIDMapName[TempRoomId];
		if ((TempRoomName == TEXT("客厅")) && (!IsLivingRoom))
		{
			LivingRoomPs = RoomIDMapRegions[TempRoomId];
			LivingRoomID = TempRoomId;
			IsLivingRoom = true;
		}
		else if ((TempRoomName == TEXT("餐厅")) && (!IsDiningRoom))
		{
			DiningRoomPs = RoomIDMapRegions[TempRoomId];
			DiningRoomID = TempRoomId;
			IsDiningRoom = true;
		}
		else if ((TempRoomName == TEXT("厨房")) && (!IsKitchenRoom))
		{
			KitchenRoomID = TempRoomId;
			KitchenRoomPs = RoomIDMapRegions[TempRoomId];
			IsKitchenRoom = true;
		}
	}
	bool IFInterSect = false;
	bool HasCommonPoints = false;
	if ((LivingRoomPs.Num() != 0) && (DiningRoomPs.Num() != 0))
	{
		IFInterSect = FPolygonAlg::JudgePolygonInterSect(LivingRoomPs, DiningRoomPs);
		HasCommonPoints = FPolygonAlg::JudgeHasClosePoint(LivingRoomPs, DiningRoomPs);
	}
	//////////////预处理第三厅以及第四厅数据///////////////////////////
	TArray<FVector2D> ThirdDinging, FourthDining;
	int ThirdDingingRoomID = 0, FourthDiningRoomID = 0;
	bool IsThirdDining = false;
	bool IsFourthDining = false;
	for (int I = 0; I < AllRoomIDs.Num(); ++I)
	{
		int TempRoomId = AllRoomIDs[I];
		FString TempRoomName = RoomIDMapName[TempRoomId];
		if (((TempRoomName == TEXT("客厅")) || (TempRoomName == TEXT("起居室"))) && (TempRoomId != LivingRoomID) && (!IsThirdDining))
		{
			ThirdDinging = RoomIDMapRegions[TempRoomId];
			ThirdDingingRoomID = TempRoomId;
			IsThirdDining = true;
		}
		else if ((TempRoomName == TEXT("餐厅")) && (TempRoomId != DiningRoomID) && (!IsFourthDining))
		{
			FourthDining = RoomIDMapRegions[TempRoomId];
			FourthDiningRoomID = TempRoomId;
			IsFourthDining = true;
		}
	}
	bool IFInterSectOfThirdAndFourth = false;
	bool HasCommonPointsOfThirdAndFourth = false;
	if ((ThirdDinging.Num() != 0) && (FourthDining.Num() != 0))
	{
		IFInterSectOfThirdAndFourth = FPolygonAlg::JudgePolygonInterSect(ThirdDinging, FourthDining);
		HasCommonPointsOfThirdAndFourth = FPolygonAlg::JudgeHasClosePoint(ThirdDinging, FourthDining);
	}
	/////////////预处理厨房数据,判断厨房是否是开放式厨房//////////////////
	bool IsOpenKitchen1 = false;
	bool IsOpenKitchen2 = false;

	for (int Index = 0; Index < AllRoomIDs.Num(); ++Index)
	{
		if (AllRoomIDs[Index] != KitchenRoomID)
		{
			TArray<FVector2D> TempRoomPs;
			TempRoomPs = RoomIDMapRegions[AllRoomIDs[Index]];
			IsOpenKitchen1 = FPolygonAlg::JudgePolygonInterSect(KitchenRoomPs, TempRoomPs);
			if (IsOpenKitchen1)
			{
				break;
			}
			TArray<FVector2D> UpdateKitchenRoomPs, UpdateTempRoomPs, TempInterSectPs, TempCombinedPolygon;
			IsOpenKitchen2 = FPolygonAlg::CalculateTwoPolygonInterSect(KitchenRoomPs, TempRoomPs, UpdateKitchenRoomPs, UpdateTempRoomPs, TempInterSectPs, TempCombinedPolygon);
			if (IsOpenKitchen2)
			{
				break;
			}
		}
	}
	TMap<int, FVector2D> PanoramaWatchPoints;
	TMap<int, FVector2D> RoomIDMapWatchDirections;
	TMap<int, TArray<FVector>> RoomIDMapHoleData;
	TArray<int> SpecialRoomIDs;
	for (int RoomIndex = 0; RoomIndex < AllRoomIDs.Num(); RoomIndex++)
	{
		int TempRoomId = AllRoomIDs[RoomIndex];
		FString TempRoomName = RoomIDMapName[TempRoomId];
		TArray<FVector2D> TempRegionPs;
		TempRegionPs = RoomIDMapRegions[TempRoomId];
		if ((TempRoomName == TEXT("主卧")) || (TempRoomName == TEXT("次卧")) || (TempRoomName == TEXT("儿童房")) || (TempRoomName == TEXT("老人房"))
			|| (TempRoomName == TEXT("榻榻米房")) || (TempRoomName == TEXT("客人房")) || (TempRoomName == TEXT("书房")) || (TempRoomName == TEXT("健身房"))
			|| (TempRoomName == TEXT("多功能房")))
		{
			TArray<FVector2D> UpdateRegionPs;
			FPolygonAlg::MergeCollinearPoints(TempRegionPs, UpdateRegionPs);
			TArray<AFurnitureModelActor*> ModelsOfRoom;
			FindModelsOfRoom(WorldContextObject, UpdateRegionPs, ModelsOfRoom);
			AFurnitureModelActor* FindFur = nullptr;
			bool FindModel = false;
			bool IsSame = false;
			for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
			{
				AFurnitureModelActor* TempFur = ModelsOfRoom[_CurM];
				int TempID = 0;
				TempFur->GetModelCategory(TempID);
				if ((TempID == 5009) || (TempID == 5010))
				{
					FindFur = TempFur;
					FindModel = true;
					break;
				}
			}
			if (FindModel)
			{
				FBox TempBox = FindFur->GetComponentsBoundingBox(true);
				FVector FMin = TempBox.Min;
				FVector FMax = TempBox.Max;
				FVector2D P1(FMin.X, FMin.Y);
				FVector2D P2(FMax.X, FMin.Y);
				FVector2D P3(FMax.X, FMax.Y);
				FVector2D P4(FMin.X, FMax.Y);
				FVector2D BoxCenter = 0.25*(P1 + P2 + P3 + P4);
				float Dis1 = FVector2D::Distance(P1, P2);
				float Dis2 = FVector2D::Distance(P2, P3);
				FVector2D TempWatchP;
				FVector2D TempDir;
				const float ExtendL = 20;
				if (Dis1 > Dis2)
				{
					FVector2D TempPointVec = P2 - P1;
					TempPointVec = TempPointVec.GetSafeNormal();
					FVector2D TryP1 = BoxCenter + TempPointVec * (0.5*Dis1 + ExtendL);
					FVector2D TryP2 = BoxCenter - TempPointVec * (0.5*Dis1 + ExtendL);
					bool JudgeTryP1 = FPolygonAlg::JudgePointOnOrInPolygon(UpdateRegionPs, TryP1);
					bool JudgeTryP2 = FPolygonAlg::JudgePointOnOrInPolygon(UpdateRegionPs, TryP2);
					if (JudgeTryP1&&JudgeTryP2)
					{
						TempPointVec = P3 - P2;
						TempPointVec = TempPointVec.GetSafeNormal();
						TryP1 = BoxCenter + TempPointVec * (0.5*Dis2 + ExtendL);
						TryP2 = BoxCenter - TempPointVec * (0.5*Dis2 + ExtendL);
						JudgeTryP1 = FPolygonAlg::JudgePointOnOrInPolygon(UpdateRegionPs, TryP1);
						JudgeTryP2 = FPolygonAlg::JudgePointOnOrInPolygon(UpdateRegionPs, TryP2);
						if (JudgeTryP1&&JudgeTryP2)
						{
							IsSame = true;
						}
						else
						{
							FVector2D TempInterSectP1, TempInterSectP2;
							FPolygonAlg::CalculateRayToInterSectP(UpdateRegionPs, BoxCenter, TempPointVec, TempInterSectP1);
							FPolygonAlg::CalculateRayToInterSectP(UpdateRegionPs, BoxCenter, -TempPointVec, TempInterSectP2);
							float DisToInterSectP1 = FVector2D::Distance(BoxCenter, TempInterSectP1);
							float DisToInterSectP2 = FVector2D::Distance(BoxCenter, TempInterSectP2);
							if ((DisToInterSectP1 >= 20) || (DisToInterSectP2 >= 20))
							{
								if (DisToInterSectP1 > DisToInterSectP2)
								{
									TempWatchP = 0.5*(0.5*(P3 + P4) + TempInterSectP1);
									TempDir = -TempPointVec;
								}
								else
								{
									TempWatchP = 0.5*(0.5*(P1 + P2) + TempInterSectP2);
									TempDir = TempPointVec;
								}
							}
						}
					}
					else
					{
						FVector2D TempInterSectP1, TempInterSectP2;
						FPolygonAlg::CalculateRayToInterSectP(UpdateRegionPs, BoxCenter, TempPointVec, TempInterSectP1);
						FPolygonAlg::CalculateRayToInterSectP(UpdateRegionPs, BoxCenter, -TempPointVec, TempInterSectP2);
						float DisToInterSectP1 = FVector2D::Distance(BoxCenter, TempInterSectP1);
						float DisToInterSectP2 = FVector2D::Distance(BoxCenter, TempInterSectP2);
						if ((DisToInterSectP1 >= 20) || (DisToInterSectP2 >= 20))
						{
							if (DisToInterSectP1 > DisToInterSectP2)
							{
								TempWatchP = 0.5*(0.5*(P2 + P3) + TempInterSectP1);
								TempDir = -TempPointVec;
							}
							else
							{
								TempWatchP = 0.5*(0.5*(P4 + P1) + TempInterSectP2);
								TempDir = TempPointVec;
							}
						}
					}
				}
				else
				{
					FVector2D TempPointVec = P3 - P2;
					TempPointVec = TempPointVec.GetSafeNormal();
					FVector2D TryP1 = BoxCenter + TempPointVec * (0.5*Dis2 + ExtendL);
					FVector2D TryP2 = BoxCenter - TempPointVec * (0.5*Dis2 + ExtendL);
					bool JudgeTryP1 = FPolygonAlg::JudgePointOnOrInPolygon(UpdateRegionPs, TryP1);
					bool JudgeTryP2 = FPolygonAlg::JudgePointOnOrInPolygon(UpdateRegionPs, TryP2);
					if (JudgeTryP1 && JudgeTryP2)
					{
						TempPointVec = P2 - P1;
						TempPointVec = TempPointVec.GetSafeNormal();
						TryP1 = BoxCenter + TempPointVec * (0.5*Dis1 + ExtendL);
						TryP2 = BoxCenter - TempPointVec * (0.5*Dis1 + ExtendL);
						JudgeTryP1 = FPolygonAlg::JudgePointOnOrInPolygon(UpdateRegionPs, TryP1);
						JudgeTryP2 = FPolygonAlg::JudgePointOnOrInPolygon(UpdateRegionPs, TryP2);
						if (JudgeTryP1&&JudgeTryP2)
						{
							IsSame = true;
						}
						else
						{
							FVector2D TempInterSectP1, TempInterSectP2;
							FPolygonAlg::CalculateRayToInterSectP(UpdateRegionPs, BoxCenter, TempPointVec, TempInterSectP1);
							FPolygonAlg::CalculateRayToInterSectP(UpdateRegionPs, BoxCenter, -TempPointVec, TempInterSectP2);
							float DisToInterSectP1 = FVector2D::Distance(BoxCenter, TempInterSectP1);
							float DisToInterSectP2 = FVector2D::Distance(BoxCenter, TempInterSectP2);
							if ((DisToInterSectP1 >= 20) || (DisToInterSectP2 >= 20))
							{
								if (DisToInterSectP1 > DisToInterSectP2)
								{
									TempWatchP = 0.5*(0.5*(P3 + P4) + TempInterSectP1);
									TempDir = -TempPointVec;
								}
								else
								{
									TempWatchP = 0.5*(0.5*(P1 + P2) + TempInterSectP2);
									TempDir = TempPointVec;
								}
							}
						}
					}
					else
					{
						FVector2D TempInterSectP1, TempInterSectP2;
						FPolygonAlg::CalculateRayToInterSectP(UpdateRegionPs, BoxCenter, TempPointVec, TempInterSectP1);
						FPolygonAlg::CalculateRayToInterSectP(UpdateRegionPs, BoxCenter, -TempPointVec, TempInterSectP2);
						float DisToInterSectP1 = FVector2D::Distance(BoxCenter, TempInterSectP1);
						float DisToInterSectP2 = FVector2D::Distance(BoxCenter, TempInterSectP2);
						if ((DisToInterSectP1 >= 20) || (DisToInterSectP2 >= 20))
						{
							if (DisToInterSectP1 > DisToInterSectP2)
							{
								TempWatchP = 0.5*(0.5*(P3 + P4) + TempInterSectP1);
								TempDir = -TempPointVec;
							}
							else
							{
								TempWatchP = 0.5*(0.5*(P1 + P2) + TempInterSectP2);
								TempDir = TempPointVec;
							}
						}
					}
				}

				if (!IsSame)
				{
					bool FindPointInModel = false;
					for (auto TempModelInRoom : ModelsOfRoom)
					{
						FBox TempBox = TempModelInRoom->GetComponentsBoundingBox(true);
						FString ModelName = TempModelInRoom->GetName();
						if (!ModelName.Contains(TEXT("Light")))
						{
							bool IfInModel = TempBox.IsInsideOrOn(FVector(TempWatchP, 130));
							if (IfInModel)
							{
								FVector FMin = TempBox.Min;
								FVector FMax = TempBox.Max;
								bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, UpdateRegionPs);
								if (ModelBoxIsUseful)
								{
									FindPointInModel = true;
									break;
								}
							}
						}
					}
					bool IsInSide = false;
					IsInSide = FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, TempWatchP);

					if ((!FindPointInModel) && (IsInSide))
					{
						PanoramaWatchPoints.Add(TempRoomId, TempWatchP);
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						SpecialRoomIDs.AddUnique(TempRoomId);
						TArray<FVector>DoorPoints;
						bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
						if (GetDoorSuccess)
						{
							int TempNumOfDoors = DoorPoints.Num() / 8;
							if (TempNumOfDoors > 0)
							{
								RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
							}
						}
					}
					else
					{
						IsSame = true;
					}
				}
			}
			else
			{
				IsSame = true;
			}
			if (IsSame)
			{
				TArray<FVector>DoorPoints;
				if (UpdateRegionPs.Num() <= 5)
				{
					bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
					if (!GetDoorSuccess)
					{
						PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
						FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}
					else
					{

						int NumOfDoors = DoorPoints.Num() / 8;
						RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
						FVector2D SuitPoint;
						TArray<FVector2D> RoomWallPs;
						bool GetWallSuccess = GetWallPointsOfRoom(WorldContextObject, TempRoomId, RoomWallPs);
						if (GetWallSuccess)
						{
							bool GetSpecialSuccess = FPolygonAlg::GetRegionOfFourCornerSpecialRoom(UpdateRegionPs, SuitPoint, RoomWallPs, DoorPoints, 0.01);
							if (GetSpecialSuccess)
							{
								if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, SuitPoint))
								{
									PanoramaWatchPoints.Add(TempRoomId, SuitPoint);
									FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - SuitPoint;
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
								else
								{
									PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
									FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}

							}
							else
							{
								if (NumOfDoors == 1)
								{
									FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
									FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
									DirVec = DirVec.GetSafeNormal();
									DirVec = DirVec.GetRotated(90);
									FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
									FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
									FVector2D TempVec1 = DoorCenter2D + 100 * DirVec;
									if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, TempVec1))
									{
										PanoramaWatchPoints.Add(TempRoomId, TempVec1);
										FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
									}
									else
									{
										if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, DoorCenter2D - 100 * DirVec))
										{
											PanoramaWatchPoints.Add(TempRoomId, DoorCenter2D - 100 * DirVec);
											FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - (DoorCenter2D - 100 * DirVec);
											TempDir = TempDir.GetSafeNormal();
											RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
										}
										else
										{
											PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
											FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
											TempDir = TempDir.GetSafeNormal();
											RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
										}

									}
								}
								else if (NumOfDoors >= 2)
								{
									FVector2D TempCenter = RegionCenters[RoomIndex];
									float MaxDis = 0.0;
									int TargetDoorIndex = 0;
									for (int J = 0; J < NumOfDoors; ++J)
									{
										FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
										FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
										float TempDis = FVector2D::Distance(TempCenter, TempDoorCenter2D);
										if ((MaxDis == 0.0) || (TempDis > MaxDis))
										{
											MaxDis = TempDis;
											TargetDoorIndex = J;
										}
									}
									FVector2D PStart = FVector2D(DoorPoints[0 + 8 * TargetDoorIndex].X, DoorPoints[1 + 8 * TargetDoorIndex].Y);
									FVector2D PEnd = FVector2D(DoorPoints[2 + 8 * TargetDoorIndex].X, DoorPoints[3 + 8 * TargetDoorIndex].Y);
									FVector2D ParallelPStart, ParallelPEnd;
									const float DisValue = 30;
									int ParallelEdgeIndex = 0;
									bool FindSuccess = FPolygonAlg::FindParallelEdge(UpdateRegionPs, PStart, PEnd, ParallelPStart, ParallelPEnd, ParallelEdgeIndex, DisValue);
									if (!FindSuccess)
									{
										FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
										FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
										DirVec = DirVec.GetSafeNormal();
										DirVec = DirVec.GetRotated(90);
										FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
										FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
										FVector2D TempVec1 = DoorCenter2D + 100 * DirVec;
										if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, TempVec1))
										{
											PanoramaWatchPoints.Add(TempRoomId, TempVec1);
											FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
											TempDir = TempDir.GetSafeNormal();
											RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
										}
										else
										{
											if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, DoorCenter2D - 100 * DirVec))
											{
												PanoramaWatchPoints.Add(TempRoomId, DoorCenter2D - 100 * DirVec);
												FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - (DoorCenter2D - 100 * DirVec);
												TempDir = TempDir.GetSafeNormal();
												RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
											}
											else
											{
												PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
												FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
												TempDir = TempDir.GetSafeNormal();
												RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
											}

										}
									}
									else
									{
										FVector TempDirVec = DoorPoints[1 + 8 * TargetDoorIndex] - DoorPoints[0 + 8 * TargetDoorIndex];
										FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
										DirVec = DirVec.GetSafeNormal();
										DirVec = DirVec.GetRotated(90);
										FVector DoorCenter3D = 0.25*(DoorPoints[0 + 8 * TargetDoorIndex] + DoorPoints[1 + 8 * TargetDoorIndex] + DoorPoints[2 + 8 * TargetDoorIndex]
											+ DoorPoints[3 + 8 * TargetDoorIndex]);
										FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
										FVector2D TempVec1 = DoorCenter2D + 100 * DirVec;
										if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, TempVec1))
										{
											PanoramaWatchPoints.Add(TempRoomId, TempVec1);
											FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
											TempDir = TempDir.GetSafeNormal();
											RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
										}
										else
										{
											if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, DoorCenter2D - 100 * DirVec))
											{
												PanoramaWatchPoints.Add(TempRoomId, DoorCenter2D - 100 * DirVec);
												FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - (DoorCenter2D - 100 * DirVec);
												TempDir = TempDir.GetSafeNormal();
												RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
											}
											else
											{
												PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
												FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
												TempDir = TempDir.GetSafeNormal();
												RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
											}

										}
									}
								}
							}
						}
						else
						{
							PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
							FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
					}
				}
				else if (UpdateRegionPs.Num() >= 6)
				{
					bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
					if (!GetDoorSuccess)
					{
						PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
						FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}
					else
					{
						int NumOfDoors = DoorPoints.Num() / 8;
						RoomIDMapHoleData.Add(TempRoomId, DoorPoints);

						TArray<FVector2D> MaxAreaRegion;
						FVector2D SuitPoint;

						bool GetSuccess = FPolygonAlg::GetMaxRegionOfSpecialRoom(UpdateRegionPs, MaxAreaRegion, SuitPoint, DoorPoints);
						if (GetSuccess)
						{
							if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, SuitPoint))
							{
								PanoramaWatchPoints.Add(TempRoomId, SuitPoint);
								FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - SuitPoint;
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
							}
							else
							{
								PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
								FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
							}

						}
						else
						{
							const float DisBound = 180;
							if (NumOfDoors == 1)
							{
								///////////////////////////////////////////////////计算从门中心出发射线与区域的交点/////////////////////////////////////////////////
								FVector2D TempDoorLoc = 0.25*FVector2D(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
								FVector2D TempDoorVec = FVector2D(DoorPoints[1] - DoorPoints[0]);
								TempDoorVec = TempDoorVec.GetSafeNormal();
								FVector2D TempRotateOfVec = TempDoorVec.GetRotated(90);
								FVector2D TempExtendP = TempDoorLoc + 40 * TempRotateOfVec;
								bool IfInArea = FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, TempExtendP);
								bool HasLocated = false;
								if (IfInArea)
								{
									FVector2D TempInterP;
									bool IsLocated = FPolygonAlg::CalculateRayInterSectPoly(UpdateRegionPs, TempDoorLoc, TempRotateOfVec, TempInterP, DisBound);
									if (IsLocated)
									{
										FVector2D SuitLoc = 0.5*(TempInterP + TempDoorLoc);
										PanoramaWatchPoints.Add(TempRoomId, SuitLoc);
										FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - SuitLoc;
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
										HasLocated = true;
									}
								}
								else
								{
									FVector2D TempInterP;
									bool IsLocated = FPolygonAlg::CalculateRayInterSectPoly(UpdateRegionPs, TempDoorLoc, -TempRotateOfVec, TempInterP, DisBound);
									if (IsLocated)
									{
										FVector2D SuitLoc = 0.5*(TempInterP + TempDoorLoc);
										PanoramaWatchPoints.Add(TempRoomId, SuitLoc);
										FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - SuitLoc;
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
										HasLocated = true;
									}
								}

								if (!HasLocated)
								{
									PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
									FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}

							}
							else if (NumOfDoors >= 2)
							{
								FVector2D TempCenter = RegionCenters[RoomIndex];
								float MaxDis = 0.0;
								int TargetDoorIndex = 0;
								for (int J = 0; J < NumOfDoors; ++J)
								{
									FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
									FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
									float TempDis = FVector2D::Distance(TempCenter, TempDoorCenter2D);
									if ((MaxDis == 0.0) || (TempDis > MaxDis))
									{
										MaxDis = TempDis;
										TargetDoorIndex = J;
									}
								}

								FVector2D TempDoorLoc = 0.25*FVector2D(DoorPoints[8 * TargetDoorIndex + 0] + DoorPoints[8 * TargetDoorIndex + 1] + DoorPoints[8 * TargetDoorIndex + 2] + DoorPoints[8 * TargetDoorIndex + 3]);
								FVector2D TempDoorVec = FVector2D(DoorPoints[8 * TargetDoorIndex + 1] - DoorPoints[8 * TargetDoorIndex + 0]);
								TempDoorVec = TempDoorVec.GetSafeNormal();
								FVector2D TempRotateOfVec = TempDoorVec.GetRotated(90);
								FVector2D TempExtendP = TempDoorLoc + 40 * TempRotateOfVec;
								bool IfInArea = FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, TempExtendP);
								bool HasLocated = false;
								if (IfInArea)
								{
									FVector2D TempInterP;
									bool IsLocated = FPolygonAlg::CalculateRayInterSectPoly(UpdateRegionPs, TempDoorLoc, TempRotateOfVec, TempInterP, DisBound);
									if (IsLocated)
									{
										FVector2D SuitLoc = 0.5*(TempInterP + TempDoorLoc);
										PanoramaWatchPoints.Add(TempRoomId, SuitLoc);
										FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - SuitLoc;
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
										HasLocated = true;
									}
								}
								else
								{
									FVector2D TempInterP;
									bool IsLocated = FPolygonAlg::CalculateRayInterSectPoly(UpdateRegionPs, TempDoorLoc, -TempRotateOfVec, TempInterP, DisBound);
									if (IsLocated)
									{
										FVector2D SuitLoc = 0.5*(TempInterP + TempDoorLoc);
										PanoramaWatchPoints.Add(TempRoomId, SuitLoc);
										FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - SuitLoc;
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
										HasLocated = true;
									}
								}

								if (!HasLocated)
								{
									PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
									FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
							}
						}
					}
				}
			}

		}
		else if ((TempRoomName == TEXT("客厅")) || (TempRoomName == TEXT("起居室")))
		{
			if (TempRoomId == LivingRoomID)
			{
				if ((LivingRoomPs.Num() != 0) && (DiningRoomPs.Num() != 0))
				{
					if ((IFInterSect) || (HasCommonPoints))
					{
						FVector2D TempCenter = 0.5*(RoomIDMapRegionCenters[LivingRoomID] + RoomIDMapRegionCenters[DiningRoomID]);
						if ((FPolygonAlg::JudgePointOnOrInPolygon(TempRegionPs, TempCenter)) || (FPolygonAlg::JudgePointOnOrInPolygon(DiningRoomPs, TempCenter)))
						{
							PanoramaWatchPoints.Add(TempRoomId, TempCenter);
							FVector2D TempDir = RoomIDMapRegionCenters[LivingRoomID] - TempCenter;
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						else
						{
							PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
							FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						TArray<FVector>DoorPoints;
						bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
						if (GetDoorSuccess)
						{
							RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
						}
					}
					else if ((!IFInterSect) && (!HasCommonPoints))
					{
						TArray<FVector>DoorPoints;
						bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
						if (!GetDoorSuccess)
						{
							PanoramaWatchPoints.Add(LivingRoomID, RoomIDMapRegionCenters[LivingRoomID]);
							FVector2D TempDir = -RoomIDMapRegionCenters[LivingRoomID];
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						else
						{
							int NumOfDoors = DoorPoints.Num() / 8;
							RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
							if (NumOfDoors == 1)
							{
								FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
								FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
								DirVec = DirVec.GetSafeNormal();
								DirVec = DirVec.GetRotated(90);
								FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
								FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
								FVector2D TempVec1 = DoorCenter2D + 80 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
								{
									PanoramaWatchPoints.Add(TempRoomId, TempVec1);
									FVector2D TempDir = RoomIDMapRegionCenters[LivingRoomID] - TempVec1;
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
								else
								{
									FVector2D TempWatchP = DoorCenter2D - 80 * DirVec;
									if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempWatchP))
									{
										PanoramaWatchPoints.Add(TempRoomId, TempWatchP);
										FVector2D TempDir = RoomIDMapRegionCenters[LivingRoomID] - TempWatchP;
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
									}
									else
									{
										PanoramaWatchPoints.Add(LivingRoomID, RoomIDMapRegionCenters[LivingRoomID]);
										FVector2D TempDir = -RoomIDMapRegionCenters[LivingRoomID];
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
									}

								}
							}
							else if (NumOfDoors >= 2)
							{
								FVector2D TempCenter = RegionCenters[RoomIndex];
								float MinDis = 0.0;
								int TargetDoorIndex = 0;
								for (int J = 0; J < NumOfDoors; ++J)
								{
									FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
									FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
									float TempDis = FVector2D::Distance(RoomIDMapRegionCenters[LivingRoomID], TempDoorCenter2D) +
										FVector2D::Distance(RoomIDMapRegionCenters[DiningRoomID], TempDoorCenter2D);
									if ((MinDis == 0.0) || (TempDis < MinDis))
									{
										MinDis = TempDis;
										TargetDoorIndex = J;
									}
								}

								FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
								FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
								DirVec = DirVec.GetSafeNormal();
								DirVec = DirVec.GetRotated(90);
								FVector DoorCenter3D = 0.25*(DoorPoints[0 + 8 * TargetDoorIndex] + DoorPoints[1 + 8 * TargetDoorIndex]
									+ DoorPoints[2 + 8 * TargetDoorIndex] + DoorPoints[3 + 8 * TargetDoorIndex]);
								FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
								FVector2D TempVec1 = DoorCenter2D + 80 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
								{
									PanoramaWatchPoints.Add(TempRoomId, TempVec1);
									FVector2D TempDir = RoomIDMapRegionCenters[LivingRoomID] - TempVec1;
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
								else
								{
									FVector2D TempWatchP = DoorCenter2D - 80 * DirVec;
									if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempWatchP))
									{
										PanoramaWatchPoints.Add(TempRoomId, TempWatchP);
										FVector2D TempDir = RoomIDMapRegionCenters[LivingRoomID] - (DoorCenter2D - 80 * DirVec);
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
									}
									else
									{
										PanoramaWatchPoints.Add(LivingRoomID, RoomIDMapRegionCenters[LivingRoomID]);
										FVector2D TempDir = -RoomIDMapRegionCenters[LivingRoomID];
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
									}

								}
							}
						}
					}
				}
				else if ((LivingRoomPs.Num() != 0) && (DiningRoomPs.Num() == 0))
				{
					TArray<FVector>DoorPoints;
					bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
					if (!GetDoorSuccess)
					{
						PanoramaWatchPoints.Add(LivingRoomID, RoomIDMapRegionCenters[LivingRoomID]);
						FVector2D TempDir = -RoomIDMapRegionCenters[LivingRoomID];
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}
					else
					{
						int NumOfDoors = DoorPoints.Num() / 8;
						RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
						if (NumOfDoors == 1)
						{
							FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
							FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
							DirVec = DirVec.GetSafeNormal();
							DirVec = DirVec.GetRotated(90);
							FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
							FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
							FVector2D TempVec1 = DoorCenter2D + 80 * DirVec;
							if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
							{
								PanoramaWatchPoints.Add(TempRoomId, TempVec1);
								FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
							}
							else
							{
								FVector2D TempP = DoorCenter2D - 80 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
								{
									PanoramaWatchPoints.Add(TempRoomId, TempP);
									FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - (DoorCenter2D - 80 * DirVec);
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
								else
								{
									PanoramaWatchPoints.Add(LivingRoomID, RoomIDMapRegionCenters[LivingRoomID]);
									FVector2D TempDir = -RoomIDMapRegionCenters[LivingRoomID];
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}

							}
						}
						else if (NumOfDoors >= 2)
						{
							FVector2D TempCenter = RegionCenters[RoomIndex];
							float MinDis = 0.0;
							int TargetDoorIndex = 0;
							for (int J = 0; J < NumOfDoors; ++J)
							{
								FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
								FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
								float TempDis = FVector2D::Distance(TempCenter, TempDoorCenter2D);
								if ((MinDis == 0.0) || (TempDis < MinDis))
								{
									MinDis = TempDis;
									TargetDoorIndex = J;
								}
							}

							FVector TempDirVec = DoorPoints[1 + 8 * TargetDoorIndex] - DoorPoints[0 + 8 * TargetDoorIndex];
							FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
							DirVec = DirVec.GetSafeNormal();
							DirVec = DirVec.GetRotated(90);
							FVector DoorCenter3D = 0.25*(DoorPoints[0 + 8 * TargetDoorIndex] + DoorPoints[1 + 8 * TargetDoorIndex]
								+ DoorPoints[2 + 8 * TargetDoorIndex] + DoorPoints[3 + 8 * TargetDoorIndex]);
							FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
							FVector2D TempVec1 = DoorCenter2D + 80 * DirVec;
							if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
							{
								PanoramaWatchPoints.Add(TempRoomId, TempVec1);
								FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);

							}
							else
							{
								FVector2D TempP = DoorCenter2D - 80 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
								{
									PanoramaWatchPoints.Add(TempRoomId, TempP);
									FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempP;
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
								else
								{
									PanoramaWatchPoints.Add(LivingRoomID, RoomIDMapRegionCenters[LivingRoomID]);
									FVector2D TempDir = -RoomIDMapRegionCenters[LivingRoomID];
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
							}
						}
					}
				}
			}
			else
			{
				PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
				FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
				TempDir = TempDir.GetSafeNormal();
				RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
			}
		}
		else if (TempRoomName == TEXT("餐厅"))
		{
			if (TempRoomId == DiningRoomID)
			{
				if ((LivingRoomPs.Num() != 0) && (DiningRoomPs.Num() != 0))
				{
					if ((IFInterSect) || (HasCommonPoints))
					{
						TArray<FVector>DoorPoints;
						FVector2D TempCenter = 0.5*(RoomIDMapRegionCenters[LivingRoomID] + RoomIDMapRegionCenters[DiningRoomID]);
						if ((FPolygonAlg::JudgePointOnOrInPolygon(TempRegionPs, TempCenter)) || (FPolygonAlg::JudgePointOnOrInPolygon(LivingRoomPs, TempCenter)))
						{
							PanoramaWatchPoints.Add(TempRoomId, TempCenter);
							FVector2D TempDir = RoomIDMapRegionCenters[DiningRoomID] - TempCenter;
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						else
						{
							PanoramaWatchPoints.Add(DiningRoomID, RoomIDMapRegionCenters[DiningRoomID]);
							FVector2D TempDir = -RoomIDMapRegionCenters[DiningRoomID];
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}

						bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
						if (GetDoorSuccess)
						{
							RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
						}
					}
					else if ((!IFInterSect) && (!HasCommonPoints))
					{
						TArray<FVector>DoorPoints;
						bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
						if (!GetDoorSuccess)
						{
							PanoramaWatchPoints.Add(DiningRoomID, RoomIDMapRegionCenters[DiningRoomID]);
							FVector2D TempDir = -RoomIDMapRegionCenters[DiningRoomID];
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						else
						{
							int NumOfDoors = DoorPoints.Num() / 8;
							RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
							if (NumOfDoors == 1)
							{
								FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
								FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
								DirVec = DirVec.GetSafeNormal();
								DirVec = DirVec.GetRotated(90);
								FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
								FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
								FVector2D TempVec1 = DoorCenter2D + 80 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
								{
									PanoramaWatchPoints.Add(TempRoomId, TempVec1);

									FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
								else
								{
									FVector2D TempP = DoorCenter2D - 80 * DirVec;
									if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
									{
										PanoramaWatchPoints.Add(TempRoomId, TempP);
										FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempP;
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
									}
									else
									{
										PanoramaWatchPoints.Add(DiningRoomID, RoomIDMapRegionCenters[DiningRoomID]);
										FVector2D TempDir = -RoomIDMapRegionCenters[DiningRoomID];
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
									}
								}
							}
							else if (NumOfDoors >= 2)
							{
								FVector2D TempCenter = RegionCenters[RoomIndex];
								float MinDis = 0.0;
								int TargetDoorIndex = 0;
								for (int J = 0; J < NumOfDoors; ++J)
								{
									FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
									FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
									float TempDis = FVector2D::Distance(RoomIDMapRegionCenters[LivingRoomID], TempDoorCenter2D) +
										FVector2D::Distance(RoomIDMapRegionCenters[DiningRoomID], TempDoorCenter2D);
									if ((MinDis == 0.0) || (TempDis < MinDis))
									{
										MinDis = TempDis;
										TargetDoorIndex = J;
									}
								}

								FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
								FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
								DirVec = DirVec.GetSafeNormal();
								DirVec = DirVec.GetRotated(90);
								FVector DoorCenter3D = 0.25*(DoorPoints[0 + 8 * TargetDoorIndex] + DoorPoints[1 + 8 * TargetDoorIndex]
									+ DoorPoints[2 + 8 * TargetDoorIndex] + DoorPoints[3 + 8 * TargetDoorIndex]);
								FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
								FVector2D TempVec1 = DoorCenter2D + 80 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
								{
									PanoramaWatchPoints.Add(TempRoomId, TempVec1);
									FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
								else
								{
									FVector2D TempP = DoorCenter2D - 80 * DirVec;
									if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
									{
										PanoramaWatchPoints.Add(TempRoomId, DoorCenter2D - 80 * DirVec);
										FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - (DoorCenter2D - 80 * DirVec);
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
									}
									else
									{
										PanoramaWatchPoints.Add(DiningRoomID, RoomIDMapRegionCenters[DiningRoomID]);
										FVector2D TempDir = -RoomIDMapRegionCenters[DiningRoomID];
										TempDir = TempDir.GetSafeNormal();
										RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
									}

								}
							}
						}
					}
				}
				else if ((LivingRoomPs.Num() == 0) && (DiningRoomPs.Num() != 0))
				{
					TArray<FVector>DoorPoints;
					bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
					if (!GetDoorSuccess)
					{
						PanoramaWatchPoints.Add(DiningRoomID, RoomIDMapRegionCenters[DiningRoomID]);
						FVector2D TempDir = -RoomIDMapRegionCenters[DiningRoomID];
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}
					else
					{
						int NumOfDoors = DoorPoints.Num() / 8;
						RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
						if (NumOfDoors == 1)
						{
							FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
							FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
							DirVec = DirVec.GetSafeNormal();
							DirVec = DirVec.GetRotated(90);
							FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
							FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
							FVector2D TempVec1 = DoorCenter2D + 80 * DirVec;
							if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
							{
								PanoramaWatchPoints.Add(TempRoomId, TempVec1);
								FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);

							}
							else
							{
								FVector2D TempP = DoorCenter2D - 80 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
								{
									PanoramaWatchPoints.Add(TempRoomId, TempP);
									FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempP;
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
								else
								{
									PanoramaWatchPoints.Add(DiningRoomID, RoomIDMapRegionCenters[DiningRoomID]);
									FVector2D TempDir = -RoomIDMapRegionCenters[DiningRoomID];
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}

							}
						}
						else if (NumOfDoors >= 2)
						{
							FVector2D TempCenter = RegionCenters[RoomIndex];
							float MinDis = 0.0;
							int TargetDoorIndex = 0;
							for (int J = 0; J < NumOfDoors; ++J)
							{
								FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
								FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
								float TempDis = FVector2D::Distance(TempCenter, TempDoorCenter2D);
								if ((MinDis == 0.0) || (TempDis < MinDis))
								{
									MinDis = TempDis;
									TargetDoorIndex = J;
								}
							}

							FVector TempDirVec = DoorPoints[1 + 8 * TargetDoorIndex] - DoorPoints[0 + 8 * TargetDoorIndex];
							FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
							DirVec = DirVec.GetSafeNormal();
							DirVec = DirVec.GetRotated(90);
							FVector DoorCenter3D = 0.25*(DoorPoints[0 + 8 * TargetDoorIndex] + DoorPoints[1 + 8 * TargetDoorIndex]
								+ DoorPoints[2 + 8 * TargetDoorIndex] + DoorPoints[3 + 8 * TargetDoorIndex]);
							FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
							FVector2D TempVec1 = DoorCenter2D + 80 * DirVec;
							if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
							{
								PanoramaWatchPoints.Add(TempRoomId, TempVec1);
								FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
							}
							else
							{
								FVector2D TempP = DoorCenter2D - 80 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
								{
									PanoramaWatchPoints.Add(TempRoomId, TempP);
									FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempP;
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
								else
								{
									PanoramaWatchPoints.Add(DiningRoomID, RoomIDMapRegionCenters[DiningRoomID]);
									FVector2D TempDir = -RoomIDMapRegionCenters[DiningRoomID];
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
							}
						}
					}
				}
			}
			else
			{
				PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
				FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
				TempDir = TempDir.GetSafeNormal();
				RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
			}
		}
		else if ((TempRoomName == TEXT("生活阳台")) || (TempRoomName == TEXT("休闲阳台")) || (TempRoomName == TEXT("卧室阳台")))
		{
			TArray<FVector>DoorPoints;
			bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
			if (!GetDoorSuccess)
			{
				PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
				FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
				TempDir = TempDir.GetSafeNormal();
				RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
			}
			else
			{
				int NumOfDoors = DoorPoints.Num() / 8;
				RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
				if (NumOfDoors == 1)
				{
					FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
					FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
					DirVec = DirVec.GetSafeNormal();
					DirVec = DirVec.GetRotated(90);
					FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
					FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
					FVector2D PCenterToDoorCenter = RoomIDMapRegionCenters[TempRoomId] - DoorCenter2D;
					float TempDotValue = FVector2D::DotProduct(PCenterToDoorCenter, DirVec);
					FVector2D TempNode = DoorCenter2D + TempDotValue * DirVec;

					if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempNode))
					{
						PanoramaWatchPoints.Add(TempRoomId, TempNode);
						if (TempDotValue > 0)
						{
							RoomIDMapWatchDirections.Add(TempRoomId, -DirVec);
						}
						else
						{
							RoomIDMapWatchDirections.Add(TempRoomId, DirVec);
						}
					}
					else
					{
						PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
						FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}
				}
				else if (NumOfDoors >= 2)
				{
					FVector2D TempCenter = RegionCenters[RoomIndex];
					float MinDis = 0.0;
					int TargetDoorIndex = 0;
					for (int J = 0; J < NumOfDoors; ++J)
					{
						FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
						FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
						float TempDis = FVector2D::Distance(TempCenter, TempDoorCenter2D);
						if ((MinDis == 0.0) || (TempDis < MinDis))
						{
							MinDis = TempDis;
							TargetDoorIndex = J;
						}
					}

					FVector TempDirVec = DoorPoints[1 + 8 * TargetDoorIndex] - DoorPoints[0 + 8 * TargetDoorIndex];
					FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
					DirVec = DirVec.GetSafeNormal();
					DirVec = DirVec.GetRotated(90);
					FVector DoorCenter3D = 0.25*(DoorPoints[0 + 8 * TargetDoorIndex] + DoorPoints[1 + 8 * TargetDoorIndex]
						+ DoorPoints[2 + 8 * TargetDoorIndex] + DoorPoints[3 + 8 * TargetDoorIndex]);
					FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);

					FVector2D PCenterToDoorCenter = RoomIDMapRegionCenters[TempRoomId] - DoorCenter2D;
					float TempDotValue = FVector2D::DotProduct(PCenterToDoorCenter, DirVec);
					FVector2D TempNode = DoorCenter2D + TempDotValue * DirVec;

					if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempNode))
					{
						PanoramaWatchPoints.Add(TempRoomId, TempNode);
						if (TempDotValue > 0)
						{
							RoomIDMapWatchDirections.Add(TempRoomId, -DirVec);
						}
						else
						{
							RoomIDMapWatchDirections.Add(TempRoomId, DirVec);
						}
					}
					else
					{
						PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
						FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}

				}
			}
		}
		else if ((TempRoomName == TEXT("主卫")) || (TempRoomName == TEXT("客卫")) || (TempRoomName == TEXT("卫生间")))
		{
			TArray<FVector2D> UpdateRegionPs;
			FPolygonAlg::MergeCollinearPoints(TempRegionPs, UpdateRegionPs);

			bool FindWall = false;
			int TargetIndex = 0;
			for (int _CurIndex = 0; _CurIndex < IndexMapWallCenter.Num(); ++_CurIndex)
			{
				bool JudgeIfInRegion = FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, IndexMapWallCenter[_CurIndex]);
				if (JudgeIfInRegion)
				{
					FindWall = true;
					TargetIndex = _CurIndex;
					break;
				}
			}
			if (FindWall)
			{
				TArray<FVector2D> ToiletWatchPoints;
				bool LocateSecondToiletSuccess = FPolygonAlg::LocateCentersOfSecondToilet(UpdateRegionPs, IndexMapWalls2D[TargetIndex], ToiletWatchPoints);
				if (LocateSecondToiletSuccess)
				{
					FVector2D DirOfWatchPoint = ToiletWatchPoints[0] - IndexMapWallCenter[TargetIndex];
					DirOfWatchPoint = DirOfWatchPoint.GetSafeNormal();
					PanoramaWatchPoints.Add(TempRoomId, ToiletWatchPoints[0]);
					RoomIDMapWatchDirections.Add(TempRoomId, DirOfWatchPoint);
				}
				else
				{
					TArray<FVector2D> TempWallPoints = IndexMapWalls2D[TargetIndex];
					FVector2D TempSide1 = TempWallPoints[1] - TempWallPoints[0];
					FVector2D TempSide2 = TempWallPoints[2] - TempWallPoints[1];
					float LengthOfSide1 = TempSide1.Size();
					float LengthOfSide2 = TempSide2.Size();
					if (LengthOfSide1 > LengthOfSide2)
					{
						FVector2D TempDir = TempSide1.GetSafeNormal();
						FVector2D TempRotatedDir = TempDir.GetRotated(90);
						FVector2D TempExtendP = IndexMapWallCenter[TargetIndex] + TempRotatedDir * 35;
						PanoramaWatchPoints.Add(TempRoomId, TempExtendP);
						RoomIDMapWatchDirections.Add(TempRoomId, TempRotatedDir);
					}
					else
					{
						FVector2D TempDir = TempSide2.GetSafeNormal();
						FVector2D TempRotatedDir = TempDir.GetRotated(90);
						FVector2D TempExtendP = IndexMapWallCenter[TargetIndex] + TempRotatedDir * 35;
						PanoramaWatchPoints.Add(TempRoomId, TempExtendP);
						RoomIDMapWatchDirections.Add(TempRoomId, TempRotatedDir);
					}
				}
				TArray<FVector>DoorPoints;
				bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
				if (GetDoorSuccess)
				{
					int TempNumOfDoors = DoorPoints.Num() / 8;
					if (TempNumOfDoors > 0)
					{
						RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
					}
				}
			}
			else
			{
				if (UpdateRegionPs.Num() <= 6)
				{
					TArray<FVector>DoorPoints;
					bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
					if (!GetDoorSuccess)
					{
						PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
						FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}
					else
					{
						int NumOfDoors = DoorPoints.Num() / 8;
						RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
						if (NumOfDoors == 1)
						{
							FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
							FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
							DirVec = DirVec.GetSafeNormal();
							DirVec = DirVec.GetRotated(90);
							FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
							FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
							FVector2D TempVec1 = DoorCenter2D + 50 * DirVec;
							if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, TempVec1))
							{
								PanoramaWatchPoints.Add(TempRoomId, TempVec1);
								FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
							}
							else
							{
								FVector2D TempP = DoorCenter2D - 50 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, TempP))
								{
									PanoramaWatchPoints.Add(TempRoomId, TempP);
									FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempP;
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}
								else
								{
									PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
									FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
									TempDir = TempDir.GetSafeNormal();
									RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
								}

							}
						}
						else if (NumOfDoors >= 2)
						{
							FVector2D TempCenter = RegionCenters[RoomIndex];
							if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, TempCenter))
							{
								PanoramaWatchPoints.Add(TempRoomId, TempCenter);
								float MinDis = 0.0;
								int TargetDoorIndex = 0;
								for (int J = 0; J < NumOfDoors; ++J)
								{
									FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
									FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
									float TempDis = FVector2D::Distance(TempCenter, TempDoorCenter2D);
									if ((MinDis == 0.0) || (TempDis < MinDis))
									{
										MinDis = TempDis;
										TargetDoorIndex = J;
									}
								}

								FVector TempDirVec = DoorPoints[1 + 8 * TargetDoorIndex] - DoorPoints[0 + 8 * TargetDoorIndex];
								FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
								DirVec = DirVec.GetSafeNormal();
								DirVec = DirVec.GetRotated(90);
								FVector DoorCenter3D = 0.25*(DoorPoints[0 + 8 * TargetDoorIndex] + DoorPoints[1 + 8 * TargetDoorIndex] + DoorPoints[2 + 8 * TargetDoorIndex]
									+ DoorPoints[3 + 8 * TargetDoorIndex]);
								FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
								FVector2D TestVec1 = TempCenter - DoorCenter2D;
								float TestValue1 = FVector2D::DotProduct(TestVec1, DirVec);
								if (TestValue1 > 0)
								{
									RoomIDMapWatchDirections.Add(TempRoomId, DirVec);

								}
								else
								{
									RoomIDMapWatchDirections.Add(TempRoomId, -DirVec);
								}
							}
							else
							{
								PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
								FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
							}
						}
					}
				}
				else if (UpdateRegionPs.Num() >= 7)
				{
					TArray<FVector>DoorPoints;
					bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
					if (!GetDoorSuccess)
					{
						PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
						FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}
					else
					{
						int NumOfDoors = DoorPoints.Num() / 8;
						RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
						if (NumOfDoors == 1)
						{
							FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
							FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
							DirVec = DirVec.GetSafeNormal();
							DirVec = DirVec.GetRotated(90);
							FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
							FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
							PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
							FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - DoorCenter2D;
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						else if (NumOfDoors >= 2)
						{
							FVector2D TempCenter = RegionCenters[RoomIndex];
							float MinDis = 0.0;
							int TargetDoorIndex = 0;
							for (int J = 0; J < NumOfDoors; ++J)
							{
								FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
								FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
								float TempDis = FVector2D::Distance(TempCenter, TempDoorCenter2D);
								if ((MinDis == 0.0) || (TempDis < MinDis))
								{
									MinDis = TempDis;
									TargetDoorIndex = J;
								}
							}

							FVector TempDirVec = DoorPoints[1 + 8 * TargetDoorIndex] - DoorPoints[0 + 8 * TargetDoorIndex];
							FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
							DirVec = DirVec.GetSafeNormal();
							DirVec = DirVec.GetRotated(90);
							FVector DoorCenter3D = 0.25*(DoorPoints[0 + 8 * TargetDoorIndex] + DoorPoints[1 + 8 * TargetDoorIndex] + DoorPoints[2 + 8 * TargetDoorIndex]
								+ DoorPoints[3 + 8 * TargetDoorIndex]);
							FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
							PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
							FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - DoorCenter2D;
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
					}
				}
			}
		}
		else if (TempRoomName == TEXT("厨房"))
		{
			if ((!IsOpenKitchen1) && (!IsOpenKitchen2))
			{
				TArray<FVector>DoorPoints;
				bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
				if (!GetDoorSuccess)
				{
					PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
					FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
					TempDir = TempDir.GetSafeNormal();
					RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
				}
				else
				{
					int NumOfDoors = DoorPoints.Num() / 8;
					RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
					if (NumOfDoors == 1)
					{
						FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
						FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
						DirVec = DirVec.GetSafeNormal();
						DirVec = DirVec.GetRotated(90);
						FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
						FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
						FVector2D TempVec1 = DoorCenter2D + 35 * DirVec;
						if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
						{
							PanoramaWatchPoints.Add(TempRoomId, TempVec1);
							FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						else
						{
							FVector2D TempP = DoorCenter2D - 35 * DirVec;
							if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
							{
								PanoramaWatchPoints.Add(TempRoomId, TempP);
								FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempP;
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
							}
							else
							{
								PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
								FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
							}

						}
					}
					else if (NumOfDoors >= 2)
					{
						FVector2D TempCenter = RegionCenters[RoomIndex];
						float MinDis = 0.0;
						int TargetDoorIndex = 0;
						for (int J = 0; J < NumOfDoors; ++J)
						{
							FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
							FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
							float TempDis = FVector2D::Distance(TempCenter, TempDoorCenter2D);
							if ((MinDis == 0.0) || (TempDis < MinDis))
							{
								MinDis = TempDis;
								TargetDoorIndex = J;
							}
						}

						FVector TempDirVec = DoorPoints[1 + 8 * TargetDoorIndex] - DoorPoints[0 + 8 * TargetDoorIndex];
						FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
						DirVec = DirVec.GetSafeNormal();
						DirVec = DirVec.GetRotated(90);
						FVector DoorCenter3D = 0.25*(DoorPoints[0 + 8 * TargetDoorIndex] + DoorPoints[1 + 8 * TargetDoorIndex]
							+ DoorPoints[2 + 8 * TargetDoorIndex] + DoorPoints[3 + 8 * TargetDoorIndex]);
						FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);

						FVector2D TempVec1 = DoorCenter2D + 35 * DirVec;
						if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
						{
							PanoramaWatchPoints.Add(TempRoomId, TempVec1);
							FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						else
						{
							FVector2D TempP = DoorCenter2D - 35 * DirVec;
							if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
							{
								PanoramaWatchPoints.Add(TempRoomId, TempP);
								FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempP;
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
							}
							else
							{
								PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
								FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
								TempDir = TempDir.GetSafeNormal();
								RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
							}
						}
					}
				}
			}
			else if ((IsOpenKitchen1) || (IsOpenKitchen2))
			{
				TArray<FVector>DoorPoints;
				PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
				FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
				TempDir = TempDir.GetSafeNormal();
				RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
				bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
				if (GetDoorSuccess)
				{
					RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
				}
			}
		}
		else if (TempRoomName == TEXT("储藏间"))
		{
			TArray<FVector>DoorPoints;
			bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
			if (!GetDoorSuccess)
			{
				PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
				FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
				TempDir = TempDir.GetSafeNormal();
				RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
			}
			else
			{
				int NumOfDoors = DoorPoints.Num() / 8;
				RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
				if (NumOfDoors == 1)
				{
					FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
					FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
					DirVec = DirVec.GetSafeNormal();
					DirVec = DirVec.GetRotated(90);
					FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
					FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
					FVector2D TempVec1 = DoorCenter2D + 20 * DirVec;
					if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
					{
						PanoramaWatchPoints.Add(TempRoomId, TempVec1);
						FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}
					else
					{
						FVector2D TempP = DoorCenter2D - 20 * DirVec;
						if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
						{
							PanoramaWatchPoints.Add(TempRoomId, TempP);
							FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempP;
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						else
						{
							PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
							FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}

					}
				}
				else if (NumOfDoors >= 2)
				{
					FVector2D TempCenter = RegionCenters[RoomIndex];
					float MaxDis = 0.0;
					int TargetDoorIndex = 0;
					for (int J = 0; J < NumOfDoors; ++J)
					{
						FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
						FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
						float TempDis = FVector2D::Distance(TempCenter, TempDoorCenter2D);
						if ((MaxDis == 0.0) || (TempDis > MaxDis))
						{
							MaxDis = TempDis;
							TargetDoorIndex = J;
						}
					}

					FVector TempDirVec = DoorPoints[1 + 8 * TargetDoorIndex] - DoorPoints[0 + 8 * TargetDoorIndex];
					FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
					DirVec = DirVec.GetSafeNormal();
					DirVec = DirVec.GetRotated(90);
					FVector DoorCenter3D = 0.25*(DoorPoints[0 + 8 * TargetDoorIndex] + DoorPoints[1 + 8 * TargetDoorIndex] +
						DoorPoints[2 + 8 * TargetDoorIndex] + DoorPoints[3 + 8 * TargetDoorIndex]);
					FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
					FVector2D TempVec1 = DoorCenter2D + 20 * DirVec;
					if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
					{
						PanoramaWatchPoints.Add(TempRoomId, TempVec1);
						FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}
					else
					{
						FVector2D TempP = DoorCenter2D - 20 * DirVec;
						if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
						{
							PanoramaWatchPoints.Add(TempRoomId, TempP);
							FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempP;
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						else
						{
							PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
							FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}

					}
				}
			}
		}
		else if ((TempRoomName == TEXT("衣帽间")) || (TempRoomName == TEXT("茶室")))
		{
			TArray<FVector>DoorPoints;
			bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomId, DoorPoints);
			if (!GetDoorSuccess)
			{
				PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
				FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
				TempDir = TempDir.GetSafeNormal();
				RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
			}
			else
			{
				int NumOfDoors = DoorPoints.Num() / 8;
				RoomIDMapHoleData.Add(TempRoomId, DoorPoints);
				if (NumOfDoors == 1)
				{
					FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
					FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
					DirVec = DirVec.GetSafeNormal();
					DirVec = DirVec.GetRotated(90);
					FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
					FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
					FVector2D TempVec1 = DoorCenter2D + 35 * DirVec;
					if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
					{
						PanoramaWatchPoints.Add(TempRoomId, TempVec1);
						FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}
					else
					{
						FVector2D TempP = DoorCenter2D - 35 * DirVec;
						if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
						{
							PanoramaWatchPoints.Add(TempRoomId, TempP);
							FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempP;
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						else
						{
							PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
							FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}

					}
				}
				else if (NumOfDoors >= 2)
				{
					FVector2D TempCenter = RegionCenters[RoomIndex];
					float MaxDis = 0.0;
					int TargetDoorIndex = 0;
					for (int J = 0; J < NumOfDoors; ++J)
					{
						FVector TempDoorCenter3D = 0.25*(DoorPoints[0 + J * 8] + DoorPoints[1 + 8 * J] + DoorPoints[2 + 8 * J] + DoorPoints[3 + 8 * J]);
						FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D.X, TempDoorCenter3D.Y);
						float TempDis = FVector2D::Distance(TempCenter, TempDoorCenter2D);
						if ((MaxDis == 0.0) || (TempDis > MaxDis))
						{
							MaxDis = TempDis;
							TargetDoorIndex = J;
						}
					}

					FVector TempDirVec = DoorPoints[1 + 8 * TargetDoorIndex] - DoorPoints[0 + 8 * TargetDoorIndex];
					FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
					DirVec = DirVec.GetSafeNormal();
					DirVec = DirVec.GetRotated(90);
					FVector DoorCenter3D = 0.25*(DoorPoints[0 + 8 * TargetDoorIndex] + DoorPoints[1 + 8 * TargetDoorIndex] +
						DoorPoints[2 + 8 * TargetDoorIndex] + DoorPoints[3 + 8 * TargetDoorIndex]);
					FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
					FVector2D TempVec1 = DoorCenter2D + 35 * DirVec;
					if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempVec1))
					{
						PanoramaWatchPoints.Add(TempRoomId, TempVec1);
						FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempVec1;
						TempDir = TempDir.GetSafeNormal();
						RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
					}
					else
					{
						FVector2D TempP = DoorCenter2D - 35 * DirVec;
						if (FPolygonAlg::JudgePointInPolygon(TempRegionPs, TempP))
						{
							PanoramaWatchPoints.Add(TempRoomId, TempP);
							FVector2D TempDir = RoomIDMapRegionCenters[TempRoomId] - TempP;
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}
						else
						{
							PanoramaWatchPoints.Add(TempRoomId, RoomIDMapRegionCenters[TempRoomId]);
							FVector2D TempDir = -RoomIDMapRegionCenters[TempRoomId];
							TempDir = TempDir.GetSafeNormal();
							RoomIDMapWatchDirections.Add(TempRoomId, TempDir);
						}

					}
				}
			}
		}
	}
	//////////////////修正客厅以及餐厅观察点///////////////////////////////
	if ((IFInterSect) || (HasCommonPoints))
	{
		FVector2D LivingPickP = RoomIDMapRegionCenters[LivingRoomID];
		FVector2D DiningPickP = RoomIDMapRegionCenters[DiningRoomID];
		FVector2D UpdateFirstPoint, UpdateSecondPoint, UpdateWatchPoint;
		bool IsAdjusted = FPolygonAlg::AdjustWatchAndPickPoints(LivingPickP, DiningPickP, LivingRoomPs, DiningRoomPs, UpdateFirstPoint, UpdateSecondPoint, UpdateWatchPoint);
		if (IsAdjusted)
		{
			PanoramaWatchPoints[LivingRoomID] = UpdateWatchPoint;
			PanoramaWatchPoints[DiningRoomID] = UpdateWatchPoint;
			RoomIDMapRegionCenters[LivingRoomID] = UpdateFirstPoint;
			RoomIDMapRegionCenters[DiningRoomID] = UpdateSecondPoint;
			FVector2D TempDir = UpdateWatchPoint - UpdateFirstPoint;
			TempDir = TempDir.GetSafeNormal();
			RoomIDMapWatchDirections[LivingRoomID] = -TempDir;
			RoomIDMapWatchDirections[DiningRoomID] = TempDir;
		}
	}
	/////////////////////修正第三厅与第四厅的观察点////////////////////////
	if ((IFInterSectOfThirdAndFourth) || (HasCommonPointsOfThirdAndFourth))
	{
		FVector2D ThirdPickP = RoomIDMapRegionCenters[ThirdDingingRoomID];
		FVector2D FourthPickP = RoomIDMapRegionCenters[FourthDiningRoomID];
		FVector2D UpdateFirstPoint, UpdateSecondPoint, UpdateWatchPoint;
		bool IsChangedThirdAndFourth = FPolygonAlg::AdjustWatchAndPickPoints(ThirdPickP, FourthPickP, ThirdDinging, FourthDining, UpdateFirstPoint, UpdateSecondPoint, UpdateWatchPoint);
		if (IsChangedThirdAndFourth)
		{
			PanoramaWatchPoints[ThirdDingingRoomID] = UpdateWatchPoint;
			PanoramaWatchPoints[FourthDiningRoomID] = UpdateWatchPoint;
			RoomIDMapRegionCenters[ThirdDingingRoomID] = UpdateFirstPoint;
			RoomIDMapRegionCenters[FourthDiningRoomID] = UpdateSecondPoint;
			FVector2D TempDir = UpdateWatchPoint - UpdateFirstPoint;
			TempDir = TempDir.GetSafeNormal();
			RoomIDMapWatchDirections[ThirdDingingRoomID] = -TempDir;
			RoomIDMapWatchDirections[FourthDiningRoomID] = TempDir;
		}
	}

	for (int I = 0; I < AllRoomIDs.Num(); ++I)
	{
		if (SpecialRoomIDs.Contains(AllRoomIDs[I]))
		{
			WatchPoints.Add(AllRoomIDs[I], FVector(PanoramaWatchPoints[AllRoomIDs[I]], WatchPointHeight - 10));
		}
		else
		{
			WatchPoints.Add(AllRoomIDs[I], FVector(PanoramaWatchPoints[AllRoomIDs[I]], WatchPointHeight));
		}

		LookDirs.Add(AllRoomIDs[I], FVector(RoomIDMapWatchDirections[AllRoomIDs[I]], 0));
	}
	return true;
}

bool UWriteMeshObj_FunctionLibrary::FromJsonToWriteFullObjFile(UObject* WorldContextObject, UVaRestJsonObject* InJson, const FString FileName,
	const FString FilePath)
{
	TArray<FVector> AreaBoundaryPs;
	TArray<int> AreaPIndexVec;
	TArray<TArray<FVector>> WallPoints;
	TArray<FString> AreaNames;
	if ((InJson == nullptr) || (*FilePath == NULL) || (*FileName == NULL))
	{
		return false;
	}


	TArray<UVaRestJsonObject*> RoomJsonObj = InJson->GetObjectArrayField("roomList");
	for (int Index = 0; Index < RoomJsonObj.Num(); Index++)
	{
		TArray<UVaRestJsonObject*> AreaCoorJson = RoomJsonObj[Index]->GetObjectArrayField("areas");
		int NumCount = 0;
		for (int AreaIndex = 0; AreaIndex < AreaCoorJson.Num(); AreaIndex++)
		{
			float TempX = AreaCoorJson[AreaIndex]->GetNumberField("x");
			float TempY = AreaCoorJson[AreaIndex]->GetNumberField("y");
			AreaBoundaryPs.Add(FVector(TempX, TempY, 0));
			NumCount++;
			FString TempRoomNameString = RoomJsonObj[Index]->GetStringField("roomName");
			AreaNames.Add(TempRoomNameString);

		}
		AreaPIndexVec.Add(NumCount);
	}

	TArray<UVaRestJsonObject*> WallJsonObj = InJson->GetObjectArrayField("walls");
	for (int Index = 0; Index < WallJsonObj.Num(); Index++)
	{
		TArray<UVaRestJsonObject*> EachWallRegion = WallJsonObj[Index]->GetObjectArrayField("wallPoints");
		TArray<FVector> TempWall;
		for (int WallIndex = 0; WallIndex < EachWallRegion.Num(); WallIndex++)
		{
			float TempX = EachWallRegion[WallIndex]->GetNumberField("x");
			float TempY = EachWallRegion[WallIndex]->GetNumberField("y");
			float TempZ = EachWallRegion[WallIndex]->GetNumberField("z");
			//WallPoints.Add(FVector(TempX, TempY, TempZ));
			TempWall.Add(FVector(TempX, TempY, TempZ));
		}
		WallPoints.Add(TempWall);
	}

	float WallHeight = 0.0;
	for (int Pindex = 0; Pindex < WallPoints.Num(); Pindex++)
	{
		for (int J = 0; J < WallPoints[Pindex].Num(); ++J)
		{
			if (WallPoints[Pindex][J].Z != 0)
			{
				WallHeight = WallPoints[Pindex][J].Z;
				break;
			}
		}

	}


	//int SolutionID = InJson->GetNumberField("solutionId");
	//FString FileName = FString::FromInt(SolutionID);
	FString ObjFileName = FilePath + FileName + ".obj";
	std::ofstream OutFile(*ObjFileName);
	for (int Num = 0; Num < WallPoints.Num(); ++Num)
	{
		for (int Index = 0; Index < WallPoints[Num].Num(); Index++)
		{
			OutFile << "v" << " " << WallPoints[Num][Index].X << " " << WallPoints[Num][Index].Y << " " << WallPoints[Num][Index].Z << std::endl;

		}
	}

	//const int EachWallNumV = 12;

	for (int NumWall = 0; NumWall < WallPoints.Num(); NumWall++)
	{
		for (int Forder = 0; Forder < 8; Forder++)
		{
			if (Forder == 0)
			{
				OutFile << "f" << " " << 1 + NumWall * 12 << " " << 2 + NumWall * 12 << " " << 3 + NumWall * 12 << " " << 4 + NumWall * 12 <<
					" " << 5 + NumWall * 12 << " " << 6 + NumWall * 12 << std::endl;
			}
			else if (Forder == 1)
			{
				OutFile << "f" << " " << 12 + NumWall * 12 << " " << 11 + NumWall * 12 << " " << 10 + NumWall * 12 << " " << 9 + NumWall * 12 <<
					" " << 8 + NumWall * 12 << "  " << 7 + NumWall * 12 << std::endl;
			}
			else if (Forder == 2)
			{
				OutFile << "f" << " " << 9 + NumWall * 12 << " " << 10 + NumWall * 12 << " " << 4 + NumWall * 12 << " " << 3 + NumWall * 12 << std::endl;
			}
			else if (Forder == 3)
			{
				OutFile << "f" << " " << 12 + NumWall * 12 << " " << 7 + NumWall * 12 << " " << 1 + NumWall * 12 << " " << 6 + NumWall * 12 << std::endl;
			}
			else if (Forder == 4)
			{
				OutFile << "f" << " " << 2 + NumWall * 12 << " " << 8 + NumWall * 12 << " " << 9 + NumWall * 12 << " " << 3 + NumWall * 12 << std::endl;
			}
			else if (Forder == 5)
			{
				OutFile << "f" << " " << 2 + NumWall * 12 << " " << 1 + NumWall * 12 << " " << 7 + NumWall * 12 << " " << 8 + NumWall * 12 << std::endl;
			}
			else if (Forder == 6)
			{
				OutFile << "f" << " " << 5 + NumWall * 12 << " " << 4 + NumWall * 12 << " " << 10 + NumWall * 12 << " " << 11 + NumWall * 12 << std::endl;
			}
			else if (Forder == 7)
			{
				OutFile << "f" << " " << 6 + NumWall * 12 << " " << 5 + NumWall * 12 << " " << 11 + NumWall * 12 << " " << 12 + NumWall * 12 << std::endl;
			}
		}
	}
	int NumWallPs = 12 * WallPoints.Num();
	for (int Index = 0; Index < AreaBoundaryPs.Num(); Index++)
	{
		OutFile << "v" << " " << AreaBoundaryPs[Index].X << " " << AreaBoundaryPs[Index].Y << " " << 0 << std::endl;
	}
	int NumCount = 0;
	int NumArray = AreaPIndexVec.Num();
	for (int FaceId = 1; FaceId <= NumArray; FaceId++)
	{
		OutFile << "f";

		if (FaceId == 1)
		{
			float VecX1 = AreaBoundaryPs[NumCount + 1].X - AreaBoundaryPs[NumCount].X;
			float VecY1 = AreaBoundaryPs[NumCount + 1].Y - AreaBoundaryPs[NumCount].Y;
			float VecZ1 = AreaBoundaryPs[NumCount + 1].Z - AreaBoundaryPs[NumCount].Z;

			float VecX2 = AreaBoundaryPs[NumCount + AreaPIndexVec[FaceId - 1] - 1].X - AreaBoundaryPs[NumCount].X;
			float VecY2 = AreaBoundaryPs[NumCount + AreaPIndexVec[FaceId - 1] - 1].Y - AreaBoundaryPs[NumCount].Y;
			float VecZ2 = AreaBoundaryPs[NumCount + AreaPIndexVec[FaceId - 1] - 1].Z - AreaBoundaryPs[NumCount].Z;

			float CrossResX = VecY1 * VecZ2 - VecZ1 * VecY2;
			float CrossResY = VecZ1 * VecX2 - VecX1 * VecZ2;
			float CrossResZ = VecX1 * VecY2 - VecY1 * VecX2;
			if (CrossResZ < 0)
			{
				for (int Forder = AreaPIndexVec[FaceId - 1]; Forder >= 1; Forder--)
				{
					OutFile << " " << NumWallPs + Forder << " ";
				}
				int NumVec = AreaPIndexVec[FaceId - 1];
				for (int Jindex = 0; Jindex < NumVec / 2; Jindex++)
				{
					FVector TempVec = AreaBoundaryPs[Jindex];
					AreaBoundaryPs[Jindex] = AreaBoundaryPs[NumVec - 1 - Jindex];
					AreaBoundaryPs[NumVec - 1 - Jindex] = TempVec;
				}
			}
			else
			{
				for (int Forder = 1; Forder <= AreaPIndexVec[FaceId - 1]; Forder++)
				{

					OutFile << " " << NumWallPs + Forder << " ";
				}
			}

			NumCount = AreaPIndexVec[0];
		}
		else if (FaceId != 1)
		{
			float VecX1 = AreaBoundaryPs[NumCount + 1].X - AreaBoundaryPs[NumCount].X;
			float VecY1 = AreaBoundaryPs[NumCount + 1].Y - AreaBoundaryPs[NumCount].Y;
			float VecZ1 = AreaBoundaryPs[NumCount + 1].Z - AreaBoundaryPs[NumCount].Z;

			float VecX2 = AreaBoundaryPs[NumCount + AreaPIndexVec[FaceId - 1] - 1].X - AreaBoundaryPs[NumCount].X;
			float VecY2 = AreaBoundaryPs[NumCount + AreaPIndexVec[FaceId - 1] - 1].Y - AreaBoundaryPs[NumCount].Y;
			float VecZ2 = AreaBoundaryPs[NumCount + AreaPIndexVec[FaceId - 1] - 1].Z - AreaBoundaryPs[NumCount].Z;

			float CrossResX = VecY1 * VecZ2 - VecZ1 * VecY2;
			float CrossResY = VecZ1 * VecX2 - VecX1 * VecZ2;
			float CrossResZ = VecX1 * VecY2 - VecY1 * VecX2;
			if (CrossResZ < 0)
			{
				for (int Forder = AreaPIndexVec[FaceId - 1]; Forder >= 1; Forder--)
				{
					OutFile << " " << NumWallPs + NumCount + Forder << " ";
				}
				int NumVec = AreaPIndexVec[FaceId - 1];
				for (int Jindex = 0; Jindex < NumVec / 2; Jindex++)
				{
					FVector TempVec = AreaBoundaryPs[NumCount + Jindex];
					AreaBoundaryPs[NumCount + Jindex] = AreaBoundaryPs[NumCount + NumVec - 1 - Jindex];
					AreaBoundaryPs[NumCount + NumVec - 1 - Jindex] = TempVec;
				}
			}
			else
			{
				for (int Forder = 1; Forder <= AreaPIndexVec[FaceId - 1]; Forder++)
				{
					OutFile << " " << NumWallPs + NumCount + Forder << " ";
				}
			}

			NumCount = NumCount + AreaPIndexVec[FaceId - 1];
		}

		OutFile << std::endl;
	}

	OutFile.close();

	return true;





}


bool  UWriteMeshObj_FunctionLibrary::CreateSegmentsJson(UObject* WorldContextObject, TArray<FVector2D>LivingRoomPs, int LivingRoomID,
	TArray<FVector>HoleDatas, UVaRestJsonObject* &SegmentsJson)
{
	if (!SegmentsJson)
		SegmentsJson = UVaRestJsonObject::ConstructJsonObject(WorldContextObject);
	if (LivingRoomPs.Num() == 0)
	{
		return false;
	}
	else
	{
		TArray<FVector2D>EndPoints, MapPoints, MaxRegion;
		bool GetSuccess = FPolygonAlg::GetMaxAreaEndPoints(LivingRoomPs, EndPoints, MapPoints, MaxRegion);
		if (GetSuccess)
		{
			TArray<FVector> LivingRoomDoorPs = HoleDatas;
			TArray<int> CollectDoorIndexs;
			TArray<FVector> ExceptDoorPs;
			int NumOfLivingDoors = LivingRoomDoorPs.Num() / 8;
			if (NumOfLivingDoors > 0)
			{
				for (int DoorIndex = 0; DoorIndex < NumOfLivingDoors; ++DoorIndex)
				{
					FVector TempDoorVec = LivingRoomDoorPs[1 + 8 * DoorIndex] - LivingRoomDoorPs[8 * DoorIndex];
					FVector2D TempVec2D = FVector2D(TempDoorVec.X, TempDoorVec.Y);
					TempVec2D = TempVec2D.GetSafeNormal();
					FVector2D TempRotatedVec = TempVec2D.GetRotated(90);
					FVector DoorCenter3D = 0.25*(LivingRoomDoorPs[0 + 8 * DoorIndex] + LivingRoomDoorPs[1 + 8 * DoorIndex]
						+ LivingRoomDoorPs[2 + 8 * DoorIndex] + LivingRoomDoorPs[3 + 8 * DoorIndex]);
					FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
					FVector2D TempVec1 = DoorCenter2D + 30 * TempRotatedVec;
					FVector2D TempVec2 = DoorCenter2D - 30 * TempRotatedVec;
					if ((FPolygonAlg::JudgePointInPolygon(MaxRegion, TempVec1)) || (FPolygonAlg::JudgePointInPolygon(MaxRegion, TempVec2)))
					{
						CollectDoorIndexs.Add(DoorIndex);
					}
					else
					{
						for (int J = 0; J < 8; ++J)
						{
							ExceptDoorPs.Add(LivingRoomDoorPs[J + 8 * DoorIndex]);
						}
					}
				}
				TArray<FVector2D> PolygonInterSectPs;
				bool GetInterSuccess = FPolygonAlg::GetWayInterSectPs(LivingRoomPs, EndPoints, MapPoints, PolygonInterSectPs);
				if (GetInterSuccess)
				{
					TMap<int, int> DoorIndexMapSegIndex;
					bool DivideSuccess = FPolygonAlg::DivideDoorPointsToGroups(ExceptDoorPs, EndPoints, PolygonInterSectPs, DoorIndexMapSegIndex);
					if (DivideSuccess)
					{
						TMap<int, TArray<TArray<FVector>>> AllSeperatedDoorPs;
						TArray<FVector2D> TotalSegPs;
						for (int NumSeg = 0; NumSeg < EndPoints.Num(); ++NumSeg)
						{
							TArray<TArray<FVector>> TempAttr;

							TotalSegPs.Add(EndPoints[NumSeg]);
							TotalSegPs.Add(PolygonInterSectPs[NumSeg]);
							for (int NumOfTempDoor = 0; NumOfTempDoor < ExceptDoorPs.Num() / 8; ++NumOfTempDoor)
							{
								if (DoorIndexMapSegIndex.Contains(NumOfTempDoor))
								{
									if (DoorIndexMapSegIndex[NumOfTempDoor] == NumSeg)
									{
										TArray<FVector> ReCollectDoorPs;
										for (int Index = 0; Index < 8; ++Index)
										{
											ReCollectDoorPs.Add(ExceptDoorPs[Index + 8 * NumOfTempDoor]);
										}
										TempAttr.Add(ReCollectDoorPs);
									}
								}
							}
							AllSeperatedDoorPs.Add(NumSeg, TempAttr);
						}


						TArray<UVaRestJsonObject*> SegmentsObjAttr;
						for (int I = 0; I < TotalSegPs.Num() / 2; ++I)
						{
							UVaRestJsonObject* TempSegment = NewObject<UVaRestJsonObject>();
							TArray<UVaRestJsonObject*> EachSegObjAttr;
							for (int J = 0; J < 2; ++J)
							{
								UVaRestJsonObject* TempSegPoint = NewObject<UVaRestJsonObject>();
								TempSegPoint->SetNumberField("x", TotalSegPs[2 * I + J].X);
								TempSegPoint->SetNumberField("y", TotalSegPs[2 * I + J].Y);
								EachSegObjAttr.Add(TempSegPoint);
							}
							TempSegment->SetObjectArrayField("segpoints", EachSegObjAttr);

							TArray<TArray<FVector>> TempHoleSet = AllSeperatedDoorPs[I];
							TArray<UVaRestJsonObject*> HolesAttr;
							for (int HoleIndex = 0; HoleIndex < TempHoleSet.Num(); ++HoleIndex)
							{
								UVaRestJsonObject* TempHole = NewObject<UVaRestJsonObject>();
								TArray<UVaRestJsonObject*> EachHolePointAttr;
								for (int PIndex = 0; PIndex < TempHoleSet[HoleIndex].Num(); ++PIndex)
								{
									UVaRestJsonObject* TempHoleP = NewObject<UVaRestJsonObject>();
									TempHoleP->SetNumberField("x", TempHoleSet[HoleIndex][PIndex].X);
									TempHoleP->SetNumberField("y", TempHoleSet[HoleIndex][PIndex].Y);
									TempHoleP->SetNumberField("z", TempHoleSet[HoleIndex][PIndex].Z);
									EachHolePointAttr.Add(TempHoleP);
								}
								TempHole->SetObjectArrayField("holepoint", EachHolePointAttr);
								HolesAttr.Add(TempHole);
							}

							TempSegment->SetObjectArrayField("hole", HolesAttr);
							SegmentsObjAttr.Add(TempSegment);
						}
						SegmentsJson->SetObjectArrayField("segments", SegmentsObjAttr);
					}
				}
			}
		}
	}
	return true;
}


bool  UWriteMeshObj_FunctionLibrary::SnapAreaPoints(UObject* WorldContextObject, const int RoomID, const TArray<FVector2D> OriginAreaPs, TArray<FVector2D>& OutAreaPs)
{
	if (OriginAreaPs.Num() == 0)
	{
		return false;
	}
	TArray<ALineWallActor *> WallsOfRegion;
	bool GetWallSuccess = GetWallsOfRoom(WorldContextObject, RoomID, WallsOfRegion);

	if (GetWallSuccess)
	{
		TArray<FVector2D> AllWallPoints;
		for (ALineWallActor* WallActor : WallsOfRegion)
		{
			if (WallActor == nullptr) {
				continue;
			}

			UDRProjData* projectDataManager = UDRProjData::GetProjectDataManager(WallActor);
			if (projectDataManager == nullptr) {
				continue;
			}

			UDRSolidWallAdapter* solidWallAdapter = Cast<UDRSolidWallAdapter>(projectDataManager->GetAdapter(WallActor->ObjectId));
			if (solidWallAdapter == nullptr) {
				continue;
			}

			FVector2D PStartLeft(solidWallAdapter->GetWallPositionData().LeftStartPos.X, solidWallAdapter->GetWallPositionData().LeftStartPos.Y);
			FVector2D PEndLeft(solidWallAdapter->GetWallPositionData().LeftEndPos.X, solidWallAdapter->GetWallPositionData().LeftEndPos.Y);
			FVector2D PStartRight(solidWallAdapter->GetWallPositionData().RightStartPos.X, solidWallAdapter->GetWallPositionData().RightStartPos.Y);
			FVector2D PEndRight(solidWallAdapter->GetWallPositionData().RightEndPos.X, solidWallAdapter->GetWallPositionData().RightEndPos.Y);
			AllWallPoints.Add(PStartLeft);
			AllWallPoints.Add(PEndLeft);
			AllWallPoints.Add(PStartRight);
			AllWallPoints.Add(PEndRight);
		}



		for (int I = 0; I < OriginAreaPs.Num(); ++I)
		{
			float MinDis = 0.0;
			int TempTargetIndex = 0;
			for (int J = 0; J < AllWallPoints.Num(); ++J)
			{
				float TempDis = FVector2D::Distance(OriginAreaPs[I], AllWallPoints[J]);
				if ((TempDis <= MinDis) || (MinDis == 0.0))
				{
					MinDis = TempDis;
					TempTargetIndex = J;
				}
			}
			if (MinDis <= 1.5)
			{
				OutAreaPs.Add(AllWallPoints[TempTargetIndex]);
			}
			else
			{
				OutAreaPs.Add(OriginAreaPs[I]);
			}

		}
	}

	if (OutAreaPs.Num() == 0)
	{
		return false;
	}
	return true;
}

bool UWriteMeshObj_FunctionLibrary::SaveFileToUTF8(UObject* WorldContextObject, const FString InStr, FString FileName, FString SaveDir, bool IsNoBom)
{
	FileName = SaveDir + FileName;
	bool IsSaved = false;
	if (IsNoBom)
	{
		IsSaved = FFileHelper::SaveStringToFile(InStr, *FileName, FFileHelper::EEncodingOptions::ForceUTF8WithoutBOM);
	}
	else
	{
		IsSaved = FFileHelper::SaveStringToFile(InStr, *FileName, FFileHelper::EEncodingOptions::ForceUTF8);
	}

	return IsSaved;

}


bool UWriteMeshObj_FunctionLibrary::GetWallPointsOfRoom(UObject* WorldContextObject, const int RoomID, TArray<FVector2D>&AllWallPoints)
{
	TArray<ALineWallActor *> WallsOfRegion;
	bool GetWallSuccess = GetWallsOfRoom(WorldContextObject, RoomID, WallsOfRegion);
	if (GetWallSuccess)
	{
		for (ALineWallActor* WallActor : WallsOfRegion)
		{
			if (WallActor == nullptr) {
				continue;
			}

			UDRProjData* projectDataManager = UDRProjData::GetProjectDataManager(WallActor);
			if (projectDataManager == nullptr) {
				continue;
			}

			UDRSolidWallAdapter* solidWallAdapter = Cast<UDRSolidWallAdapter>(projectDataManager->GetAdapter(WallActor->ObjectId));
			if (solidWallAdapter == nullptr) {
				continue;
			}

			FVector2D PStartLeft(solidWallAdapter->GetWallPositionData().LeftStartPos.X, solidWallAdapter->GetWallPositionData().LeftStartPos.Y);
			FVector2D PEndLeft(solidWallAdapter->GetWallPositionData().LeftEndPos.X, solidWallAdapter->GetWallPositionData().LeftEndPos.Y);
			FVector2D PStartRight(solidWallAdapter->GetWallPositionData().RightStartPos.X, solidWallAdapter->GetWallPositionData().RightStartPos.Y);
			FVector2D PEndRight(solidWallAdapter->GetWallPositionData().RightEndPos.X, solidWallAdapter->GetWallPositionData().RightEndPos.Y);
			AllWallPoints.Add(PStartLeft);
			AllWallPoints.Add(PEndLeft);
			AllWallPoints.Add(PStartRight);
			AllWallPoints.Add(PEndRight);

		}
	}
	if (AllWallPoints.Num() == 0)
	{
		return false;
	}
	return true;
}

bool UWriteMeshObj_FunctionLibrary::DivideAreas(UObject* WorldContextObject, UVaRestJsonObject* InJson, TMap<int, FloorGroup>&GroupRoomIDs)
{
	if (InJson == nullptr)
	{
		return false;
	}
	TArray<UVaRestJsonObject*> RoomJsonObj = InJson->GetObjectArrayField("roomList");
	TMap<int, TArray<FVector2D>> RoomIDMapRegions;
	TMap<int, FString> RoomIDMapName;
	TArray<int> AllRoomIDs;
	TMap<int, FString> RoomIDMapUseageName;
	TMap<int, int> RoomIDMapUsageID;
	TArray<TArray<FVector2D>> AllRegions;
	for (int RoomIndex = 0; RoomIndex < RoomJsonObj.Num(); RoomIndex++)
	{
		UVaRestJsonObject* NewRoomJson = NewObject<UVaRestJsonObject>();
		TArray<UVaRestJsonObject*> EachRoomRegion = RoomJsonObj[RoomIndex]->GetObjectArrayField("areas");
		TArray<FVector2D> TempRegionPs;
		int RoomId = RoomJsonObj[RoomIndex]->GetIntegerField("roomId");
		AllRoomIDs.Add(RoomId);
		for (int NumIndex = 0; NumIndex < EachRoomRegion.Num(); NumIndex++)
		{
			float TempX = EachRoomRegion[NumIndex]->GetNumberField("x");
			float TempY = EachRoomRegion[NumIndex]->GetNumberField("y");
			TempRegionPs.Add(FVector2D(TempX, TempY));
		}
		AllRegions.Add(TempRegionPs);
		FString RoomName = RoomJsonObj[RoomIndex]->GetStringField("roomName");
		RoomIDMapRegions.Add(RoomId, TempRegionPs);
		RoomIDMapName.Add(RoomId, RoomName);
		FString RoomUsageName = RoomJsonObj[RoomIndex]->GetStringField("roomUsageName");
		RoomIDMapUseageName.Add(RoomId, RoomUsageName);
		int RoomUsageId = RoomJsonObj[RoomIndex]->GetNumberField("usageId");
		RoomIDMapUsageID.Add(RoomId, RoomUsageId);
	}

	TMap<int, TArray<int>> GroupMapFloor;
	TArray<int> Group1, Group2;
	bool FindDingRoom = false;
	for (int I = 0; I < AllRoomIDs.Num(); ++I)
	{
		if (RoomIDMapName[AllRoomIDs[I]] == TEXT("客厅"))
		{
			Group1.AddUnique(AllRoomIDs[I]);
			TArray<FVector2D> TempWallPoints;
			FindDingRoom = true;
			bool GetWallSuccess = GetWallPointsOfRoom(WorldContextObject, AllRoomIDs[I], TempWallPoints);
			if (GetWallSuccess)
			{
				int NumOfWall = TempWallPoints.Num() / 4;
				for (int J = 0; J < NumOfWall; ++J)
				{
					FVector2D StartPos = 0.5*(TempWallPoints[0 + 4 * J] + TempWallPoints[2 + 4 * J]);
					FVector2D EndPos = 0.5*(TempWallPoints[1 + 4 * J] + TempWallPoints[3 + 4 * J]);
					FVector2D MiddleP = 0.5*(StartPos + EndPos);
					FVector2D TempVec = EndPos - StartPos;
					TempVec = TempVec.GetSafeNormal();
					FVector2D VerticalVec = TempVec.GetRotated(90);
					FVector2D TestP1 = MiddleP + 30 * VerticalVec;
					FVector2D TestP2 = MiddleP - 30 * VerticalVec;
					for (int _CurRoom = 0; _CurRoom < AllRoomIDs.Num(); ++_CurRoom)
					{
						if (AllRoomIDs[_CurRoom] != AllRoomIDs[I])
						{
							if ((FPolygonAlg::JudgePointInPolygon(RoomIDMapRegions[AllRoomIDs[_CurRoom]], TestP1)) ||
								((FPolygonAlg::JudgePointInPolygon(RoomIDMapRegions[AllRoomIDs[_CurRoom]], TestP2))))
							{
								Group1.AddUnique(AllRoomIDs[_CurRoom]);
							}
						}
					}
				}
			}
			break;
		}
		if (FindDingRoom == true)
		{
			break;
		}
	}

	int DifferNum = 1;
	while (DifferNum != 0)
	{
		int BeforeCalculation = Group1.Num();
		for (int Index = 0; Index < Group1.Num(); ++Index)
		{
			TArray<FVector2D> TempWallPoints;
			bool GetWallSuccess = GetWallPointsOfRoom(WorldContextObject, Group1[Index], TempWallPoints);
			if (GetWallSuccess)
			{
				int NumOfWall = TempWallPoints.Num() / 4;
				for (int J = 0; J < NumOfWall; ++J)
				{
					FVector2D StartPos = 0.5*(TempWallPoints[0 + 4 * J] + TempWallPoints[2 + 4 * J]);
					FVector2D EndPos = 0.5*(TempWallPoints[1 + 4 * J] + TempWallPoints[3 + 4 * J]);
					FVector2D MiddleP = 0.5*(StartPos + EndPos);
					FVector2D TempVec = EndPos - StartPos;
					TempVec = TempVec.GetSafeNormal();
					FVector2D VerticalVec = TempVec.GetRotated(90);
					FVector2D TestP1 = MiddleP + 30 * VerticalVec;
					FVector2D TestP2 = MiddleP - 30 * VerticalVec;
					for (int _CurRoom = 0; _CurRoom < AllRoomIDs.Num(); ++_CurRoom)
					{
						if (AllRoomIDs[_CurRoom] != Group1[Index])
						{
							if ((FPolygonAlg::JudgePointInPolygon(RoomIDMapRegions[AllRoomIDs[_CurRoom]], TestP1)) ||
								((FPolygonAlg::JudgePointInPolygon(RoomIDMapRegions[AllRoomIDs[_CurRoom]], TestP2))))
							{
								Group1.AddUnique(AllRoomIDs[_CurRoom]);
							}
						}
					}
				}

			}
		}
		int AfterCalculation = Group1.Num();
		DifferNum = AfterCalculation - BeforeCalculation;
	}

	if (Group1.Num() == AllRoomIDs.Num())
	{
		FloorGroup TempGroup;
		TempGroup.RoomIDs = Group1;
		GroupRoomIDs.Add(1, TempGroup);
	}
	else
	{
		FloorGroup TempGroup1, TempGroup2;
		for (int _CurRoomID = 0; _CurRoomID < AllRoomIDs.Num(); ++_CurRoomID)
		{
			if (!Group1.Contains(AllRoomIDs[_CurRoomID]))
			{
				Group2.AddUnique(AllRoomIDs[_CurRoomID]);
			}
		}
		if (Group2.Num() > Group1.Num())
		{
			TempGroup1.RoomIDs = Group2;
			TempGroup2.RoomIDs = Group1;
			GroupRoomIDs.Add(1, TempGroup1);
			GroupRoomIDs.Add(2, TempGroup2);
		}
		else
		{
			TempGroup1.RoomIDs = Group1;
			TempGroup2.RoomIDs = Group2;
			GroupRoomIDs.Add(1, TempGroup1);
			GroupRoomIDs.Add(2, TempGroup2);
		}
	}

	return true;
}


bool UWriteMeshObj_FunctionLibrary::CalculateParentRelation(UObject* WorldContextObject, UVaRestJsonObject* InJson, TArray<int>&PossibleParentRoomIDs,
	TArray<FParentRoom>&ParentRooms)
{
	if (InJson == nullptr)
	{
		return false;
	}
	TArray<UVaRestJsonObject*> RoomJsonObj = InJson->GetObjectArrayField("roomList");
	TMap<int, TArray<FVector2D>> RoomIDMapRegions;
	TMap<int, FString> RoomIDMapName;
	TArray<int> AllRoomIDs;
	TMap<int, FString> RoomIDMapUseageName;
	TMap<int, int> RoomIDMapUsageID;
	TArray<TArray<FVector2D>> AllRegions;
	for (int RoomIndex = 0; RoomIndex < RoomJsonObj.Num(); RoomIndex++)
	{
		UVaRestJsonObject* NewRoomJson = NewObject<UVaRestJsonObject>();
		TArray<UVaRestJsonObject*> EachRoomRegion = RoomJsonObj[RoomIndex]->GetObjectArrayField("areas");
		TArray<FVector2D> TempRegionPs;
		int RoomId = RoomJsonObj[RoomIndex]->GetIntegerField("roomId");
		AllRoomIDs.Add(RoomId);
		for (int NumIndex = 0; NumIndex < EachRoomRegion.Num(); NumIndex++)
		{
			float TempX = EachRoomRegion[NumIndex]->GetNumberField("x");
			float TempY = EachRoomRegion[NumIndex]->GetNumberField("y");
			TempRegionPs.AddUnique(FVector2D(TempX, TempY));
		}
		AllRegions.Add(TempRegionPs);
		FString RoomName = RoomJsonObj[RoomIndex]->GetStringField("roomName");
		RoomIDMapRegions.Add(RoomId, TempRegionPs);
		RoomIDMapName.Add(RoomId, RoomName);
		FString RoomUsageName = RoomJsonObj[RoomIndex]->GetStringField("roomUsageName");
		RoomIDMapUseageName.Add(RoomId, RoomUsageName);
		int RoomUsageId = RoomJsonObj[RoomIndex]->GetNumberField("usageId");
		RoomIDMapUsageID.Add(RoomId, RoomUsageId);
	}

	for (int _CurI = 0; _CurI < AllRoomIDs.Num(); ++_CurI)
	{
		if (RoomIDMapUseageName[AllRoomIDs[_CurI]].Contains(TEXT("主卧")))
		{
			FParentRoom TempParent;
			TempParent.ParentRoomID = AllRoomIDs[_CurI];
			PossibleParentRoomIDs.AddUnique(AllRoomIDs[_CurI]);
			TArray<int> TempArr;
			TArray<FVector> DoorPoints;
			bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, AllRoomIDs[_CurI], DoorPoints);
			if (GetDoorSuccess)
			{
				int NumOfDoors = DoorPoints.Num() / 8;
				for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
				{
					FVector DoorStart3D = 0.5*(DoorPoints[8 * DoorIndex] + DoorPoints[8 * DoorIndex + 2]);
					FVector DoorEnd3D = 0.5*(DoorPoints[8 * DoorIndex + 1] + DoorPoints[8 * DoorIndex + 3]);
					FVector2D DoorStart2D = FVector2D(DoorStart3D);
					FVector2D DoorEnd2D = FVector2D(DoorEnd3D);
					FVector2D DoorCenter2D = 0.5*(DoorStart2D + DoorEnd2D);
					FVector2D TempDoorVec = DoorEnd2D - DoorStart2D;
					TempDoorVec = TempDoorVec.GetSafeNormal();
					FVector2D TempDoorVertical = TempDoorVec.GetRotated(90);
					FVector2D TestNode1 = DoorCenter2D + 30 * TempDoorVertical;
					FVector2D TestNode2 = DoorCenter2D - 30 * TempDoorVertical;
					for (int _CurRoom = 0; _CurRoom < AllRoomIDs.Num(); ++_CurRoom)
					{
						if (AllRoomIDs[_CurRoom] != AllRoomIDs[_CurI])
						{
							if ((FPolygonAlg::JudgePointInPolygon(RoomIDMapRegions[AllRoomIDs[_CurRoom]], TestNode1)) ||
								(FPolygonAlg::JudgePointInPolygon(RoomIDMapRegions[AllRoomIDs[_CurRoom]], TestNode2)))
							{
								if ((RoomIDMapUseageName[AllRoomIDs[_CurRoom]].Contains(TEXT("主卫"))) ||
									(RoomIDMapUseageName[AllRoomIDs[_CurRoom]].Contains(TEXT("衣帽间"))) ||
									(RoomIDMapUseageName[AllRoomIDs[_CurRoom]].Contains(TEXT("生活阳台"))) ||
									(RoomIDMapUseageName[AllRoomIDs[_CurRoom]].Contains(TEXT("休闲阳台"))))
								{
									TempArr.AddUnique(AllRoomIDs[_CurRoom]);
								}
							}

						}
					}
				}
				if (TempArr.Num() != 0)
				{
					TempParent.RoomIDs = TempArr;
					ParentRooms.Add(TempParent);
					for (int _CurArr = 0; _CurArr < TempArr.Num(); ++_CurArr)
					{
						FParentRoom TempSecondParent;
						TArray<int> TempSecondArr;

						TArray<FVector> DoorPoints;
						bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempArr[_CurArr], DoorPoints);
						if (GetDoorSuccess)
						{
							int NumOfDoors = DoorPoints.Num() / 8;
							for (int DoorIndex = 0; DoorIndex < NumOfDoors; ++DoorIndex)
							{
								FVector DoorStart3D = 0.5*(DoorPoints[8 * DoorIndex] + DoorPoints[8 * DoorIndex + 2]);
								FVector DoorEnd3D = 0.5*(DoorPoints[8 * DoorIndex + 1] + DoorPoints[8 * DoorIndex + 3]);
								FVector2D DoorStart2D = FVector2D(DoorStart3D);
								FVector2D DoorEnd2D = FVector2D(DoorEnd3D);
								FVector2D DoorCenter2D = 0.5*(DoorStart2D + DoorEnd2D);
								FVector2D TempDoorVec = DoorEnd2D - DoorStart2D;
								TempDoorVec = TempDoorVec.GetSafeNormal();
								FVector2D TempDoorVertical = TempDoorVec.GetRotated(90);
								FVector2D TestNode1 = DoorCenter2D + 30 * TempDoorVertical;
								FVector2D TestNode2 = DoorCenter2D - 30 * TempDoorVertical;
								for (int _CurRoom = 0; _CurRoom < AllRoomIDs.Num(); ++_CurRoom)
								{
									if (AllRoomIDs[_CurRoom] != TempArr[_CurArr])
									{
										if ((FPolygonAlg::JudgePointInPolygon(RoomIDMapRegions[AllRoomIDs[_CurRoom]], TestNode1)) ||
											(FPolygonAlg::JudgePointInPolygon(RoomIDMapRegions[AllRoomIDs[_CurRoom]], TestNode2)))
										{
											if ((RoomIDMapUseageName[AllRoomIDs[_CurRoom]].Contains(TEXT("主卫"))) ||
												(RoomIDMapUseageName[AllRoomIDs[_CurRoom]].Contains(TEXT("衣帽间"))) ||
												(RoomIDMapUseageName[AllRoomIDs[_CurRoom]].Contains(TEXT("生活阳台"))) ||
												(RoomIDMapUseageName[AllRoomIDs[_CurRoom]].Contains(TEXT("休闲阳台"))))
											{
												PossibleParentRoomIDs.AddUnique(TempArr[_CurArr]);
												TempSecondArr.AddUnique(AllRoomIDs[_CurRoom]);
											}
										}

									}
								}
							}
						}
						if (TempSecondArr.Num() != 0)
						{
							TempSecondParent.ParentRoomID = TempArr[_CurArr];
							TempSecondParent.RoomIDs = TempSecondArr;
							ParentRooms.Add(TempSecondParent);
						}
					}
				}
			}
		}
	}
	return true;
}


bool UWriteMeshObj_FunctionLibrary::ReorderModelCenterPs(TArray<FVector2D> RegionPs, TArray<FVector> ModelCenters, TArray<FVector>& OrderedModelCenters, const float DisOfClip)
{
	bool ReorderSuccess = FPolygonAlg::ReOrderModelCenters(RegionPs, ModelCenters, OrderedModelCenters, DisOfClip);

	return ReorderSuccess;

}

bool UWriteMeshObj_FunctionLibrary::AutoMaticCreateLights(UObject* WorldContextObject, UVaRestJsonObject* InJson, TArray<FRegionLights>& AllRegionLights, const float ReduceHeight)
{
	if (InJson == nullptr)
	{
		return false;
	}

	TArray<FOldSceneLights>OldLightsArr;
	TArray<UVaRestJsonObject*> WallJsonObj = InJson->GetObjectArrayField("walls");
	TArray<Polygon_2> WallPolygon;
	TArray<FVector2D> WallCenters;
	TMap<int, TArray<FVector2D>> IndexMapWallPs;
	float WallHeight = 280;
	for (int Index = 0; Index < WallJsonObj.Num(); Index++)
	{
		TArray<FVector2D> WallRegionPoints;
		TArray<UVaRestJsonObject*> EachWallRegion = WallJsonObj[Index]->GetObjectArrayField("wallPoints");

		for (int WallIndex = 0; WallIndex < EachWallRegion.Num(); WallIndex++)
		{
			float TempZ = EachWallRegion[WallIndex]->GetNumberField("z");
			if (TempZ != 0.0)
			{
				WallHeight = TempZ;
				break;
			}
		}

		for (int WallIndex = 0; WallIndex < EachWallRegion.Num(); WallIndex++)
		{
			float TempX = EachWallRegion[WallIndex]->GetNumberField("x");
			float TempY = EachWallRegion[WallIndex]->GetNumberField("y");

			WallRegionPoints.Add(FVector2D(TempX, TempY));
		}
		Polygon_2 TempWallPolygon;
		float WallCenterX = 0.0, WallCenterY = 0.0;
		for (int PIndex = 0; PIndex < 4; PIndex++)
		{
			TempWallPolygon.push_back(Point_2(WallRegionPoints[PIndex].X, WallRegionPoints[PIndex].Y));
			WallCenterX = WallCenterX + WallRegionPoints[PIndex].X;
			WallCenterY = WallCenterY + WallRegionPoints[PIndex].Y;
		}
		WallCenterX = WallCenterX / 4;
		WallCenterY = WallCenterY / 4;
		WallCenters.Add(FVector2D(WallCenterX, WallCenterY));
		IndexMapWallPs.Add(Index, WallRegionPoints);
		WallPolygon.Add(TempWallPolygon);
		TempWallPolygon.clear();
	}


	TArray<FString> RoomNameSet, RoomUsageNameSet;
	TArray<int> RoomIDs;
	TArray<UVaRestJsonObject*> RoomJsonObj = InJson->GetObjectArrayField("roomList");

	TMap<int, TArray<FVector2D>> RoomIDMapRoomPs;
	TMap<int, FRegionLights> RoomIDMapRegionLights;
	TArray<int> RoomIDsToRemove;


	TArray<FVector2D> LivingRoomPs, DiningRoomPs, ThirdRoomPs, FourthRoomPs;

	TArray<FVector> LivingRegionLights, DiningRegionLights, ThirdLights, FourthLights;

	int LivingRoomID, DiningRoomID, ThirdRoomID, FourthRoomID;
	TArray<FRegionLights> TotalLights;

	float CuttingHeight = ReduceHeight;
	const float FilterDisBound = 20.0;
	bool IsLiving = false;
	bool IsDining = false;
	for (int Index = 0; Index < RoomJsonObj.Num(); Index++)
	{
		TArray<FVector2D> AreaPoints;

		TArray<FVector>LightsLoc;
		TArray<UVaRestJsonObject*> AreaCoorJson = RoomJsonObj[Index]->GetObjectArrayField("areas");

		FString TempRoomNameString = RoomJsonObj[Index]->GetStringField("roomName");
		RoomNameSet.Add(TempRoomNameString);

		int TempRoomID = RoomJsonObj[Index]->GetIntegerField("roomId");
		RoomIDs.Add(TempRoomID);

		for (int AreaIndex = 0; AreaIndex < AreaCoorJson.Num(); AreaIndex++)
		{
			float TempX = AreaCoorJson[AreaIndex]->GetNumberField("x");
			float TempY = AreaCoorJson[AreaIndex]->GetNumberField("y");
			AreaPoints.AddUnique(FVector2D(TempX, TempY));
		}

		RoomIDMapRoomPs.Add(TempRoomID, AreaPoints);

		FString LocalRoomName = RoomJsonObj[Index]->GetStringField("roomName");

		CuttingHeight = RoomJsonObj[Index]->GetNumberField("ReduceHeight");
		if (CuttingHeight != 0)
		{
			CuttingHeight = CuttingHeight + 10;
		}
		else
		{
			CuttingHeight = ReduceHeight + 35;
		}

		if ((LocalRoomName == TEXT("客厅")) || (LocalRoomName == TEXT("起居室")))
		{
			if (!IsLiving)
			{
				IsLiving = true;
				LivingRoomID = TempRoomID;
				bool IsSuccess = FPolygonAlg::LocateLightsOfDiningOrLivingRegion(AreaPoints, LightsLoc, WallHeight, CuttingHeight);
				TArray<AFurnitureModelActor*> ModelsInRegion;
				FindModelsOfRoom(WorldContextObject, AreaPoints, ModelsInRegion);

				if (IsSuccess)
				{
					FVector TempLightCenter(0.0, 0.0, 0.0);
					for (int _CurL = 0; _CurL < LightsLoc.Num(); ++_CurL)
					{
						TempLightCenter = TempLightCenter + LightsLoc[_CurL];
					}
					TempLightCenter = TempLightCenter / LightsLoc.Num();

					TArray<int> LocalRemoveIndexs;
					for (int _CurLight = 0; _CurLight < LightsLoc.Num(); ++_CurLight)
					{
						if (ModelsInRegion.Num() != 0)
						{
							for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
							{
								FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
								bool IfInModel = TempBox.IsInsideOrOn(LightsLoc[_CurLight]);
								if (IfInModel)
								{
									FVector FMin = TempBox.Min;
									FVector FMax = TempBox.Max;
									bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
									if (ModelBoxIsUseful)
									{
										LocalRemoveIndexs.AddUnique(_CurLight);
									}

								}
								else
								{
									bool IsInExtendBox = JudgeLightInExtendedBox(WorldContextObject, AreaPoints, LightsLoc[_CurLight], ModelsInRegion[_CurM]);
									if (IsInExtendBox)
									{
										FVector TempLoc = 0.5*(TempLightCenter + LightsLoc[_CurLight]);
										LivingRegionLights.AddUnique(TempLoc);
										break;
									}
								}

							}
						}
						if (!LocalRemoveIndexs.Contains(_CurLight))
						{
							LivingRegionLights.AddUnique(LightsLoc[_CurLight]);
						}
					}
					if (LocalRemoveIndexs.Num() == LightsLoc.Num())
					{
						for (int _Index = 0; _Index < LightsLoc.Num(); ++_Index)
						{
							LivingRegionLights.AddUnique(LightsLoc[_Index]);
						}
					}
					LivingRoomPs = AreaPoints;
				}
			}
			else
			{
				ThirdRoomID = TempRoomID;
				bool IsSuccess = FPolygonAlg::LocateLightsOfDiningOrLivingRegion(AreaPoints, LightsLoc, WallHeight, CuttingHeight);
				TArray<AFurnitureModelActor*> ModelsInRegion;
				FindModelsOfRoom(WorldContextObject, AreaPoints, ModelsInRegion);
				if (IsSuccess)
				{
					FVector TempLightCenter(0.0, 0.0, 0.0);
					for (int _CurL = 0; _CurL < LightsLoc.Num(); ++_CurL)
					{
						TempLightCenter = TempLightCenter + LightsLoc[_CurL];
					}
					TempLightCenter = TempLightCenter / LightsLoc.Num();

					TArray<int> LocalRemoveIndexs;
					for (int _CurLight = 0; _CurLight < LightsLoc.Num(); ++_CurLight)
					{
						if (ModelsInRegion.Num() != 0)
						{
							for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
							{
								FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
								bool IfInModel = TempBox.IsInsideOrOn(LightsLoc[_CurLight]);
								if (IfInModel)
								{
									FVector FMin = TempBox.Min;
									FVector FMax = TempBox.Max;
									bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
									if (ModelBoxIsUseful)
									{
										LocalRemoveIndexs.AddUnique(_CurLight);
									}
								}
								else
								{
									bool IsInExtendBox = JudgeLightInExtendedBox(WorldContextObject, AreaPoints, LightsLoc[_CurLight], ModelsInRegion[_CurM]);
									if (IsInExtendBox)
									{
										FVector TempLoc = 0.5*(TempLightCenter + LightsLoc[_CurLight]);
										ThirdLights.AddUnique(TempLoc);
										break;
									}
								}

							}
						}

						if (!LocalRemoveIndexs.Contains(_CurLight))
						{
							ThirdLights.AddUnique(LightsLoc[_CurLight]);
						}
					}
					if (LocalRemoveIndexs.Num() == LightsLoc.Num())
					{
						for (int _Index = 0; _Index < LightsLoc.Num(); ++_Index)
						{
							ThirdLights.AddUnique(LightsLoc[_Index]);
						}
					}
					ThirdRoomPs = AreaPoints;
				}



			}
		}
		else if (LocalRoomName == TEXT("餐厅"))
		{
			if (!IsDining)
			{
				IsDining = true;
				DiningRoomID = TempRoomID;
				bool IsSuccess = FPolygonAlg::LocateLightsOfDiningOrLivingRegion(AreaPoints, LightsLoc, WallHeight, CuttingHeight);

				TArray<AFurnitureModelActor*> ModelsInRegion;
				FindModelsOfRoom(WorldContextObject, AreaPoints, ModelsInRegion);

				if (IsSuccess)
				{
					FVector TempLightCenter(0.0, 0.0, 0.0);
					for (int _CurL = 0; _CurL < LightsLoc.Num(); ++_CurL)
					{
						TempLightCenter = TempLightCenter + LightsLoc[_CurL];
					}
					TempLightCenter = TempLightCenter / LightsLoc.Num();

					TArray<int> LocalRemoveIndexs;
					for (int _CurLight = 0; _CurLight < LightsLoc.Num(); ++_CurLight)
					{

						if (ModelsInRegion.Num() != 0)
						{
							for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
							{
								FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
								bool IfInModel = TempBox.IsInsideOrOn(LightsLoc[_CurLight]);
								if (IfInModel)
								{
									FVector FMin = TempBox.Min;
									FVector FMax = TempBox.Max;
									bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
									if (ModelBoxIsUseful)
									{
										LocalRemoveIndexs.AddUnique(_CurLight);
									}
								}
								else
								{
									bool IsInExtendBox = JudgeLightInExtendedBox(WorldContextObject, AreaPoints, LightsLoc[_CurLight], ModelsInRegion[_CurM]);
									if (IsInExtendBox)
									{
										FVector TempLoc = 0.5*(TempLightCenter + LightsLoc[_CurLight]);
										DiningRegionLights.AddUnique(TempLoc);
										break;
									}
								}

							}
						}
						if (!LocalRemoveIndexs.Contains(_CurLight))
						{
							DiningRegionLights.AddUnique(LightsLoc[_CurLight]);
						}
					}
					if (LocalRemoveIndexs.Num() == LightsLoc.Num())
					{
						for (int _Index = 0; _Index < LightsLoc.Num(); ++_Index)
						{
							DiningRegionLights.AddUnique(LightsLoc[_Index]);
						}
					}
					DiningRoomPs = AreaPoints;
				}
			}
			else
			{
				FourthRoomID = TempRoomID;
				bool IsSuccess = FPolygonAlg::LocateLightsOfDiningOrLivingRegion(AreaPoints, LightsLoc, WallHeight, CuttingHeight);
				TArray<AFurnitureModelActor*> ModelsInRegion;
				FindModelsOfRoom(WorldContextObject, AreaPoints, ModelsInRegion);
				if (IsSuccess)
				{
					FVector TempLightCenter(0.0, 0.0, 0.0);
					for (int _CurL = 0; _CurL < LightsLoc.Num(); ++_CurL)
					{
						TempLightCenter = TempLightCenter + LightsLoc[_CurL];
					}
					TempLightCenter = TempLightCenter / LightsLoc.Num();

					TArray<int> LocalRemoveIndexs;
					for (int _CurLight = 0; _CurLight < LightsLoc.Num(); ++_CurLight)
					{
						if (ModelsInRegion.Num() != 0)
						{
							for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
							{
								FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
								bool IfInModel = TempBox.IsInsideOrOn(LightsLoc[_CurLight]);
								if (IfInModel)
								{
									FVector FMin = TempBox.Min;
									FVector FMax = TempBox.Max;
									bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
									if (ModelBoxIsUseful)
									{
										LocalRemoveIndexs.AddUnique(_CurLight);
									}
								}
								else
								{
									bool IsInExtendBox = JudgeLightInExtendedBox(WorldContextObject, AreaPoints, LightsLoc[_CurLight], ModelsInRegion[_CurM]);
									if (IsInExtendBox)
									{
										FVector TempLoc = 0.5*(TempLightCenter + LightsLoc[_CurLight]);
										FourthLights.AddUnique(TempLoc);
										break;
									}
								}

							}
						}
						if (!LocalRemoveIndexs.Contains(_CurLight))
						{
							FourthLights.AddUnique(LightsLoc[_CurLight]);
						}
					}
					if (LocalRemoveIndexs.Num() == LightsLoc.Num())
					{
						for (int _Index = 0; _Index < LightsLoc.Num(); ++_Index)
						{
							FourthLights.AddUnique(LightsLoc[_Index]);
						}
					}
					FourthRoomPs = AreaPoints;
				}
			}
		}
		else if ((LocalRoomName == TEXT("主卧")) || (LocalRoomName == TEXT("次卧")) || (LocalRoomName == TEXT("儿童房")) || (LocalRoomName == TEXT("老人房"))
			|| (LocalRoomName == TEXT("榻榻米房")) || (LocalRoomName == TEXT("客人房")) || (LocalRoomName == TEXT("书房")) || (LocalRoomName == TEXT("健身房"))
			|| (LocalRoomName == TEXT("多功能房")))
		{

			TArray<FVector2D> TempSmallCenters;
			TMap<FVector2D, TArray<FVector2D>> TempCenterMapLocalRegions;
			bool IsCreated = FPolygonAlg::LocateLightsOfRoom(AreaPoints, LightsLoc, WallHeight, CuttingHeight);
			TArray<AFurnitureModelActor*> ModelsInRegion;
			FindModelsOfRoom(WorldContextObject, AreaPoints, ModelsInRegion);
			if (IsCreated)
			{
				FVector TempLightCenter(0.0, 0.0, 0.0);
				for (int _CurL = 0; _CurL < LightsLoc.Num(); ++_CurL)
				{
					TempLightCenter = TempLightCenter + LightsLoc[_CurL];
				}
				TempLightCenter = TempLightCenter / LightsLoc.Num();

				TArray<int> LocalRemoveIndexs;
				FRegionLights TempLights;
				for (int _CurLight = 0; _CurLight < LightsLoc.Num(); ++_CurLight)
				{
					FIntelligentLight LocalLight;
					LocalLight.Loc = LightsLoc[_CurLight];
					if (ModelsInRegion.Num() != 0)
					{
						for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
						{
							FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
							bool IfInModel = TempBox.IsInsideOrOn(LocalLight.Loc);
							if (IfInModel)
							{
								FVector FMin = TempBox.Min;
								FVector FMax = TempBox.Max;
								bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
								if (ModelBoxIsUseful)
								{
									LocalRemoveIndexs.AddUnique(_CurLight);
								}
							}
							else
							{
								bool IsInExtendBox = JudgeLightInExtendedBox(WorldContextObject, AreaPoints, LocalLight.Loc, ModelsInRegion[_CurM]);
								if (IsInExtendBox)
								{
									LocalLight.Loc = 0.75*TempLightCenter + 0.25*LocalLight.Loc;
									break;
								}
							}
						}
					}

					if (!LocalRemoveIndexs.Contains(_CurLight))
					{
						TempLights.LightInfo.Add(LocalLight);
					}

				}

				if (TempLights.LightInfo.Num() != 4)
				{
					TArray<FVector2D> PostPoints;
					FPolygonAlg::MergeCollinearPoints(AreaPoints, PostPoints);
					if (PostPoints.Num() == 4)
					{
						TArray<FVector> DoorPoints;
						bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomID, DoorPoints);
						if (GetDoorSuccess)
						{
							int NumOfDoors = DoorPoints.Num() / 8;
							for (int _CurDoor = 0; _CurDoor < NumOfDoors; ++_CurDoor)
							{
								FIntelligentLight LocalLight;
								FVector TempDoorCenter = 0.25*(DoorPoints[0 + 8 * _CurDoor] + DoorPoints[1 + 8 * _CurDoor] + DoorPoints[2 + 8 * _CurDoor] + DoorPoints[3 + 8 * _CurDoor]);
								FVector TempLongDir = DoorPoints[1 + 8 * _CurDoor] - DoorPoints[0 + 8 * _CurDoor];
								TempLongDir.Normalize();
								FVector2D TempRotatedDir = FVector2D(TempLongDir);
								TempRotatedDir = TempRotatedDir.GetRotated(90);
								FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter);
								FVector2D TempExtendPos = TempDoorCenter2D + 60 * TempRotatedDir;
								if (FPolygonAlg::JudgePointInPolygon(PostPoints, TempExtendPos))
								{
									LocalLight.Loc = FVector(TempExtendPos, WallHeight - CuttingHeight);
									TempLights.LightInfo.Add(LocalLight);
								}
								else
								{
									TempExtendPos = TempDoorCenter2D - 60 * TempRotatedDir;
									LocalLight.Loc = FVector(TempExtendPos, WallHeight - CuttingHeight);
									TempLights.LightInfo.Add(LocalLight);
								}
							}
						}
					}
				}
				RoomIDMapRegionLights.Add(TempRoomID, TempLights);
				TotalLights.Add(TempLights);
			}
		}
		else if (LocalRoomName == TEXT("厨房"))
		{
			FVector TempLocOfKitchen;
			bool IsCreated = FPolygonAlg::LocateLightOfKitchen(AreaPoints, TempLocOfKitchen, WallHeight, CuttingHeight);
			TArray<AFurnitureModelActor*> ModelsInRegion;
			FindModelsOfRoom(WorldContextObject, AreaPoints, ModelsInRegion);
			if (IsCreated)
			{

				TArray<FVector> TempArrOfLoc;
				TempArrOfLoc.Add(TempLocOfKitchen);
				FRegionLights TempLights;
				TArray<int> LocalRemoveIndexs;
				for (int I = 0; I < TempArrOfLoc.Num(); ++I)
				{
					FIntelligentLight LocalLight;
					LocalLight.Loc = TempArrOfLoc[I];
					if (ModelsInRegion.Num() != 0)
					{
						for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
						{
							FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
							bool IfInModel = TempBox.IsInsideOrOn(LocalLight.Loc);
							if (IfInModel)
							{
								FVector FMin = TempBox.Min;
								FVector FMax = TempBox.Max;
								bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
								if (ModelBoxIsUseful)
								{
									LocalRemoveIndexs.AddUnique(I);
								}
							}

						}
					}

					if (!LocalRemoveIndexs.Contains(I))
					{
						TempLights.LightInfo.Add(LocalLight);
					}
				}
				RoomIDMapRegionLights.Add(TempRoomID, TempLights);
				TotalLights.Add(TempLights);
			}

		}
		else if ((LocalRoomName == TEXT("主卫")) || (LocalRoomName == TEXT("客卫")) || (LocalRoomName == TEXT("卫生间")))
		{
			bool FindWall = false;
			int TargetIndex = 0;
			for (int _CurIndex = 0; _CurIndex < WallCenters.Num(); ++_CurIndex)
			{
				bool JudgeIfInRegion = FPolygonAlg::JudgePointInPolygon(AreaPoints, WallCenters[_CurIndex]);
				if (JudgeIfInRegion)
				{
					FindWall = true;
					TargetIndex = _CurIndex;
					break;
				}
			}
			TArray<AFurnitureModelActor*> ModelsInRegion;
			FindModelsOfRoom(WorldContextObject, AreaPoints, ModelsInRegion);
			if (FindWall)
			{
				TArray<int> LocalRemoveIndexs;
				TArray<FVector2D> WallPoints = IndexMapWallPs[TargetIndex];
				bool LocateSuccess = FPolygonAlg::LocateLightsOfSecondToliet(AreaPoints, WallPoints, LightsLoc, WallHeight, CuttingHeight);

				if (LocateSuccess)
				{
					FRegionLights TempLights;
					for (int _CurL = 0; _CurL < LightsLoc.Num(); ++_CurL)
					{
						FIntelligentLight LocalLight;
						LocalLight.Loc = LightsLoc[_CurL];
						if (ModelsInRegion.Num() != 0)
						{
							for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
							{
								FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
								bool IfInModel = TempBox.IsInsideOrOn(LocalLight.Loc);
								if (IfInModel)
								{
									FVector FMin = TempBox.Min;
									FVector FMax = TempBox.Max;
									bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
									if (ModelBoxIsUseful)
									{
										LocalRemoveIndexs.AddUnique(_CurL);
									}
								}

							}

							if (!LocalRemoveIndexs.Contains(_CurL))
							{
								TempLights.LightInfo.Add(LocalLight);
							}
						}
					}
					if (LocalRemoveIndexs.Num() == LightsLoc.Num())
					{
						TArray<FVector>DoorPoints;
						bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomID, DoorPoints);
						if (!GetDoorSuccess)
						{
							FVector2D TempCenter;
							bool IsCreated = FPolygonAlg::LocateSuitableCenter(AreaPoints, TempCenter);
							if (IsCreated)
							{
								TArray<FVector> TempLightArr;
								TempLightArr.Add(FVector(TempCenter, WallHeight - CuttingHeight));
								FRegionLights TempLights;
								for (int I = 0; I < TempLightArr.Num(); ++I)
								{
									FIntelligentLight LocalLight;
									LocalLight.Loc = TempLightArr[I];
									TempLights.LightInfo.Add(LocalLight);
								}
								RoomIDMapRegionLights.Add(TempRoomID, TempLights);
								TotalLights.Add(TempLights);
							}
						}
						else
						{
							int NumOfDoors = DoorPoints.Num() / 8;
							if (NumOfDoors >= 1)
							{
								FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
								FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
								DirVec = DirVec.GetSafeNormal();
								DirVec = DirVec.GetRotated(90);
								FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
								FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
								FVector2D TempVec1 = DoorCenter2D + 25 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(AreaPoints, TempVec1))
								{
									TArray<FVector> TempLightArr;
									TempLightArr.Add(FVector(TempVec1, WallHeight - CuttingHeight));
									FRegionLights TempLights;
									for (int I = 0; I < TempLightArr.Num(); ++I)
									{
										FIntelligentLight LocalLight;
										LocalLight.Loc = TempLightArr[I];
										TempLights.LightInfo.Add(LocalLight);
									}
									RoomIDMapRegionLights.Add(TempRoomID, TempLights);
									TotalLights.Add(TempLights);
								}
								else
								{
									FVector2D TempP = DoorCenter2D - 25 * DirVec;
									if (FPolygonAlg::JudgePointInPolygon(AreaPoints, TempP))
									{
										TArray<FVector> TempLightArr;
										TempLightArr.Add(FVector(TempP, WallHeight - CuttingHeight));
										FRegionLights TempLights;
										for (int I = 0; I < TempLightArr.Num(); ++I)
										{
											FIntelligentLight LocalLight;
											LocalLight.Loc = TempLightArr[I];
											TempLights.LightInfo.Add(LocalLight);
										}
										RoomIDMapRegionLights.Add(TempRoomID, TempLights);
										TotalLights.Add(TempLights);
									}
									else
									{
										FVector2D TempCenter;
										bool IsCreated = FPolygonAlg::LocateSuitableCenter(AreaPoints, TempCenter);
										if (IsCreated)
										{
											TArray<FVector> TempLightArr;
											TempLightArr.Add(FVector(TempCenter, WallHeight - CuttingHeight));
											FRegionLights TempLights;
											for (int I = 0; I < TempLightArr.Num(); ++I)
											{
												FIntelligentLight LocalLight;
												LocalLight.Loc = TempLightArr[I];
												TempLights.LightInfo.Add(LocalLight);
											}
											RoomIDMapRegionLights.Add(TempRoomID, TempLights);
											TotalLights.Add(TempLights);
										}
									}

								}
							}
						}
					}
					else
					{
						RoomIDMapRegionLights.Add(TempRoomID, TempLights);
						TotalLights.Add(TempLights);
					}
				}
			}
			else
			{
				TArray<FVector> TempLightLocs;
				bool IsSuccess = FPolygonAlg::LocateTwoLightsOfOneToilet(AreaPoints, TempLightLocs, WallHeight, CuttingHeight);
				if (IsSuccess)
				{
					TArray<int> LocalRemoveIndexs;

					FRegionLights TempLights;
					for (int I = 0; I < TempLightLocs.Num(); ++I)
					{
						FIntelligentLight LocalLight;
						LocalLight.Loc = TempLightLocs[I];

						if (ModelsInRegion.Num() != 0)
						{
							for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
							{
								FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
								bool IfInModel = TempBox.IsInsideOrOn(LocalLight.Loc);
								if (IfInModel)
								{
									FVector FMin = TempBox.Min;
									FVector FMax = TempBox.Max;
									bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
									if (ModelBoxIsUseful)
									{
										LocalRemoveIndexs.AddUnique(I);
									}
								}

							}

							if (!LocalRemoveIndexs.Contains(I))
							{
								TempLights.LightInfo.Add(LocalLight);
							}
						}
					}

					if (LocalRemoveIndexs.Num() == TempLightLocs.Num())
					{
						TArray<FVector>DoorPoints;
						bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomID, DoorPoints);
						if (!GetDoorSuccess)
						{
							FVector2D TempCenter;
							bool IsCreated = FPolygonAlg::LocateSuitableCenter(AreaPoints, TempCenter);
							if (IsCreated)
							{
								TArray<FVector> TempLightArr;
								TempLightArr.Add(FVector(TempCenter, WallHeight - CuttingHeight));
								FRegionLights TempLights;
								for (int I = 0; I < TempLightArr.Num(); ++I)
								{
									FIntelligentLight LocalLight;
									LocalLight.Loc = TempLightArr[I];
									TempLights.LightInfo.Add(LocalLight);
								}
								RoomIDMapRegionLights.Add(TempRoomID, TempLights);
								TotalLights.Add(TempLights);
							}
						}
						else
						{
							int NumOfDoors = DoorPoints.Num() / 8;
							if (NumOfDoors >= 1)
							{
								FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
								FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
								DirVec = DirVec.GetSafeNormal();
								DirVec = DirVec.GetRotated(90);
								FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
								FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
								FVector2D TempVec1 = DoorCenter2D + 25 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(AreaPoints, TempVec1))
								{
									TArray<FVector> TempLightArr;
									TempLightArr.Add(FVector(TempVec1, WallHeight - CuttingHeight));
									FRegionLights TempLights;
									for (int I = 0; I < TempLightArr.Num(); ++I)
									{
										FIntelligentLight LocalLight;
										LocalLight.Loc = TempLightArr[I];
										TempLights.LightInfo.Add(LocalLight);
									}
									RoomIDMapRegionLights.Add(TempRoomID, TempLights);
									TotalLights.Add(TempLights);
								}
								else
								{
									FVector2D TempP = DoorCenter2D - 25 * DirVec;
									if (FPolygonAlg::JudgePointInPolygon(AreaPoints, TempP))
									{
										TArray<FVector> TempLightArr;
										TempLightArr.Add(FVector(TempP, WallHeight - CuttingHeight));
										FRegionLights TempLights;
										for (int I = 0; I < TempLightArr.Num(); ++I)
										{
											FIntelligentLight LocalLight;
											LocalLight.Loc = TempLightArr[I];
											TempLights.LightInfo.Add(LocalLight);
										}
										RoomIDMapRegionLights.Add(TempRoomID, TempLights);
										TotalLights.Add(TempLights);
									}
									else
									{
										FVector2D TempCenter;
										bool IsCreated = FPolygonAlg::LocateSuitableCenter(AreaPoints, TempCenter);
										if (IsCreated)
										{
											TArray<FVector> TempLightArr;
											TempLightArr.Add(FVector(TempCenter, WallHeight - CuttingHeight));
											FRegionLights TempLights;
											for (int I = 0; I < TempLightArr.Num(); ++I)
											{
												FIntelligentLight LocalLight;
												LocalLight.Loc = TempLightArr[I];
												TempLights.LightInfo.Add(LocalLight);
											}
											RoomIDMapRegionLights.Add(TempRoomID, TempLights);
											TotalLights.Add(TempLights);
										}
									}

								}
							}
						}
					}
					else
					{
						RoomIDMapRegionLights.Add(TempRoomID, TempLights);
						TotalLights.Add(TempLights);
					}


				}
			}
		}
		else if (LocalRoomName == TEXT("储藏间"))
		{
			bool IsUnUseful = false;
			const float DisTol = 10.0;
			TArray<FVector>DoorPoints;
			bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomID, DoorPoints);
			if (!GetDoorSuccess)
			{
				FVector2D TempCenter;
				bool IsCreated = FPolygonAlg::LocateSuitableCenter(AreaPoints, TempCenter);
				if (IsCreated)
				{
					TArray<AFurnitureModelActor*> TempModelsInRegion;
					FindModelsOfRoom(WorldContextObject, AreaPoints, TempModelsInRegion);
					for (auto TempModel : TempModelsInRegion)
					{
						FBox TempBox = TempModel->GetComponentsBoundingBox(true);
						bool IfInModel = TempBox.IsInsideOrOn(FVector(TempCenter, WallHeight - CuttingHeight));
						if (!IfInModel)
						{
							FVector TempMin = TempBox.Min;
							FVector TempMax = TempBox.Max;
							float TempMinX = TempMin.X;
							float TempMaxX = TempMax.X;
							float TempMinY = TempMin.Y;
							float TempMaxY = TempMax.Y;
							float DifferMinX = abs(TempMinX - TempCenter.X);
							float DifferMinY = abs(TempMinY - TempCenter.Y);
							float DifferMaxX = abs(TempMaxX - TempCenter.X);
							float DifferMaxY = abs(TempMaxY - TempCenter.Y);
							if ((DifferMinX <= DisTol) || (DifferMinY <= DisTol) || (DifferMaxX <= DisTol) || (DifferMaxY <= DisTol))
							{
								IsUnUseful = true;
								break;
							}
						}
					}
					if (!IsUnUseful)
					{
						TArray<FVector> TempLightArr;
						TempLightArr.Add(FVector(TempCenter, WallHeight - CuttingHeight));
						FRegionLights TempLights;
						for (int I = 0; I < TempLightArr.Num(); ++I)
						{
							FIntelligentLight LocalLight;
							LocalLight.Loc = TempLightArr[I];
							TempLights.LightInfo.Add(LocalLight);
						}
						RoomIDMapRegionLights.Add(TempRoomID, TempLights);
						TotalLights.Add(TempLights);
					}

				}
			}
			else
			{
				//////////////////////////////////////////////////////////////////////////////////////
				FVector2D TempCenter;
				bool IsCreated = FPolygonAlg::LocateSuitableCenter(AreaPoints, TempCenter);
				if (IsCreated)
				{

					TArray<AFurnitureModelActor*> TempModelsInRegion;
					FindModelsOfRoom(WorldContextObject, AreaPoints, TempModelsInRegion);
					for (auto TempModel : TempModelsInRegion)
					{
						FBox TempBox = TempModel->GetComponentsBoundingBox(true);
						bool IfInModel = TempBox.IsInsideOrOn(FVector(TempCenter, WallHeight - CuttingHeight));
						if (!IfInModel)
						{
							FVector TempMin = TempBox.Min;
							FVector TempMax = TempBox.Max;
							float TempMinX = TempMin.X;
							float TempMaxX = TempMax.X;
							float TempMinY = TempMin.Y;
							float TempMaxY = TempMax.Y;
							float DifferMinX = abs(TempMinX - TempCenter.X);
							float DifferMinY = abs(TempMinY - TempCenter.Y);
							float DifferMaxX = abs(TempMaxX - TempCenter.X);
							float DifferMaxY = abs(TempMaxY - TempCenter.Y);
							if ((DifferMinX <= DisTol) || (DifferMinY <= DisTol) || (DifferMaxX <= DisTol) || (DifferMaxY <= DisTol))
							{
								IsUnUseful = true;
								break;
							}
						}
					}
					if (!IsUnUseful)
					{
						TArray<FVector> TempLightArr;
						TempLightArr.Add(FVector(TempCenter, WallHeight - CuttingHeight));
						FRegionLights TempLights;
						for (int I = 0; I < TempLightArr.Num(); ++I)
						{
							FIntelligentLight LocalLight;
							LocalLight.Loc = TempLightArr[I];
							TempLights.LightInfo.Add(LocalLight);
						}
						RoomIDMapRegionLights.Add(TempRoomID, TempLights);
						TotalLights.Add(TempLights);
					}

				}
			}




			//////////////////////////////////////////////////////////////////////////////////////
			if (IsUnUseful)
			{
				int NumOfDoors = DoorPoints.Num() / 8;
				if (NumOfDoors >= 1)
				{
					FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
					FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
					DirVec = DirVec.GetSafeNormal();
					DirVec = DirVec.GetRotated(90);
					FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
					FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
					FVector2D TempVec1 = DoorCenter2D + 20 * DirVec;
					if (FPolygonAlg::JudgePointInPolygon(AreaPoints, TempVec1))
					{
						TArray<FVector> TempLightArr;
						TempLightArr.Add(FVector(TempVec1, WallHeight - CuttingHeight));
						FRegionLights TempLights;
						for (int I = 0; I < TempLightArr.Num(); ++I)
						{
							FIntelligentLight LocalLight;
							LocalLight.Loc = TempLightArr[I];
							TempLights.LightInfo.Add(LocalLight);
						}
						RoomIDMapRegionLights.Add(TempRoomID, TempLights);
						TotalLights.Add(TempLights);
					}
					else
					{
						FVector2D TempP = DoorCenter2D - 20 * DirVec;
						if (FPolygonAlg::JudgePointInPolygon(AreaPoints, TempP))
						{
							TArray<FVector> TempLightArr;
							TempLightArr.Add(FVector(TempP, WallHeight - CuttingHeight));
							FRegionLights TempLights;
							for (int I = 0; I < TempLightArr.Num(); ++I)
							{
								FIntelligentLight LocalLight;
								LocalLight.Loc = TempLightArr[I];
								TempLights.LightInfo.Add(LocalLight);
							}
							RoomIDMapRegionLights.Add(TempRoomID, TempLights);
							TotalLights.Add(TempLights);
						}
						else
						{
							FVector2D TempCenter;
							bool IsCreated = FPolygonAlg::LocateSuitableCenter(AreaPoints, TempCenter);
							if (IsCreated)
							{
								TArray<FVector> TempLightArr;
								TempLightArr.Add(FVector(TempCenter, WallHeight - CuttingHeight));
								FRegionLights TempLights;
								for (int I = 0; I < TempLightArr.Num(); ++I)
								{
									FIntelligentLight LocalLight;
									LocalLight.Loc = TempLightArr[I];
									TempLights.LightInfo.Add(LocalLight);
								}
								RoomIDMapRegionLights.Add(TempRoomID, TempLights);
								TotalLights.Add(TempLights);
							}
						}

					}
				}
			}

		}
		else if ((LocalRoomName == TEXT("衣帽间")) || (LocalRoomName == TEXT("茶室")))
		{
			FVector2D TempCenter;
			bool IsCreated = FPolygonAlg::LocateSuitableCenter(AreaPoints, TempCenter);
			TArray<AFurnitureModelActor*> ModelsInRegion;
			FindModelsOfRoom(WorldContextObject, AreaPoints, ModelsInRegion);
			if (IsCreated)
			{
				TArray<int> LocalRemoveIndexs;
				TArray<FVector> TempLightArr;
				TempLightArr.Add(FVector(TempCenter, WallHeight - CuttingHeight));
				FRegionLights TempLights;
				for (int I = 0; I < TempLightArr.Num(); ++I)
				{
					FIntelligentLight LocalLight;
					LocalLight.Loc = TempLightArr[I];
					if (ModelsInRegion.Num() != 0)
					{
						for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
						{
							FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
							bool IfInModel = TempBox.IsInsideOrOn(LocalLight.Loc);
							if (IfInModel)
							{
								FVector FMin = TempBox.Min;
								FVector FMax = TempBox.Max;
								bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
								if (ModelBoxIsUseful)
								{
									LocalRemoveIndexs.AddUnique(I);
								}
							}

						}

						if (!LocalRemoveIndexs.Contains(I))
						{
							TempLights.LightInfo.Add(LocalLight);
						}
					}
				}

				if (LocalRemoveIndexs.Num() == TempLightArr.Num())
				{
					TArray<FVector>DoorPoints;
					bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomID, DoorPoints);
					if (!GetDoorSuccess)
					{
						FVector2D TempCenter;
						bool IsCreated = FPolygonAlg::LocateSuitableCenter(AreaPoints, TempCenter);
						if (IsCreated)
						{
							TArray<FVector> TempLightArr;
							TempLightArr.Add(FVector(TempCenter, WallHeight - CuttingHeight));
							FRegionLights TempLights;
							for (int I = 0; I < TempLightArr.Num(); ++I)
							{
								FIntelligentLight LocalLight;
								LocalLight.Loc = TempLightArr[I];
								TempLights.LightInfo.Add(LocalLight);
							}
							RoomIDMapRegionLights.Add(TempRoomID, TempLights);
							TotalLights.Add(TempLights);
						}
					}
					else
					{
						int NumOfDoors = DoorPoints.Num() / 8;
						if (NumOfDoors >= 1)
						{
							FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
							FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
							DirVec = DirVec.GetSafeNormal();
							DirVec = DirVec.GetRotated(90);
							FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
							FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
							FVector2D TempVec1 = DoorCenter2D + 25 * DirVec;
							if (FPolygonAlg::JudgePointInPolygon(AreaPoints, TempVec1))
							{
								TArray<FVector> TempLightArr;
								TempLightArr.Add(FVector(TempVec1, WallHeight - CuttingHeight));
								FRegionLights TempLights;
								for (int I = 0; I < TempLightArr.Num(); ++I)
								{
									FIntelligentLight LocalLight;
									LocalLight.Loc = TempLightArr[I];
									TempLights.LightInfo.Add(LocalLight);
								}
								RoomIDMapRegionLights.Add(TempRoomID, TempLights);
								TotalLights.Add(TempLights);
							}
							else
							{
								FVector2D TempP = DoorCenter2D - 25 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(AreaPoints, TempP))
								{
									TArray<FVector> TempLightArr;
									TempLightArr.Add(FVector(TempP, WallHeight - CuttingHeight));
									FRegionLights TempLights;
									for (int I = 0; I < TempLightArr.Num(); ++I)
									{
										FIntelligentLight LocalLight;
										LocalLight.Loc = TempLightArr[I];
										TempLights.LightInfo.Add(LocalLight);
									}
									RoomIDMapRegionLights.Add(TempRoomID, TempLights);
									TotalLights.Add(TempLights);
								}
								else
								{
									FVector2D TempCenter;
									bool IsCreated = FPolygonAlg::LocateSuitableCenter(AreaPoints, TempCenter);
									if (IsCreated)
									{
										TArray<FVector> TempLightArr;
										TempLightArr.Add(FVector(TempCenter, WallHeight - CuttingHeight));
										FRegionLights TempLights;
										for (int I = 0; I < TempLightArr.Num(); ++I)
										{
											FIntelligentLight LocalLight;
											LocalLight.Loc = TempLightArr[I];
											TempLights.LightInfo.Add(LocalLight);
										}
										RoomIDMapRegionLights.Add(TempRoomID, TempLights);
										TotalLights.Add(TempLights);
									}
								}

							}
						}
					}
				}
				RoomIDMapRegionLights.Add(TempRoomID, TempLights);
				TotalLights.Add(TempLights);
			}
		}
		else
		{
			RoomIDsToRemove.AddUnique(TempRoomID);
		}
	}

	if ((LivingRoomPs.Num() != 0) && (DiningRoomPs.Num() != 0))
	{
		bool IfConnected1 = FPolygonAlg::JudgeHasClosePoint(LivingRoomPs, DiningRoomPs);
		if (IfConnected1)
		{
			int NumOfLivingPs = LivingRoomPs.Num();
			int NumOfDiningPs = DiningRoomPs.Num();
			TArray<FVector2D> TempAreaPs, LocalRegion;
			TArray<FVector> LocationOfLights, LocalLights;
			if (NumOfLivingPs > NumOfDiningPs)
			{
				TempAreaPs = LivingRoomPs;
				LocalRegion = DiningRoomPs;
			}
			else
			{
				TempAreaPs = DiningRoomPs;
				LocalRegion = LivingRoomPs;
			}

			TArray<AFurnitureModelActor*> ModelsInRegion;
			FindModelsOfRoom(WorldContextObject, TempAreaPs, ModelsInRegion);

			bool IsSuccessful = FPolygonAlg::LocateLightsOfPassageAndVestibule(TempAreaPs, LocationOfLights, WallHeight, CuttingHeight);
			if (IsSuccessful)
			{
				TArray<FVector> UpdateLocationOfLights;
				bool FilterLocs = FPolygonAlg::FilterLights(LocationOfLights, TempAreaPs, UpdateLocationOfLights, FilterDisBound);
				if (FilterLocs)
				{
					TArray<int> LocalRemoveIndexs;
					for (int _CurLight = 0; _CurLight < UpdateLocationOfLights.Num(); ++_CurLight)
					{
						if (FPolygonAlg::JudgePointInPolygon(LivingRoomPs, FVector2D(UpdateLocationOfLights[_CurLight])))
						{
							if (ModelsInRegion.Num() != 0)
							{
								for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
								{
									FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
									bool IfInModel = TempBox.IsInsideOrOn(UpdateLocationOfLights[_CurLight]);
									if (IfInModel)
									{
										FVector FMin = TempBox.Min;
										FVector FMax = TempBox.Max;
										bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, TempAreaPs);
										if (ModelBoxIsUseful)
										{
											LocalRemoveIndexs.AddUnique(_CurLight);
										}

									}

								}
							}

							if (!LocalRemoveIndexs.Contains(_CurLight))
							{
								LivingRegionLights.AddUnique(UpdateLocationOfLights[_CurLight]);
							}
						}
						if (FPolygonAlg::JudgePointInPolygon(DiningRoomPs, FVector2D(UpdateLocationOfLights[_CurLight])))
						{
							if (ModelsInRegion.Num() != 0)
							{
								for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
								{
									FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
									bool IfInModel = TempBox.IsInsideOrOn(UpdateLocationOfLights[_CurLight]);
									if (IfInModel)
									{
										FVector FMin = TempBox.Min;
										FVector FMax = TempBox.Max;
										bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, TempAreaPs);
										if (ModelBoxIsUseful)
										{
											LocalRemoveIndexs.AddUnique(_CurLight);
										}
									}

								}
							}

							if (!LocalRemoveIndexs.Contains(_CurLight))
							{
								DiningRegionLights.AddUnique(UpdateLocationOfLights[_CurLight]);
							}
						}
					}
				}

				///////////////////////////计算局部小区域的灯的位置//////////////////////
				TArray<int> LocalIndexs;
				TArray<FVector> LightsLocOfSmallRegion;
				bool LocateSuccess = FPolygonAlg::LocateLightsOfSmallRegion(LocalRegion, LightsLocOfSmallRegion, WallHeight, CuttingHeight);
				if (LocateSuccess)
				{
					TArray<FVector> UpdateLightsLocOfSmallRegion;
					bool FilterSuccess = FPolygonAlg::FilterLights(LightsLocOfSmallRegion, LocalRegion, UpdateLightsLocOfSmallRegion, FilterDisBound);
					if (FilterSuccess)
					{
						TArray<AFurnitureModelActor*> TempModelsInRegion;
						FindModelsOfRoom(WorldContextObject, LocalRegion, TempModelsInRegion);
						for (int _CurLight = 0; _CurLight < UpdateLightsLocOfSmallRegion.Num(); ++_CurLight)
						{
							if (FPolygonAlg::JudgePointInPolygon(LivingRoomPs, FVector2D(UpdateLightsLocOfSmallRegion[_CurLight])))
							{
								if (TempModelsInRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < TempModelsInRegion.Num(); ++_CurM)
									{
										FBox TempBox = TempModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(UpdateLightsLocOfSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalIndexs.AddUnique(_CurLight);
										}
									}
								}
								if (ModelsInRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
									{
										FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(UpdateLightsLocOfSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalIndexs.AddUnique(_CurLight);
										}

									}
								}
								if (!LocalIndexs.Contains(_CurLight))
								{
									LivingRegionLights.AddUnique(UpdateLightsLocOfSmallRegion[_CurLight]);
								}
							}

							if (FPolygonAlg::JudgePointInPolygon(DiningRoomPs, FVector2D(UpdateLightsLocOfSmallRegion[_CurLight])))
							{
								if (TempModelsInRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < TempModelsInRegion.Num(); ++_CurM)
									{
										FBox TempBox = TempModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(UpdateLightsLocOfSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalIndexs.AddUnique(_CurLight);
										}
									}
								}
								if (ModelsInRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
									{
										FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(UpdateLightsLocOfSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalIndexs.AddUnique(_CurLight);
										}

									}
								}
								if (!LocalIndexs.Contains(_CurLight))
								{
									DiningRegionLights.AddUnique(UpdateLightsLocOfSmallRegion[_CurLight]);
								}
							}

						}
					}

				}
			}

			else
			{
				TArray<int> LocalRemoveIndexs;
				TArray<FVector> LightsLocOfSmallRegion;
				bool LocateSuccess = FPolygonAlg::LocateLightsOfSmallRegion(TempAreaPs, LightsLocOfSmallRegion, WallHeight, CuttingHeight);
				if (LocateSuccess)
				{
					TArray<AFurnitureModelActor*> TempModelsInRegion;
					FindModelsOfRoom(WorldContextObject, LocalRegion, TempModelsInRegion);

					TArray<FVector> UpdateLightsLocOfSmallRegion;
					bool FilterPs = FPolygonAlg::FilterLights(LightsLocOfSmallRegion, TempAreaPs, UpdateLightsLocOfSmallRegion, FilterDisBound);
					if (FilterPs)
					{
						for (int _CurLight = 0; _CurLight < UpdateLightsLocOfSmallRegion.Num(); ++_CurLight)
						{
							if (FPolygonAlg::JudgePointInPolygon(LivingRoomPs, FVector2D(UpdateLightsLocOfSmallRegion[_CurLight])))
							{
								if (ModelsInRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
									{
										FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(UpdateLightsLocOfSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalRemoveIndexs.AddUnique(_CurLight);
										}

									}
								}
								if (TempModelsInRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < TempModelsInRegion.Num(); ++_CurM)
									{
										FBox TempBox = TempModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(UpdateLightsLocOfSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalRemoveIndexs.AddUnique(_CurLight);
										}
									}
								}
								if (!LocalRemoveIndexs.Contains(_CurLight))
								{
									LivingRegionLights.AddUnique(UpdateLightsLocOfSmallRegion[_CurLight]);
								}
							}
							if (FPolygonAlg::JudgePointInPolygon(DiningRoomPs, FVector2D(UpdateLightsLocOfSmallRegion[_CurLight])))
							{
								if (ModelsInRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
									{
										FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(UpdateLightsLocOfSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalRemoveIndexs.AddUnique(_CurLight);
										}

									}
								}
								if (TempModelsInRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < TempModelsInRegion.Num(); ++_CurM)
									{
										FBox TempBox = TempModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(UpdateLightsLocOfSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalRemoveIndexs.AddUnique(_CurLight);
										}
									}
								}
								if (!LocalRemoveIndexs.Contains(_CurLight))
								{
									DiningRegionLights.AddUnique(UpdateLightsLocOfSmallRegion[_CurLight]);
								}
							}
						}
					}


				}

				///////////////计算另一区域的小区域内的灯/////////////////////////////////////
				TArray<int> LocalIndexsOfOppoRegion;
				TArray<FVector> LightsOfOppoSmallRegion;
				bool IsSuccess = FPolygonAlg::LocateLightsOfSmallRegion(LocalRegion, LightsOfOppoSmallRegion, WallHeight, CuttingHeight);
				if (IsSuccess)
				{
					TArray<AFurnitureModelActor*> TempModelsOfOppoRegion;
					FindModelsOfRoom(WorldContextObject, LocalRegion, TempModelsOfOppoRegion);

					TArray<FVector> UpdateLightsOfOppoSmallRegion;
					bool FilterLightLocs = FPolygonAlg::FilterLights(LightsOfOppoSmallRegion, LocalRegion, UpdateLightsOfOppoSmallRegion, FilterDisBound);
					if (FilterLightLocs)
					{
						for (int _CurLight = 0; _CurLight < UpdateLightsOfOppoSmallRegion.Num(); ++_CurLight)
						{
							if (FPolygonAlg::JudgePointInPolygon(LivingRoomPs, FVector2D(UpdateLightsOfOppoSmallRegion[_CurLight])))
							{
								if (TempModelsOfOppoRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < TempModelsOfOppoRegion.Num(); ++_CurM)
									{
										FBox TempBox = TempModelsOfOppoRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(UpdateLightsOfOppoSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalIndexsOfOppoRegion.AddUnique(_CurLight);
										}

									}
								}
								if (ModelsInRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
									{
										FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(UpdateLightsOfOppoSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalIndexsOfOppoRegion.AddUnique(_CurLight);
										}

									}
								}
								if (!LocalIndexsOfOppoRegion.Contains(_CurLight))
								{
									LivingRegionLights.AddUnique(UpdateLightsOfOppoSmallRegion[_CurLight]);
								}
							}
							if (FPolygonAlg::JudgePointInPolygon(DiningRoomPs, FVector2D(UpdateLightsOfOppoSmallRegion[_CurLight])))
							{
								if (TempModelsOfOppoRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < TempModelsOfOppoRegion.Num(); ++_CurM)
									{
										FBox TempBox = TempModelsOfOppoRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(UpdateLightsOfOppoSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalIndexsOfOppoRegion.AddUnique(_CurLight);
										}

									}
								}

								if (ModelsInRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
									{
										FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(UpdateLightsOfOppoSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalIndexsOfOppoRegion.AddUnique(_CurLight);
										}

									}
								}

								if (!LocalIndexsOfOppoRegion.Contains(_CurLight))
								{
									DiningRegionLights.AddUnique(UpdateLightsOfOppoSmallRegion[_CurLight]);
								}
							}
						}
					}

				}

			}
		}
	}


	if ((ThirdRoomPs.Num() != 0) && (FourthRoomPs.Num() != 0))
	{
		bool IfConnected2 = FPolygonAlg::JudgeHasClosePoint(ThirdRoomPs, FourthRoomPs);
		if (IfConnected2)
		{
			int NumOfThirdPs = ThirdRoomPs.Num();
			int NumOfFourthPs = FourthRoomPs.Num();
			TArray<FVector2D> TempAreaPs, LocalRegion;
			TArray<FVector> LocationOfLights, LocalLights;
			if (NumOfThirdPs > NumOfFourthPs)
			{
				TempAreaPs = ThirdRoomPs;
				LocalRegion = FourthRoomPs;
			}
			else
			{
				TempAreaPs = FourthRoomPs;
				LocalRegion = ThirdRoomPs;
			}
			TArray<AFurnitureModelActor*> ModelsInRegion;
			FindModelsOfRoom(WorldContextObject, TempAreaPs, ModelsInRegion);

			bool IsSuccessful = FPolygonAlg::LocateLightsOfPassageAndVestibule(TempAreaPs, LocationOfLights, WallHeight, CuttingHeight);
			if (IsSuccessful)
			{
				TArray<int> LocalRemoveIndexs;
				for (int _CurLight = 0; _CurLight < LocationOfLights.Num(); ++_CurLight)
				{
					if (FPolygonAlg::JudgePointInPolygon(ThirdRoomPs, FVector2D(LocationOfLights[_CurLight])))
					{
						if (ModelsInRegion.Num() != 0)
						{
							for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
							{
								FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
								bool IfInModel = TempBox.IsInsideOrOn(LocationOfLights[_CurLight]);
								if (IfInModel)
								{
									LocalRemoveIndexs.AddUnique(_CurLight);
								}

							}
						}

						if (!LocalRemoveIndexs.Contains(_CurLight))
						{
							ThirdLights.AddUnique(LocationOfLights[_CurLight]);
						}
					}
					if (FPolygonAlg::JudgePointInPolygon(FourthRoomPs, FVector2D(LocationOfLights[_CurLight])))
					{
						if (ModelsInRegion.Num() != 0)
						{
							for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
							{
								FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
								bool IfInModel = TempBox.IsInsideOrOn(LocationOfLights[_CurLight]);
								if (IfInModel)
								{
									LocalRemoveIndexs.AddUnique(_CurLight);
								}

							}
						}

						if (!LocalRemoveIndexs.Contains(_CurLight))
						{
							FourthLights.AddUnique(LocationOfLights[_CurLight]);
						}
					}
				}
				///////////////////////////计算局部小区域的灯的位置//////////////////////
				TArray<int> LocalIndexs;
				TArray<FVector> LightsLocOfSmallRegion;
				bool LocateSuccess = FPolygonAlg::LocateLightsOfSmallRegion(LocalRegion, LightsLocOfSmallRegion, WallHeight, CuttingHeight);
				if (LocateSuccess)
				{
					TArray<AFurnitureModelActor*> TempModelsInRegion;
					FindModelsOfRoom(WorldContextObject, LocalRegion, TempModelsInRegion);
					for (int _CurLight = 0; _CurLight < LightsLocOfSmallRegion.Num(); ++_CurLight)
					{
						if (FPolygonAlg::JudgePointInPolygon(ThirdRoomPs, FVector2D(LightsLocOfSmallRegion[_CurLight])))
						{
							if (TempModelsInRegion.Num() != 0)
							{
								for (int _CurM = 0; _CurM < TempModelsInRegion.Num(); ++_CurM)
								{
									FBox TempBox = TempModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
									bool IfInModel = TempBox.IsInsideOrOn(LightsLocOfSmallRegion[_CurLight]);
									if (IfInModel)
									{
										LocalIndexs.AddUnique(_CurLight);
									}
								}
							}
							if (ModelsInRegion.Num() != 0)
							{
								for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
								{
									FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
									bool IfInModel = TempBox.IsInsideOrOn(LightsLocOfSmallRegion[_CurLight]);
									if (IfInModel)
									{
										LocalIndexs.AddUnique(_CurLight);
									}

								}
							}
							if (!LocalIndexs.Contains(_CurLight))
							{
								ThirdLights.AddUnique(LightsLocOfSmallRegion[_CurLight]);
							}
						}

						if (FPolygonAlg::JudgePointInPolygon(FourthRoomPs, FVector2D(LightsLocOfSmallRegion[_CurLight])))
						{
							if (TempModelsInRegion.Num() != 0)
							{
								for (int _CurM = 0; _CurM < TempModelsInRegion.Num(); ++_CurM)
								{
									FBox TempBox = TempModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
									bool IfInModel = TempBox.IsInsideOrOn(LightsLocOfSmallRegion[_CurLight]);
									if (IfInModel)
									{
										LocalIndexs.AddUnique(_CurLight);
									}
								}
							}
							if (ModelsInRegion.Num() != 0)
							{
								for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
								{
									FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
									bool IfInModel = TempBox.IsInsideOrOn(LightsLocOfSmallRegion[_CurLight]);
									if (IfInModel)
									{
										LocalIndexs.AddUnique(_CurLight);
									}

								}
							}
							if (!LocalIndexs.Contains(_CurLight))
							{
								FourthLights.AddUnique(LightsLocOfSmallRegion[_CurLight]);
							}
						}

					}
				}

			}
			else
			{
				TArray<int> LocalRemoveIndexs;
				TArray<FVector> LightsLocOfSmallRegion;
				bool LocateSuccess = FPolygonAlg::LocateLightsOfSmallRegion(TempAreaPs, LightsLocOfSmallRegion, WallHeight, CuttingHeight);
				if (LocateSuccess)
				{
					TArray<AFurnitureModelActor*> TempModelsInRegion;
					FindModelsOfRoom(WorldContextObject, LocalRegion, TempModelsInRegion);
					for (int _CurLight = 0; _CurLight < LightsLocOfSmallRegion.Num(); ++_CurLight)
					{
						if (FPolygonAlg::JudgePointInPolygon(ThirdRoomPs, FVector2D(LightsLocOfSmallRegion[_CurLight])))
						{
							if (ModelsInRegion.Num() != 0)
							{
								for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
								{
									FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
									bool IfInModel = TempBox.IsInsideOrOn(LightsLocOfSmallRegion[_CurLight]);
									if (IfInModel)
									{
										LocalRemoveIndexs.AddUnique(_CurLight);
									}

								}
							}
							if (TempModelsInRegion.Num() != 0)
							{
								for (int _CurM = 0; _CurM < TempModelsInRegion.Num(); ++_CurM)
								{
									FBox TempBox = TempModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
									bool IfInModel = TempBox.IsInsideOrOn(LightsLocOfSmallRegion[_CurLight]);
									if (IfInModel)
									{
										LocalRemoveIndexs.AddUnique(_CurLight);
									}
								}
							}
							if (!LocalRemoveIndexs.Contains(_CurLight))
							{
								{
									ThirdLights.AddUnique(LightsLocOfSmallRegion[_CurLight]);
								}
							}
							if (FPolygonAlg::JudgePointInPolygon(FourthRoomPs, FVector2D(LightsLocOfSmallRegion[_CurLight])))
							{
								if (ModelsInRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
									{
										FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(LightsLocOfSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalRemoveIndexs.AddUnique(_CurLight);
										}

									}
								}
								if (TempModelsInRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < TempModelsInRegion.Num(); ++_CurM)
									{
										FBox TempBox = TempModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(LightsLocOfSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalRemoveIndexs.AddUnique(_CurLight);
										}
									}
								}
								if (!LocalRemoveIndexs.Contains(_CurLight))
								{
									FourthLights.AddUnique(LightsLocOfSmallRegion[_CurLight]);
								}
							}
						}
					}

					///////////////计算另一区域的小区域内的灯/////////////////////////////////////
					TArray<int> LocalIndexsOfOppoRegion;
					TArray<FVector> LightsOfOppoSmallRegion;
					bool IsSuccess = FPolygonAlg::LocateLightsOfSmallRegion(LocalRegion, LightsOfOppoSmallRegion, WallHeight, CuttingHeight);
					if (IsSuccess)
					{
						TArray<AFurnitureModelActor*> TempModelsOfOppoRegion;
						FindModelsOfRoom(WorldContextObject, LocalRegion, TempModelsOfOppoRegion);
						for (int _CurLight = 0; _CurLight < LightsOfOppoSmallRegion.Num(); ++_CurLight)
						{
							if (FPolygonAlg::JudgePointInPolygon(ThirdRoomPs, FVector2D(LightsOfOppoSmallRegion[_CurLight])))
							{
								if (TempModelsOfOppoRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < TempModelsOfOppoRegion.Num(); ++_CurM)
									{
										FBox TempBox = TempModelsOfOppoRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(LightsOfOppoSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalIndexsOfOppoRegion.AddUnique(_CurLight);
										}

									}
								}
								if (ModelsInRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
									{
										FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(LightsOfOppoSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalIndexsOfOppoRegion.AddUnique(_CurLight);
										}

									}
								}
								if (!LocalIndexsOfOppoRegion.Contains(_CurLight))
								{
									ThirdLights.AddUnique(LightsOfOppoSmallRegion[_CurLight]);
								}
							}
							if (FPolygonAlg::JudgePointInPolygon(DiningRoomPs, FVector2D(LightsOfOppoSmallRegion[_CurLight])))
							{
								if (TempModelsOfOppoRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < TempModelsOfOppoRegion.Num(); ++_CurM)
									{
										FBox TempBox = TempModelsOfOppoRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(LightsOfOppoSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalIndexsOfOppoRegion.AddUnique(_CurLight);
										}

									}
								}

								if (ModelsInRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
									{
										FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(LightsOfOppoSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalIndexsOfOppoRegion.AddUnique(_CurLight);
										}

									}
								}

								if (!LocalIndexsOfOppoRegion.Contains(_CurLight))
								{
									FourthLights.AddUnique(LightsOfOppoSmallRegion[_CurLight]);
								}
							}
						}
					}

				}
			}
		}
	}
	if (LivingRegionLights.Num() != 0)
	{
		FRegionLights TempLights;
		for (int I = 0; I < LivingRegionLights.Num(); ++I)
		{
			FIntelligentLight LocalLight;
			LocalLight.Loc = LivingRegionLights[I];
			TempLights.LightInfo.Add(LocalLight);
		}
		RoomIDMapRegionLights.Add(LivingRoomID, TempLights);
		TotalLights.Add(TempLights);
	}

	if (DiningRegionLights.Num() != 0)
	{
		FRegionLights TempLights;
		for (int I = 0; I < DiningRegionLights.Num(); ++I)
		{
			FIntelligentLight LocalLight;
			LocalLight.Loc = DiningRegionLights[I];
			TempLights.LightInfo.Add(LocalLight);
		}
		RoomIDMapRegionLights.Add(DiningRoomID, TempLights);
		TotalLights.Add(TempLights);
	}

	if (ThirdLights.Num() != 0)
	{
		FRegionLights TempLights;
		for (int I = 0; I < ThirdLights.Num(); ++I)
		{
			FIntelligentLight LocalLight;
			LocalLight.Loc = ThirdLights[I];
			TempLights.LightInfo.Add(LocalLight);
		}
		RoomIDMapRegionLights.Add(ThirdRoomID, TempLights);
		TotalLights.Add(TempLights);
	}

	if (FourthLights.Num() != 0)
	{
		FRegionLights TempLights;
		for (int I = 0; I < FourthLights.Num(); ++I)
		{
			FIntelligentLight LocalLight;
			LocalLight.Loc = FourthLights[I];
			TempLights.LightInfo.Add(LocalLight);
		}
		RoomIDMapRegionLights.Add(FourthRoomID, TempLights);
		TotalLights.Add(TempLights);
	}

	TArray<AActor*> PointLights, SpotLights, UniqueSpotLights;
	UWorld* MyWorld = WorldContextObject->GetWorld();
	TMap<int, TArray<AActor*>> RoomIDMapOldLights;
	TArray<int> PointgLightsIndex, SpotLightsIndexs;
	if (MyWorld)
	{
		bool GetLightsSuccess = GetAllLightsInWorld(MyWorld, PointLights, SpotLights, UniqueSpotLights, OldLightsArr);
		if (GetLightsSuccess)
		{
			for (int _CurRegion = 0; _CurRegion < RoomIDs.Num(); ++_CurRegion)
			{

				if (RoomIDMapRoomPs.Contains(RoomIDs[_CurRegion]))
				{
					TArray<FVector2D> RegionPs = RoomIDMapRoomPs[RoomIDs[_CurRegion]];
					TArray<AActor*> TempGroupLights;
					for (int _CurLight = 0; _CurLight < PointLights.Num(); ++_CurLight)
					{
						if (!PointgLightsIndex.Contains(_CurLight))
						{
							FVector EachLightLoc = PointLights[_CurLight]->GetActorLocation();
							bool IsInRegion = FPolygonAlg::JudgePointInPolygon(RegionPs, FVector2D(EachLightLoc.X, EachLightLoc.Y));
							if (IsInRegion)
							{
								PointgLightsIndex.Add(_CurLight);
								TempGroupLights.Add(PointLights[_CurLight]);
							}
						}
					}
					for (int _CurSpotLight = 0; _CurSpotLight < UniqueSpotLights.Num(); ++_CurSpotLight)
					{
						if (!SpotLightsIndexs.Contains(_CurSpotLight))
						{
							FVector EachLightLoc = UniqueSpotLights[_CurSpotLight]->GetActorLocation();
							bool IsInRegion = FPolygonAlg::JudgePointInPolygon(RegionPs, FVector2D(EachLightLoc.X, EachLightLoc.Y));
							if (IsInRegion)
							{
								SpotLightsIndexs.Add(_CurSpotLight);
								TempGroupLights.Add(UniqueSpotLights[_CurSpotLight]);
							}
						}
					}

					if (TempGroupLights.Num() != 0)
					{
						RoomIDMapOldLights.Add(RoomIDs[_CurRegion], TempGroupLights);
					}
				}

			}
		}
	}

	for (int _CurRoomIndex = 0; _CurRoomIndex < RoomIDs.Num(); ++_CurRoomIndex)
	{
		if ((RoomIDMapOldLights.Contains(RoomIDs[_CurRoomIndex])) && (RoomIDMapRegionLights.Contains(RoomIDs[_CurRoomIndex])))
		{
			FRegionLights TempNewLights;
			TempNewLights.LightInfo = RoomIDMapRegionLights[RoomIDs[_CurRoomIndex]].LightInfo;
			TempNewLights.RegionRoomId = RoomIDs[_CurRoomIndex];
			AllRegionLights.Add(TempNewLights);
		}
		else if ((!RoomIDsToRemove.Contains(RoomIDs[_CurRoomIndex])) && (RoomIDMapRegionLights.Contains(RoomIDs[_CurRoomIndex])))
		{
			FRegionLights TempNewLights;
			TempNewLights.LightInfo = RoomIDMapRegionLights[RoomIDs[_CurRoomIndex]].LightInfo;
			TempNewLights.RegionRoomId = RoomIDs[_CurRoomIndex];
			AllRegionLights.Add(TempNewLights);
		}
	}
	return true;
}


bool UWriteMeshObj_FunctionLibrary::WriteLightsLocToFile(UObject* WorldContextObject, TArray<FVector> TotalLights, const FString FilePath, const FString FileName)
{
	if ((*FilePath == NULL) || (*FileName == NULL))
	{
		return false;
	}

	FString ObjFileName = FilePath + FileName + "_locationPs.OFF";
	std::ofstream OutFile(*ObjFileName);
	OutFile << "OFF" << std::endl;
	OutFile << TotalLights.Num() << " " << 0 << " " << 0 << std::endl;
	for (int Index = 0; Index < TotalLights.Num(); Index++)
	{
		OutFile << TotalLights[Index].X << " " << TotalLights[Index].Y << " " << TotalLights[Index].Z << std::endl;

	}
	OutFile.close();
	return true;
}


bool  UWriteMeshObj_FunctionLibrary::GetAllLightsInWorld(UWorld* MyWorld, TArray<AActor*>&PointLights, TArray<AActor*>&SpotLights,
	TArray<AActor*>&UniqueSpotLight, TArray<FOldSceneLights>&OldLights)
{
	if (!MyWorld)
	{
		return false;
	}


	for (FActorIterator It(MyWorld); It; ++It)
	{
		AActor *ThisActor = *It;
		if (AFurnitureModelActor* LocalActor = Cast<AFurnitureModelActor>(ThisActor))
		{
			TArray<UActorComponent *> LightComponents = ThisActor->GetComponentsByClass(ULightComponent::StaticClass());
			for (int LightIndex = 0; LightIndex < LightComponents.Num(); ++LightIndex)
			{
				UActorComponent *Comp = LightComponents[LightIndex];
				if (USpotLightComponent *TempCom = Cast<USpotLightComponent>(Comp))
				{
					if (TempCom->bHiddenInGame)
					{
						continue;
					}
					FOldSceneLights TempOldLight;
					TempOldLight.LightActor = ThisActor;
					TempOldLight.Col = TempCom->GetLightColor();
					TempOldLight.Intensity = TempCom->Intensity;
					TempOldLight.Trans = TempCom->GetComponentTransform();
					TempOldLight.Radius = TempCom->AttenuationRadius;
					TempOldLight.Length = TempCom->SourceLength;
					TempOldLight.InnerConeAngle = TempCom->InnerConeAngle;
					TempOldLight.OuterConeAngle = TempCom->OuterConeAngle;
					TempOldLight.IsPointLight = false;
					SpotLights.Add(ThisActor);
					UniqueSpotLight.AddUnique(ThisActor);
					OldLights.Add(TempOldLight);
				}
				else if (UPointLightComponent *TempCom = Cast<UPointLightComponent>(Comp))
				{
					if (TempCom->bHiddenInGame)
					{
						continue;
					}
					FOldSceneLights TempOldLight;
					TempOldLight.LightActor = ThisActor;
					TempOldLight.Col = TempCom->GetLightColor();
					TempOldLight.Intensity = TempCom->Intensity;
					TempOldLight.Trans = TempCom->GetComponentTransform();
					TempOldLight.Radius = TempCom->AttenuationRadius;
					TempOldLight.Length = TempCom->SourceLength;
					TempOldLight.IsPointLight = true;

					PointLights.Add(ThisActor);
					OldLights.Add(TempOldLight);
				}

			}
		}

	}
	return true;
}


void UWriteMeshObj_FunctionLibrary::FindModelsOfRoom(UObject* WorldContextObject, const TArray<FVector2D> RegionPs, TArray<AFurnitureModelActor*>&ModelsOfRoom)
{
	if (RegionPs.Num() == 0)
	{
		return;
	}

	UCEditorGameInstance *GameInst = Cast<UCEditorGameInstance>(WorldContextObject->GetWorld()->GetGameInstance());
	const auto& ModelsInWorld = GameInst->ModelSystem->GetModelsInWorld();

	for (const auto ModelInW : ModelsInWorld)
	{
		if (ModelInW != nullptr)
		{
			const FBox ModelBoundingBox = ModelInW->GetComponentsBoundingBox(true);
			FVector2D ModelCenter = FVector2D(ModelBoundingBox.GetCenter());
			bool JudegIfInRegion = FPolygonAlg::JudgePointOnOrInPolygon(RegionPs, ModelCenter);
			if (JudegIfInRegion)
			{
				ModelsOfRoom.Add(ModelInW);
			}
		}
	}
	
}

void UWriteMeshObj_FunctionLibrary::FindCustomModelsOfRoom(UObject* WorldContextObject, const TArray<FVector2D> RegionPs, TArray<AHouseCustomActor*>&CustomModelsOfRoom)
{
	TArray<AActor*> _CustomActors;
	UGameplayStatics::GetAllActorsOfClass(WorldContextObject->GetWorld(), AHouseCustomActor::StaticClass(), _CustomActors);
	for (int _CurM = 0; _CurM < _CustomActors.Num(); ++_CurM)
	{
		AHouseCustomActor * _CustomModel = Cast<AHouseCustomActor>(_CustomActors[_CurM]);
		const FBox ModelBox = _CustomModel->GetComponentsBoundingBox(true);
		FVector2D ModelCenter = FVector2D(ModelBox.GetCenter());
		bool JudegIfInRegion = FPolygonAlg::JudgePointOnOrInPolygon(RegionPs, ModelCenter);
		if (JudegIfInRegion)
		{
			CustomModelsOfRoom.Add(_CustomModel);
		}
	}

}
bool UWriteMeshObj_FunctionLibrary::JudgeLightInExtendedBox(UObject* WorldContextObject, const TArray<FVector2D> RegionPs, const FVector InPoint, AFurnitureModelActor* FurModel, const float MaxLengthExtend)
{
	FBox TempBox = FurModel->GetComponentsBoundingBox(true);
	FVector FMin = TempBox.Min;
	FVector FMax = TempBox.Max;
	bool IfInModel = TempBox.IsInsideOrOn(InPoint);

	if (IfInModel)
	{
		bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, RegionPs);
		if (ModelBoxIsUseful)
		{
			return true;
		}
	}
	else
	{
		float ZPos = FMax.Z - FMin.Z;
		if (ZPos >= 215)
		{
			float ExtendScale = 1.0;
			float HalfWidth = 0.0;
			FVector2D P1(FMin.X, FMin.Y);
			FVector2D P2(FMax.X, FMin.Y);
			FVector2D P3(FMax.X, FMax.Y);
			FVector2D P4(FMin.X, FMax.Y);
			FVector2D TempCenter = 0.25*(P1 + P2 + P3 + P4);
			float P1ToP2 = FVector2D::Distance(P1, P2);
			float P2ToP3 = FVector2D::Distance(P2, P3);
			bool IsUseful = false;
			if ((P1ToP2 > P2ToP3) && (P2ToP3 > 40))
			{
				HalfWidth = 0.5*P2ToP3;
				IsUseful = true;
			}
			else if ((P1ToP2 <= P2ToP3) && (P1ToP2 > 40))
			{
				HalfWidth = 0.5*P1ToP2;
				IsUseful = true;
			}
			if (IsUseful)
			{
				ExtendScale = (HalfWidth + MaxLengthExtend) / HalfWidth;
				FVector2D UpdateP1 = (1 - ExtendScale)*TempCenter + ExtendScale * P1;
				FVector2D UpdateP2 = (1 - ExtendScale)*TempCenter + ExtendScale * P2;
				FVector2D UpdateP3 = (1 - ExtendScale)*TempCenter + ExtendScale * P3;
				FVector2D UpdateP4 = (1 - ExtendScale)*TempCenter + ExtendScale * P4;
				TArray<FVector2D> ExtendPolygon;
				ExtendPolygon.Add(UpdateP1);
				ExtendPolygon.Add(UpdateP2);
				ExtendPolygon.Add(UpdateP3);
				ExtendPolygon.Add(UpdateP4);
				bool IsInPolygon = FPolygonAlg::JudgePointOnOrInPolygon(ExtendPolygon, FVector2D(InPoint));
				if (IsInPolygon)
				{
					return true;
				}
			}
			else
			{
				return false;
			}
		}
		else
		{
			return false;
		}
	}
	return false;
}


bool  UWriteMeshObj_FunctionLibrary::LocationOfDownLights(const TArray<FVector2D> RegionPs, const float LightEqualSpace, const int NumOfLights, TArray<FVector2D>&LightsLocation)
{
	bool IsSuccess = FPolygonAlg::DownLightsLocation(RegionPs, LightEqualSpace, NumOfLights, LightsLocation);
	return IsSuccess;
}



bool UWriteMeshObj_FunctionLibrary::SeperateRoomsIntoGroups(UObject* WorldContextObject, UVaRestJsonObject* InJson, TArray<FRoomGroup>&RoomGroups)
{
	if (InJson == nullptr)
	{
		return false;
	}
	TArray<UVaRestJsonObject*> RoomJsonObj = InJson->GetObjectArrayField("roomList");
	TMap<int, FString> RoomIDMapName;
	TArray<int> AllRoomIDs;
	TMap<int, FString> RoomIDMapUseageName;
	TArray<TArray<FVector2D>> AllRegions;
	TMap<int, TArray<FVector2D>> RoomIDMapRegions;
	for (int RoomIndex = 0; RoomIndex < RoomJsonObj.Num(); RoomIndex++)
	{
		UVaRestJsonObject* NewRoomJson = NewObject<UVaRestJsonObject>();
		TArray<UVaRestJsonObject*> EachRoomRegion = RoomJsonObj[RoomIndex]->GetObjectArrayField("areas");
		TArray<FVector2D> TempRegionPs;
		int RoomId = RoomJsonObj[RoomIndex]->GetIntegerField("roomId");
		AllRoomIDs.Add(RoomId);
		for (int NumIndex = 0; NumIndex < EachRoomRegion.Num(); NumIndex++)
		{
			float TempX = EachRoomRegion[NumIndex]->GetNumberField("x");
			float TempY = EachRoomRegion[NumIndex]->GetNumberField("y");
			TempRegionPs.AddUnique(FVector2D(TempX, TempY));
		}
		AllRegions.Add(TempRegionPs);
		FString RoomName = RoomJsonObj[RoomIndex]->GetStringField("roomName");
		RoomIDMapRegions.Add(RoomId, TempRegionPs);
		RoomIDMapName.Add(RoomId, RoomName);
		FString RoomUsageName = RoomJsonObj[RoomIndex]->GetStringField("roomUsageName");
		RoomIDMapUseageName.Add(RoomId, RoomUsageName);
	}
	TArray<int> TempGroups;
	TArray<int> HasCollectedRoomIDs;
	for (int _CurI = 0; _CurI < AllRoomIDs.Num(); ++_CurI)
	{
		if ((RoomIDMapUseageName[AllRoomIDs[_CurI]].Contains(TEXT("客厅"))) || (RoomIDMapUseageName[AllRoomIDs[_CurI]].Contains(TEXT("餐厅"))) || (RoomIDMapUseageName[AllRoomIDs[_CurI]].Contains(TEXT("主卧"))))
		{
			TempGroups.AddUnique(AllRoomIDs[_CurI]);
			HasCollectedRoomIDs.AddUnique(AllRoomIDs[_CurI]);
			break;
		}
	}

	if (TempGroups.Num() == 1)
	{
		TArray<FVector2D> WallPoints;
		bool GetWallSuccess = GetWallPointsOfRoom(WorldContextObject, TempGroups[0], WallPoints);
		if (GetWallSuccess)
		{
			int NumOfWalls = WallPoints.Num() / 4;

			if (NumOfWalls > 0)
			{
				for (int _CurWall = 0; _CurWall < NumOfWalls; ++_CurWall)
				{
					FVector2D TempWallCenter = 0.25*(WallPoints[4 * _CurWall] + WallPoints[4 * _CurWall + 1] + WallPoints[4 * _CurWall + 2] + WallPoints[4 * _CurWall + 3]);
					FVector2D TempDir = WallPoints[4 * _CurWall + 1] - WallPoints[4 * _CurWall];
					TempDir = TempDir.GetSafeNormal();
					FVector2D TempRotatedDir = TempDir.GetRotated(90);
					FVector2D TestNode1 = TempWallCenter + 30 * TempRotatedDir;
					FVector2D TestNode2 = TempWallCenter - 30 * TempRotatedDir;
					for (int _CurRoom = 0; _CurRoom < AllRoomIDs.Num(); ++_CurRoom)
					{
						if (!HasCollectedRoomIDs.Contains(AllRoomIDs[_CurRoom]))
						{
							if ((FPolygonAlg::JudgePointInPolygon(RoomIDMapRegions[AllRoomIDs[_CurRoom]], TestNode1)) ||
								(FPolygonAlg::JudgePointInPolygon(RoomIDMapRegions[AllRoomIDs[_CurRoom]], TestNode2)))
							{
								TempGroups.AddUnique(AllRoomIDs[_CurRoom]);
								HasCollectedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
							}
						}
					}

				}
			}
		}
	}

	if (TempGroups.Num() >= 2)
	{
		int NumOfState1 = TempGroups.Num();
		int NumOfState2 = 0;
		while (NumOfState1 != NumOfState2)
		{
			TArray<int> CopyArrs = TempGroups;
			NumOfState1 = CopyArrs.Num();
			for (int I = 0; I < CopyArrs.Num(); ++I)
			{
				TArray<FVector2D> WallPoints;
				bool GetWallSuccess = GetWallPointsOfRoom(WorldContextObject, CopyArrs[I], WallPoints);
				if (GetWallSuccess)
				{
					int NumOfWalls = WallPoints.Num() / 4;
					if (NumOfWalls > 0)
					{
						for (int _CurWall = 0; _CurWall < NumOfWalls; ++_CurWall)
						{
							FVector2D TempWallCenter = 0.25*(WallPoints[4 * _CurWall] + WallPoints[4 * _CurWall + 1] + WallPoints[4 * _CurWall + 2] + WallPoints[4 * _CurWall + 3]);
							FVector2D TempDir = WallPoints[4 * _CurWall + 1] - WallPoints[4 * _CurWall];
							TempDir = TempDir.GetSafeNormal();
							FVector2D TempRotatedDir = TempDir.GetRotated(90);
							FVector2D TestNode1 = TempWallCenter + 30 * TempRotatedDir;
							FVector2D TestNode2 = TempWallCenter - 30 * TempRotatedDir;
							for (int _CurRoom = 0; _CurRoom < AllRoomIDs.Num(); ++_CurRoom)
							{
								if (!HasCollectedRoomIDs.Contains(AllRoomIDs[_CurRoom]))
								{
									if ((FPolygonAlg::JudgePointInPolygon(RoomIDMapRegions[AllRoomIDs[_CurRoom]], TestNode1)) ||
										(FPolygonAlg::JudgePointInPolygon(RoomIDMapRegions[AllRoomIDs[_CurRoom]], TestNode2)))
									{
										TempGroups.AddUnique(AllRoomIDs[_CurRoom]);
										HasCollectedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
									}
								}
							}

						}
					}
				}
			}
			NumOfState2 = TempGroups.Num();
		}
	}
	FRoomGroup TempRoomGroup;
	TempRoomGroup.RoomIDs = TempGroups;
	RoomGroups.Add(TempRoomGroup);

	TempGroups.Empty();

	while (HasCollectedRoomIDs.Num() != AllRoomIDs.Num())
	{
		for (int _CurJ = 0; _CurJ < AllRoomIDs.Num(); ++_CurJ)
		{
			if (!HasCollectedRoomIDs.Contains(AllRoomIDs[_CurJ]))
			{
				TempGroups.AddUnique(AllRoomIDs[_CurJ]);
				HasCollectedRoomIDs.AddUnique(AllRoomIDs[_CurJ]);
				break;
			}
		}

		TArray<FVector2D> WallPoints;
		bool GetWallSuccess = GetWallPointsOfRoom(WorldContextObject, TempGroups[0], WallPoints);
		if (GetWallSuccess)
		{
			int NumOfWalls = WallPoints.Num() / 4;

			if (NumOfWalls > 0)
			{
				for (int _CurWall = 0; _CurWall < NumOfWalls; ++_CurWall)
				{
					FVector2D TempWallCenter = 0.25*(WallPoints[4 * _CurWall] + WallPoints[4 * _CurWall + 1] + WallPoints[4 * _CurWall + 2] + WallPoints[4 * _CurWall + 3]);
					FVector2D TempDir = WallPoints[4 * _CurWall + 1] - WallPoints[4 * _CurWall];
					TempDir = TempDir.GetSafeNormal();
					FVector2D TempRotatedDir = TempDir.GetRotated(90);
					FVector2D TestNode1 = TempWallCenter + 30 * TempRotatedDir;
					FVector2D TestNode2 = TempWallCenter - 30 * TempRotatedDir;
					for (int _CurRoom = 0; _CurRoom < AllRoomIDs.Num(); ++_CurRoom)
					{
						if (!HasCollectedRoomIDs.Contains(AllRoomIDs[_CurRoom]))
						{
							if ((FPolygonAlg::JudgePointInPolygon(RoomIDMapRegions[AllRoomIDs[_CurRoom]], TestNode1)) ||
								(FPolygonAlg::JudgePointInPolygon(RoomIDMapRegions[AllRoomIDs[_CurRoom]], TestNode2)))
							{
								TempGroups.AddUnique(AllRoomIDs[_CurRoom]);
								HasCollectedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
							}
						}
					}

				}
			}
		}

		if (TempGroups.Num() >= 2)
		{
			int NumOfState1 = TempGroups.Num();
			int NumOfState2 = 0;
			while (NumOfState1 != NumOfState2)
			{
				TArray<int> CopyArrs = TempGroups;
				NumOfState1 = CopyArrs.Num();
				for (int I = 0; I < CopyArrs.Num(); ++I)
				{
					TArray<FVector2D> WallPoints;
					bool GetWallSuccess = GetWallPointsOfRoom(WorldContextObject, CopyArrs[I], WallPoints);
					if (GetWallSuccess)
					{
						int NumOfWalls = WallPoints.Num() / 4;
						if (NumOfWalls > 0)
						{
							for (int _CurWall = 0; _CurWall < NumOfWalls; ++_CurWall)
							{
								FVector2D TempWallCenter = 0.25*(WallPoints[4 * _CurWall] + WallPoints[4 * _CurWall + 1] + WallPoints[4 * _CurWall + 2] + WallPoints[4 * _CurWall + 3]);
								FVector2D TempDir = WallPoints[4 * _CurWall + 1] - WallPoints[4 * _CurWall];
								TempDir = TempDir.GetSafeNormal();
								FVector2D TempRotatedDir = TempDir.GetRotated(90);
								FVector2D TestNode1 = TempWallCenter + 30 * TempRotatedDir;
								FVector2D TestNode2 = TempWallCenter - 30 * TempRotatedDir;
								for (int _CurRoom = 0; _CurRoom < AllRoomIDs.Num(); ++_CurRoom)
								{
									if (!HasCollectedRoomIDs.Contains(AllRoomIDs[_CurRoom]))
									{
										if ((FPolygonAlg::JudgePointInPolygon(RoomIDMapRegions[AllRoomIDs[_CurRoom]], TestNode1)) ||
											(FPolygonAlg::JudgePointInPolygon(RoomIDMapRegions[AllRoomIDs[_CurRoom]], TestNode2)))
										{
											TempGroups.AddUnique(AllRoomIDs[_CurRoom]);
											HasCollectedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
										}
									}
								}

							}
						}
					}
				}
				NumOfState2 = TempGroups.Num();
			}
		}
		FRoomGroup NewTempRoomGroup;
		NewTempRoomGroup.RoomIDs = TempGroups;
		RoomGroups.Add(NewTempRoomGroup);
		TempGroups.Empty();
	}

	return true;
}



bool UWriteMeshObj_FunctionLibrary::CreateDNALocationJsonWithCenters(UObject* WorldContextObject, UVaRestJsonObject* InJson, TArray<int> AreaIndexsToRemove,
	UVaRestJsonObject* &LocationJson, TArray<FVector2D>& CameraLocations2D, int& NumOfTotalPickPs)
{
	if (InJson == nullptr)
	{
		return false;
	}

	TArray<UVaRestJsonObject*> WallJsonObj = InJson->GetObjectArrayField("walls");
	TArray<Polygon_2> WallPolygon;
	TArray<FVector2D> WallCenters;
	TMap<int, TArray<FVector2D>> IndexMapWallPs;
	for (int Index = 0; Index < WallJsonObj.Num(); Index++)
	{
		TArray<FVector2D> WallRegionPoints;
		TArray<UVaRestJsonObject*> EachWallRegion = WallJsonObj[Index]->GetObjectArrayField("wallPoints");

		for (int WallIndex = 0; WallIndex < EachWallRegion.Num(); WallIndex++)
		{
			float TempX = EachWallRegion[WallIndex]->GetNumberField("x");
			float TempY = EachWallRegion[WallIndex]->GetNumberField("y");
			WallRegionPoints.Add(FVector2D(TempX, TempY));
		}
		IndexMapWallPs.Add(Index, WallRegionPoints);
		Polygon_2 TempWallPolygon;
		float WallCenterX = 0.0, WallCenterY = 0.0;
		for (int PIndex = 0; PIndex < 4; PIndex++)
		{
			TempWallPolygon.push_back(Point_2(WallRegionPoints[PIndex].X, WallRegionPoints[PIndex].Y));
			WallCenterX = WallCenterX + WallRegionPoints[PIndex].X;
			WallCenterY = WallCenterY + WallRegionPoints[PIndex].Y;
		}
		WallCenterX = WallCenterX / 4;
		WallCenterY = WallCenterY / 4;
		WallCenters.Add(FVector2D(WallCenterX, WallCenterY));
		WallPolygon.Add(TempWallPolygon);
		TempWallPolygon.clear();
	}


	TArray<FVector2D> CameraLocations;
	TArray<FVector2D> SmallRegionCenters, NewSmallRegionCenters, ThirdDiningSmallCenters, FourthDiningSmallCenters;
	TMap<int, FVector2D> RoomIDMapToiletSmallCenter;
	TArray<FString> RoomNameSet, RoomUsageNameSet;
	TArray<int> RoomIDs;
	TArray<float> UsageIDs;
	TArray<float> IDs;
	TArray<UVaRestJsonObject*> RoomJsonObj = InJson->GetObjectArrayField("roomList");


	TMap<int, TArray<FVector2D>> IndexMapRoomPs;
	int RemoveCount = 0;

	TMap<FVector2D, TArray<FVector2D>> PointMapLocalRegion;
	TMap<int, TArray<FVector2D>> RoomIdMapSmallCenters;
	TMap<int, TArray<FVector2D>> ToiletRoomIDMapSmallCenters;
	TMap<int, TArray<int>> RoomIDMapToRemoveIndexs;
	for (int Index = 0; Index < RoomJsonObj.Num(); Index++)
	{
		if (!AreaIndexsToRemove.Contains(Index))
		{
			TArray<FVector2D> AreaPoints;
			FVector2D SuitableCenter;
			TArray<UVaRestJsonObject*> AreaCoorJson = RoomJsonObj[Index]->GetObjectArrayField("areas");

			FString TempRoomNameString = RoomJsonObj[Index]->GetStringField("roomName");
			RoomNameSet.Add(TempRoomNameString);

			int TempRoomID = RoomJsonObj[Index]->GetIntegerField("roomId");
			RoomIDs.Add(TempRoomID);

			FString TempRoomUseString = RoomJsonObj[Index]->GetStringField("roomUsageName");
			RoomUsageNameSet.Add(TempRoomUseString);

			float TempUsageID = RoomJsonObj[Index]->GetNumberField("usageId");
			UsageIDs.Add(TempUsageID);

			IDs.Add(Index + 1);

			for (int AreaIndex = 0; AreaIndex < AreaCoorJson.Num(); AreaIndex++)
			{
				float TempX = AreaCoorJson[AreaIndex]->GetNumberField("x");
				float TempY = AreaCoorJson[AreaIndex]->GetNumberField("y");
				AreaPoints.AddUnique(FVector2D(TempX, TempY));
			}


			float VecX1 = AreaPoints[1].X - AreaPoints[0].X;
			float VecY1 = AreaPoints[1].Y - AreaPoints[0].Y;

			float VecX2 = AreaPoints[AreaPoints.Num() - 1].X;
			float VecY2 = AreaPoints[AreaPoints.Num() - 1].Y;
			float CrossResZ = VecX1 * VecY2 - VecY1 * VecX2;
			if (CrossResZ < 0)
			{
				for (int Jindex = 0; Jindex < AreaPoints.Num() / 2; Jindex++)
				{
					FVector2D TempVec = AreaPoints[Jindex];
					AreaPoints[Jindex] = AreaPoints[AreaPoints.Num() - 1 - Jindex];
					AreaPoints[AreaPoints.Num() - 1 - Jindex] = TempVec;
				}
			}


			FString LocalRoomName = RoomJsonObj[Index]->GetStringField("roomName");

			if ((LocalRoomName == TEXT("客厅")) || (LocalRoomName == TEXT("起居室")))
			{
				TMap<FVector2D, TArray<FVector2D>> TempCenterMapLocalRegions;
				SmallRegionCenters.Empty();
				bool IsSuccess = FPolygonAlg::LocateCentersOfDiningOrLivingRegion(AreaPoints, SuitableCenter, SmallRegionCenters, TempCenterMapLocalRegions);
				if (!IsSuccess)
				{
					return false;
				}
				CameraLocations.Add(SuitableCenter);
				RoomIdMapSmallCenters.Add(TempRoomID, SmallRegionCenters);
				if (TempCenterMapLocalRegions.Contains(SuitableCenter))
				{
					PointMapLocalRegion.Add(SuitableCenter, TempCenterMapLocalRegions[SuitableCenter]);
				}
				TArray<AFurnitureModelActor*> ModelsOfRoom;
				FindModelsOfRoom(WorldContextObject, AreaPoints, ModelsOfRoom);
				TArray<int> TempToRemoveIndexs;
				for (int _CurP = 0; _CurP < SmallRegionCenters.Num(); ++_CurP)
				{
					for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
					{
						FBox TempBox = ModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
						FString ModelName = ModelsOfRoom[_CurM]->GetName();
						if (!ModelName.Contains(FString("Light")))
						{
							bool IfInModel = TempBox.IsInsideOrOn(FVector(SmallRegionCenters[_CurP], 130));
							if (IfInModel)
							{
								FVector FMin = TempBox.Min;
								FVector FMax = TempBox.Max;
								bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
								if (ModelBoxIsUseful)
								{
									TempToRemoveIndexs.AddUnique(_CurP);
								}
							}
						}
					}
				}

				if (TempToRemoveIndexs.Num() > 0)
				{
					RoomIDMapToRemoveIndexs.Add(TempRoomID, TempToRemoveIndexs);
				}
				for (int _CurF = 0; _CurF < SmallRegionCenters.Num(); ++_CurF)
				{
					if (!TempToRemoveIndexs.Contains(_CurF))
					{
						if (TempCenterMapLocalRegions.Contains(SmallRegionCenters[_CurF]))
						{
							PointMapLocalRegion.Add(SmallRegionCenters[_CurF], TempCenterMapLocalRegions[SmallRegionCenters[_CurF]]);
						}
					}
				}
				NumOfTotalPickPs = NumOfTotalPickPs + SmallRegionCenters.Num() - TempToRemoveIndexs.Num();
			}
			else if (LocalRoomName == TEXT("餐厅"))
			{
				TMap<FVector2D, TArray<FVector2D>> TempCenterMapLocalRegions;
				NewSmallRegionCenters.Empty();
				bool IsSuccess = FPolygonAlg::LocateCentersOfDiningOrLivingRegion(AreaPoints, SuitableCenter, NewSmallRegionCenters, TempCenterMapLocalRegions);
				if (!IsSuccess)
				{
					return false;
				}
				CameraLocations.Add(SuitableCenter);
				RoomIdMapSmallCenters.Add(TempRoomID, NewSmallRegionCenters);
				if (TempCenterMapLocalRegions.Contains(SuitableCenter))
				{
					PointMapLocalRegion.Add(SuitableCenter, TempCenterMapLocalRegions[SuitableCenter]);
				}

				TArray<AFurnitureModelActor*> ModelsOfRoom;
				FindModelsOfRoom(WorldContextObject, AreaPoints, ModelsOfRoom);
				TArray<int> TempToRemoveIndexs;
				for (int _CurP = 0; _CurP < NewSmallRegionCenters.Num(); ++_CurP)
				{
					for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
					{
						FBox TempBox = ModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
						FString ModelName = ModelsOfRoom[_CurM]->GetName();
						if (!ModelName.Contains(FString("Light")))
						{
							bool IfInModel = TempBox.IsInsideOrOn(FVector(NewSmallRegionCenters[_CurP], 130));
							if (IfInModel)
							{
								FVector FMin = TempBox.Min;
								FVector FMax = TempBox.Max;
								bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
								if (ModelBoxIsUseful)
								{
									TempToRemoveIndexs.AddUnique(_CurP);
								}
							}
						}
					}
				}

				if (TempToRemoveIndexs.Num() > 0)
				{
					RoomIDMapToRemoveIndexs.Add(TempRoomID, TempToRemoveIndexs);
				}

				for (int _CurF = 0; _CurF < NewSmallRegionCenters.Num(); ++_CurF)
				{
					if (!TempToRemoveIndexs.Contains(_CurF))
					{
						if (TempCenterMapLocalRegions.Contains(NewSmallRegionCenters[_CurF]))
						{
							PointMapLocalRegion.Add(NewSmallRegionCenters[_CurF], TempCenterMapLocalRegions[NewSmallRegionCenters[_CurF]]);
						}
					}
				}
				NumOfTotalPickPs = NumOfTotalPickPs + NewSmallRegionCenters.Num() - TempToRemoveIndexs.Num();
			}
			else if ((LocalRoomName == TEXT("主卧")) || (LocalRoomName == TEXT("次卧")) || (LocalRoomName == TEXT("儿童房")) || (LocalRoomName == TEXT("老人房"))
				|| (LocalRoomName == TEXT("榻榻米房")) || (LocalRoomName == TEXT("客人房")) || (LocalRoomName == TEXT("书房")) || (LocalRoomName == TEXT("健身房"))
				|| (LocalRoomName == TEXT("多功能房")))
			{
				TArray<FVector2D> TempSmallCenters;
				TMap<FVector2D, TArray<FVector2D>> TempCenterMapLocalRegions;
				bool IsCreated = FPolygonAlg::LocateCentersOfRoom(AreaPoints, SuitableCenter, TempSmallCenters, TempCenterMapLocalRegions);
				if (!IsCreated)
				{
					return false;
				}
				RoomIdMapSmallCenters.Add(TempRoomID, TempSmallCenters);
				CameraLocations.Add(SuitableCenter);

				if (TempCenterMapLocalRegions.Contains(SuitableCenter))
				{
					PointMapLocalRegion.Add(SuitableCenter, TempCenterMapLocalRegions[SuitableCenter]);
				}


				TArray<AFurnitureModelActor*> ModelsOfRoom;
				FindModelsOfRoom(WorldContextObject, AreaPoints, ModelsOfRoom);
				TArray<int> ToRemoveSmallIndexs;
				for (int _CurP = 0; _CurP < TempSmallCenters.Num(); ++_CurP)
				{
					for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
					{
						FBox TempBox = ModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
						FString ModelName = ModelsOfRoom[_CurM]->GetName();
						if (!ModelName.Contains(FString("Light")))
						{
							bool IfInModel = TempBox.IsInsideOrOn(FVector(TempSmallCenters[_CurP], 130));
							if (IfInModel)
							{
								FVector FMin = TempBox.Min;
								FVector FMax = TempBox.Max;
								bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
								if (ModelBoxIsUseful)
								{
									ToRemoveSmallIndexs.AddUnique(_CurP);
								}
							}
						}
					}
				}

				///////////////////定制家具过滤/////////////////////
				TArray<AHouseCustomActor*> CustomModelsOfRoom;
				FindCustomModelsOfRoom(WorldContextObject, AreaPoints, CustomModelsOfRoom);
				for (int _CurP = 0; _CurP < TempSmallCenters.Num(); ++_CurP)
				{
					for (int _CurM = 0; _CurM < CustomModelsOfRoom.Num(); ++_CurM)
					{
						FBox TempBox = CustomModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
						FString ModelName = CustomModelsOfRoom[_CurM]->GetName();
						if (!ModelName.Contains(FString("Light")))
						{
							bool IfInModel = TempBox.IsInsideOrOn(FVector(TempSmallCenters[_CurP], 130));
							if (IfInModel)
							{
								FVector FMin = TempBox.Min;
								FVector FMax = TempBox.Max;
								bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
								if (ModelBoxIsUseful)
								{
									ToRemoveSmallIndexs.AddUnique(_CurP);
								}
							}
						}
					}
				}

				if (ToRemoveSmallIndexs.Num() > 0)
				{
					RoomIDMapToRemoveIndexs.Add(TempRoomID, ToRemoveSmallIndexs);
				}

				for (int _CurF = 0; _CurF < TempSmallCenters.Num(); ++_CurF)
				{
					if (!ToRemoveSmallIndexs.Contains(_CurF))
					{
						PointMapLocalRegion.Add(TempSmallCenters[_CurF], TempCenterMapLocalRegions[TempSmallCenters[_CurF]]);
					}
				}
				NumOfTotalPickPs = NumOfTotalPickPs + TempSmallCenters.Num() - ToRemoveSmallIndexs.Num();
			}
			else if ((LocalRoomName == TEXT("主阳台")) || (LocalRoomName == TEXT("生活阳台")) || (LocalRoomName == TEXT("休闲阳台")) || (LocalRoomName == TEXT("卧室阳台")))
			{
				TArray<FVector2D> TempSmallCenters;
				TMap<FVector2D, TArray<FVector2D>> TempCenterMapLocalRegions;
				bool IsCreated = FPolygonAlg::LocateCentersOfBalcony(AreaPoints, SuitableCenter, TempSmallCenters, TempCenterMapLocalRegions);
				if (!IsCreated)
				{
					return false;
				}
				RoomIdMapSmallCenters.Add(TempRoomID, TempSmallCenters);
				CameraLocations.Add(SuitableCenter);

				if (TempCenterMapLocalRegions.Contains(SuitableCenter))
				{
					PointMapLocalRegion.Add(SuitableCenter, TempCenterMapLocalRegions[SuitableCenter]);
				}
				TArray<AFurnitureModelActor*> ModelsOfRoom;
				FindModelsOfRoom(WorldContextObject, AreaPoints, ModelsOfRoom);
				TArray<int> ToRemoveSmallIndexs;
				for (int _CurP = 0; _CurP < TempSmallCenters.Num(); ++_CurP)
				{
					for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
					{
						FBox TempBox = ModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
						FString ModelName = ModelsOfRoom[_CurM]->GetName();
						if (!ModelName.Contains(FString("Light")))
						{
							bool IfInModel = TempBox.IsInsideOrOn(FVector(TempSmallCenters[_CurP], 130));
							if (IfInModel)
							{
								FVector FMin = TempBox.Min;
								FVector FMax = TempBox.Max;
								bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
								if (ModelBoxIsUseful)
								{
									ToRemoveSmallIndexs.AddUnique(_CurP);
								}
							}
						}
					}
				}

				if (ToRemoveSmallIndexs.Num() > 0)
				{
					RoomIDMapToRemoveIndexs.Add(TempRoomID, ToRemoveSmallIndexs);
				}

				for (int _CurF = 0; _CurF < TempSmallCenters.Num(); ++_CurF)
				{
					if (!ToRemoveSmallIndexs.Contains(_CurF))
					{
						PointMapLocalRegion.Add(TempSmallCenters[_CurF], TempCenterMapLocalRegions[TempSmallCenters[_CurF]]);
					}
				}
				NumOfTotalPickPs = NumOfTotalPickPs + TempSmallCenters.Num() - ToRemoveSmallIndexs.Num();
			}
			else if (LocalRoomName == TEXT("厨房"))
			{
				bool IsCreated = FPolygonAlg::LocateCenterOfKitchen(AreaPoints, SuitableCenter);
				if (!IsCreated)
				{
					return false;
				}
				bool IsUnUseful = false;
				TArray<AFurnitureModelActor*> TempModelsOfRoom;
				FindModelsOfRoom(WorldContextObject, AreaPoints, TempModelsOfRoom);
				for (int _CurM = 0; _CurM < TempModelsOfRoom.Num(); ++_CurM)
				{
					AFurnitureModelActor* TempFur = TempModelsOfRoom[_CurM];
					FBox TempBox = TempFur->GetComponentsBoundingBox(true);

					FString ModelName = TempFur->GetName();
					if (!ModelName.Contains(FString("Light")))
					{
						bool IsInModel = TempBox.IsInside(FVector(SuitableCenter, 130));
						if (IsInModel)
						{
							FVector FMin = TempBox.Min;
							FVector FMax = TempBox.Max;
							bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
							if (!ModelBoxIsUseful)
							{
								IsUnUseful = true;
							}
						}
					}
				}
				if (!IsUnUseful)
				{
					PointMapLocalRegion.Add(SuitableCenter, AreaPoints);
					CameraLocations.Add(SuitableCenter);
				}
				else
				{
					TArray<FVector>DoorPoints;
					bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomID, DoorPoints);
					if (!GetDoorSuccess)
					{
						PointMapLocalRegion.Add(SuitableCenter, AreaPoints);
						CameraLocations.Add(SuitableCenter);
					}
					else
					{
						TMap<int, TArray<FVector>> RoomIDMapHoleData;
						int NumOfDoors = DoorPoints.Num() / 8;
						RoomIDMapHoleData.Add(TempRoomID, DoorPoints);
						if (NumOfDoors >= 1)
						{
							FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
							FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
							DirVec = DirVec.GetSafeNormal();
							DirVec = DirVec.GetRotated(90);
							FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
							FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
							FVector2D TempVec1 = DoorCenter2D + 45 * DirVec;
							if (FPolygonAlg::JudgePointInPolygon(AreaPoints, TempVec1))
							{
								PointMapLocalRegion.Add(TempVec1, AreaPoints);
								CameraLocations.Add(TempVec1);
							}
							else
							{
								FVector2D TempP = DoorCenter2D - 45 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(AreaPoints, TempP))
								{
									PointMapLocalRegion.Add(TempP, AreaPoints);
									CameraLocations.Add(TempP);
								}
								else
								{
									PointMapLocalRegion.Add(SuitableCenter, AreaPoints);
									CameraLocations.Add(SuitableCenter);
								}
							}
						}
					}
				}

			}
			else if ((LocalRoomName == TEXT("主卫")) || (LocalRoomName == TEXT("客卫")) || (LocalRoomName == TEXT("卫生间")))
			{
				bool FindWall = false;
				int TargetIndex = 0;
				for (int _CurIndex = 0; _CurIndex < WallCenters.Num(); ++_CurIndex)
				{
					bool JudgeIfInRegion = FPolygonAlg::JudgePointInPolygon(AreaPoints, WallCenters[_CurIndex]);
					if (JudgeIfInRegion)
					{
						FindWall = true;
						TargetIndex = _CurIndex;
						break;
					}
				}

				if (FindWall)
				{
					TArray<int> LocalRemoveIndexs;
					TArray<FVector2D> PickCenters;
					TArray<FVector2D> WallPoints = IndexMapWallPs[TargetIndex];
					bool LocateSuccess = FPolygonAlg::LocateCentersOfSecondToilet(AreaPoints, WallPoints, PickCenters);
					if (LocateSuccess)
					{
						PointMapLocalRegion.Add(PickCenters[0], AreaPoints);
						PointMapLocalRegion.Add(PickCenters[1], AreaPoints);
						CameraLocations.Add(PickCenters[0]);
						TArray<FVector2D> TempToiletArr;
						TempToiletArr.Add(PickCenters[1]);
						ToiletRoomIDMapSmallCenters.Add(TempRoomID, TempToiletArr);
						NumOfTotalPickPs = NumOfTotalPickPs + 1;
					}
				}
				else
				{
					FVector2D TempLocateCenter;
					bool IsSuccess = FPolygonAlg::LocateCenterOfOneToilet(AreaPoints, TempLocateCenter);
					if (IsSuccess)
					{
						PointMapLocalRegion.Add(TempLocateCenter, AreaPoints);
						CameraLocations.Add(TempLocateCenter);
					}
				}
			}
			else if (LocalRoomName == TEXT("储藏间"))
			{
				FVector2D TempLoc;
				bool HasFound = FPolygonAlg::LocateSuitableCenter(AreaPoints, TempLoc);
				if (HasFound)
				{
					bool IsUnUseful = false;
					TArray<AFurnitureModelActor*> TempModelsOfRoom;
					FindModelsOfRoom(WorldContextObject, AreaPoints, TempModelsOfRoom);
					for (int _CurM = 0; _CurM < TempModelsOfRoom.Num(); ++_CurM)
					{
						AFurnitureModelActor* TempFur = TempModelsOfRoom[_CurM];
						FBox TempBox = TempFur->GetComponentsBoundingBox(true);
						FString ModelName = TempFur->GetName();
						if (!ModelName.Contains(FString("Light")))
						{
							bool IsInModel = TempBox.IsInside(FVector(TempLoc, 130));
							if (IsInModel)
							{
								IsUnUseful = true;
								break;
							}
						}
					}
					if (!IsUnUseful)
					{
						PointMapLocalRegion.Add(TempLoc, AreaPoints);
						CameraLocations.Add(TempLoc);
					}
					else
					{
						TArray<FVector>DoorPoints;
						bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomID, DoorPoints);
						if (!GetDoorSuccess)
						{
							PointMapLocalRegion.Add(TempLoc, AreaPoints);
							CameraLocations.Add(TempLoc);
						}
						else
						{
							TMap<int, TArray<FVector>> RoomIDMapHoleData;
							int NumOfDoors = DoorPoints.Num() / 8;
							RoomIDMapHoleData.Add(TempRoomID, DoorPoints);
							if (NumOfDoors >= 1)
							{
								FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
								FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
								DirVec = DirVec.GetSafeNormal();
								DirVec = DirVec.GetRotated(90);
								FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
								FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
								FVector2D TempVec1 = DoorCenter2D + 22 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(AreaPoints, TempVec1))
								{
									PointMapLocalRegion.Add(TempVec1, AreaPoints);
									CameraLocations.Add(TempVec1);
								}
								else
								{
									FVector2D TempP = DoorCenter2D - 22 * DirVec;
									if (FPolygonAlg::JudgePointInPolygon(AreaPoints, TempP))
									{
										PointMapLocalRegion.Add(TempP, AreaPoints);
										CameraLocations.Add(TempP);
									}
									else
									{
										PointMapLocalRegion.Add(TempLoc, AreaPoints);
										CameraLocations.Add(TempLoc);
									}
								}
							}
						}
					}
				}
			}
			else if ((LocalRoomName == TEXT("衣帽间")) || (LocalRoomName == TEXT("茶室")))
			{
				FVector2D TempLoc;
				bool HasFound = FPolygonAlg::LocateSuitableCenter(AreaPoints, TempLoc);
				if (HasFound)
				{
					bool IsUnUseful = false;
					TArray<AFurnitureModelActor*> TempModelsOfRoom;
					FindModelsOfRoom(WorldContextObject, AreaPoints, TempModelsOfRoom);
					for (int _CurM = 0; _CurM < TempModelsOfRoom.Num(); ++_CurM)
					{
						AFurnitureModelActor* TempFur = TempModelsOfRoom[_CurM];
						FString ModelName = TempFur->GetName();
						if (!ModelName.Contains(FString("Light")))
						{
							FBox TempBox = TempFur->GetComponentsBoundingBox(true);
							bool IsInModel = TempBox.IsInside(FVector(TempLoc, 130));
							if (IsInModel)
							{
								IsUnUseful = true;
								break;
							}
						}
					}
					if (!IsUnUseful)
					{
						PointMapLocalRegion.Add(TempLoc, AreaPoints);
						CameraLocations.Add(TempLoc);
					}
					else
					{
						TArray<FVector>DoorPoints;
						bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomID, DoorPoints);
						if (!GetDoorSuccess)
						{
							PointMapLocalRegion.Add(TempLoc, AreaPoints);
							CameraLocations.Add(TempLoc);
						}
						else
						{
							TMap<int, TArray<FVector>> RoomIDMapHoleData;
							int NumOfDoors = DoorPoints.Num() / 8;
							RoomIDMapHoleData.Add(TempRoomID, DoorPoints);
							if (NumOfDoors >= 1)
							{
								FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
								FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
								DirVec = DirVec.GetSafeNormal();
								DirVec = DirVec.GetRotated(90);
								FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
								FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
								FVector2D TempVec1 = DoorCenter2D + 40 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(AreaPoints, TempVec1))
								{
									PointMapLocalRegion.Add(TempVec1, AreaPoints);
									CameraLocations.Add(TempVec1);
								}
								else
								{
									FVector2D TempP = DoorCenter2D - 40 * DirVec;
									if (FPolygonAlg::JudgePointInPolygon(AreaPoints, TempP))
									{
										PointMapLocalRegion.Add(TempP, AreaPoints);
										CameraLocations.Add(TempP);
									}
									else
									{
										PointMapLocalRegion.Add(TempLoc, AreaPoints);
										CameraLocations.Add(TempLoc);
									}
								}
							}
						}
					}
				}
			}
			else
			{
				bool IsCreated = FPolygonAlg::LocateSuitableCenter(AreaPoints, SuitableCenter);
				if (!IsCreated)
				{
					return false;
				}
				PointMapLocalRegion.Add(SuitableCenter, AreaPoints);
				CameraLocations.Add(SuitableCenter);
			}
		}
		else
		{
			RemoveCount++;
		}
	}
	NumOfTotalPickPs = NumOfTotalPickPs + CameraLocations.Num();


	for (int Index = 0; Index < CameraLocations.Num(); ++Index)
	{
		CameraLocations2D.Add(CameraLocations[Index]);
	}

	if (!LocationJson)
		LocationJson = UVaRestJsonObject::ConstructJsonObject(WorldContextObject);


	float WallHeight = 0.0;
	TArray<UVaRestJsonObject*> WallArray = InJson->GetObjectArrayField("walls");
	for (int Index = 0; Index < WallArray.Num(); Index++)
	{
		TArray<FVector2D> AreaPoints;
		FVector2D SuitableCenter;
		TArray<UVaRestJsonObject*> WallCoorJson = WallArray[Index]->GetObjectArrayField("wallPoints");
		for (int WallIndex = 0; WallIndex < WallCoorJson.Num(); WallIndex++)
		{
			float TempZ = WallCoorJson[WallIndex]->GetNumberField("z");
			if (TempZ != 0)
			{
				WallHeight = TempZ;
				break;
			}
		}
	}

	int AreaNum = CameraLocations.Num();
	TArray<UVaRestJsonObject*> CameraPointArray;
	for (int Index = 0; Index < AreaNum; Index++)
	{
		UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

		UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
		SinglePointObj->SetNumberField("x", CameraLocations[Index].X);
		SinglePointObj->SetNumberField("y", CameraLocations[Index].Y);
		SinglePointObj->SetNumberField("z", 130);

		TArray<UVaRestJsonObject*> PointObjArrTemp;
		PointObjArrTemp.Emplace(SinglePointObj);
		TempPoint->SetObjectArrayField("point", PointObjArrTemp);
		TempPoint->SetStringField("roomName", RoomNameSet[Index]);
		TempPoint->SetIntegerField("roomId", RoomIDs[Index]);
		TempPoint->SetStringField("roomUsageName", RoomUsageNameSet[Index]);
		TempPoint->SetNumberField("usageId", UsageIDs[Index]);
		TempPoint->SetNumberField("id", IDs[Index]);
		CameraPointArray.Add(TempPoint);

	}
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	TArray<UVaRestJsonObject*> NewCameraPointArray;
	int idOrder = 0;
	TArray<FString> AllNameStrings;
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////统计客厅用途信息并排序////////////////////////////
	TMap<int, int> LivingRoomUseIndexMapRoomID;
	TArray<int> LivingRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("客厅")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					LivingRoomUseIndexArr.Add(TempNumber);
					LivingRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				LivingRoomUseIndexArr.Add(0);
				LivingRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	LivingRoomUseIndexArr.Sort();
	/////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////统计餐厅用途信息并排序//////////////////////////////////////////////
	TMap<int, int> DiningRoomUseIndexMapRoomID;
	TArray<int> DiningRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("餐厅")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					DiningRoomUseIndexArr.Add(TempNumber);
					DiningRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				DiningRoomUseIndexArr.Add(0);
				DiningRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	DiningRoomUseIndexArr.Sort();
	//////////////////////////////////////////////////////////////////////////////////////////
	////////////////////统计主卧用途信息并排序////////////////////////////////////////////////
	TMap<int, int> FirstRoomUseIndexMapRoomID;
	TArray<int> FirstRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("主卧")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					FirstRoomUseIndexArr.Add(TempNumber);
					FirstRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				FirstRoomUseIndexArr.Add(0);
				FirstRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	FirstRoomUseIndexArr.Sort();
	//////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计次卧个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> SecondRoomUseIndexMapRoomID;
	TArray<int> SecondRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("次卧")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					SecondRoomUseIndexArr.Add(TempNumber);
					SecondRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				SecondRoomUseIndexArr.Add(0);
				SecondRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	SecondRoomUseIndexArr.Sort();
	/////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计儿童房的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> ChildRoomUseIndexMapRoomID;
	TArray<int> ChildRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("儿童房")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					ChildRoomUseIndexArr.Add(TempNumber);
					ChildRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				ChildRoomUseIndexArr.Add(0);
				ChildRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	ChildRoomUseIndexArr.Sort();
	//////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计老人房的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> OlderRoomUseIndexMapRoomID;
	TArray<int> OlderRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("老人房")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					OlderRoomUseIndexArr.Add(TempNumber);
					OlderRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				OlderRoomUseIndexArr.Add(0);
				OlderRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	OlderRoomUseIndexArr.Sort();
	////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计榻榻米房的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> TatamiRoomUseIndexMapRoomID;
	TArray<int>TatamiRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("榻榻米房")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					TatamiRoomUseIndexArr.Add(TempNumber);
					TatamiRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				TatamiRoomUseIndexArr.Add(0);
				TatamiRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	TatamiRoomUseIndexArr.Sort();
	////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计书房的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> StudyRoomUseIndexMapRoomID;
	TArray<int>StudyRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("书房")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					StudyRoomUseIndexArr.Add(TempNumber);
					StudyRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				StudyRoomUseIndexArr.Add(0);
				StudyRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	StudyRoomUseIndexArr.Sort();
	////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计多功能房的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> MultiFunctionRoomUseIndexMapRoomID;
	TArray<int>MultiFunctionRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("多功能房")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					MultiFunctionRoomUseIndexArr.Add(TempNumber);
					MultiFunctionRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				MultiFunctionRoomUseIndexArr.Add(0);
				MultiFunctionRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	MultiFunctionRoomUseIndexArr.Sort();
	////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计起居室的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> StartRoomUseIndexMapRoomID;
	TArray<int> StartRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("起居室")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					StartRoomUseIndexArr.Add(TempNumber);
					StartRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				StartRoomUseIndexArr.Add(0);
				StartRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	StartRoomUseIndexArr.Sort();
	////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计储藏间的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> StoreRoomUseIndexMapRoomID;
	TArray<int> StoreRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("储藏间")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					StoreRoomUseIndexArr.Add(TempNumber);
					StoreRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				StoreRoomUseIndexArr.Add(0);
				StoreRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	StoreRoomUseIndexArr.Sort();
	////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计衣帽间的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> CloakRoomUseIndexMapRoomID;
	TArray<int> CloakRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("衣帽间")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					CloakRoomUseIndexArr.Add(TempNumber);
					CloakRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				CloakRoomUseIndexArr.Add(0);
				CloakRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	CloakRoomUseIndexArr.Sort();
	////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计厨房的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> KitchenRoomUseIndexMapRoomID;
	TArray<int> KitchenRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("厨房")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					KitchenRoomUseIndexArr.Add(TempNumber);
					KitchenRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				KitchenRoomUseIndexArr.Add(0);
				KitchenRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	KitchenRoomUseIndexArr.Sort();
	////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计主卫的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> FirstToiletRoomUseIndexMapRoomID;
	TArray<int> FirstToiletRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("主卫")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					FirstToiletRoomUseIndexArr.Add(TempNumber);
					FirstToiletRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				FirstToiletRoomUseIndexArr.Add(0);
				FirstToiletRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	FirstToiletRoomUseIndexArr.Sort();
	//////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计客卫的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> SecondToiletRoomUseIndexMapRoomID;
	TArray<int> SecondToiletRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("客卫")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					SecondToiletRoomUseIndexArr.Add(TempNumber);
					SecondToiletRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				SecondToiletRoomUseIndexArr.Add(0);
				SecondToiletRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	SecondToiletRoomUseIndexArr.Sort();
	//////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计生活阳台的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> LivingBalconyRoomUseIndexMapRoomID;
	TArray<int> LivingBalconyRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("生活阳台")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					LivingBalconyRoomUseIndexArr.Add(TempNumber);
					LivingBalconyRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				LivingBalconyRoomUseIndexArr.Add(0);
				LivingBalconyRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	LivingBalconyRoomUseIndexArr.Sort();
	//////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计休闲阳台的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> LeisureBalconyRoomUseIndexMapRoomID;
	TArray<int> LeisureBalconyRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("休闲阳台")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					LeisureBalconyRoomUseIndexArr.Add(TempNumber);
					LeisureBalconyRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				LeisureBalconyRoomUseIndexArr.Add(0);
				LeisureBalconyRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	LeisureBalconyRoomUseIndexArr.Sort();
	//////////////////////////////////////////////////////////////////////////////////////////////////////

	TArray<int> HasProcessed;
	////////////////////////按用途顺序输出客厅相关数据json////////////////////////////////////////////////
	for (int _CurNum = 0; _CurNum < LivingRoomUseIndexArr.Num(); ++_CurNum)
	{
		int BaseRoomID = LivingRoomUseIndexMapRoomID[LivingRoomUseIndexArr[_CurNum]];
		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);
					SinglePointObj->SetNumberField("floor", 1);

					
					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Add(SinglePointObj);
					/////////////////////////////////
					if (RoomIdMapSmallCenters.Contains(BaseRoomID))
					{
						TArray<FVector2D> TempSmallCentersArr = RoomIdMapSmallCenters[BaseRoomID];
						TArray<int> CutIntArr;
						if (RoomIDMapToRemoveIndexs.Contains(TempIDOfRoom))
						{
							CutIntArr = RoomIDMapToRemoveIndexs[TempIDOfRoom];
						}
						for (int PIndex = 0; PIndex < TempSmallCentersArr.Num(); PIndex++)
						{
							if (!CutIntArr.Contains(PIndex))
							{
								idOrder++;
								UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
								TSinglePointObj->SetNumberField("id", idOrder);
								TSinglePointObj->SetNumberField("x", TempSmallCentersArr[PIndex].X);
								TSinglePointObj->SetNumberField("y", TempSmallCentersArr[PIndex].Y);
								TSinglePointObj->SetNumberField("z", 130);
								TSinglePointObj->SetNumberField("markType", 0);
								TSinglePointObj->SetNumberField("floor", 1);

								
								if (PointMapLocalRegion.Contains(TempSmallCentersArr[PIndex]))
								{
									TArray<FVector2D> LocalPoints = PointMapLocalRegion[TempSmallCentersArr[PIndex]];
									TArray<UVaRestJsonObject*> LocalBoundPoints;
									for (int IP = 0; IP < LocalPoints.Num(); ++IP)
									{
										UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
										TempPoint->SetNumberField("x", LocalPoints[IP].X);
										TempPoint->SetNumberField("y", LocalPoints[IP].Y);
										LocalBoundPoints.Add(TempPoint);
									}
									TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
								}
								PointObjArrTemp.Add(TSinglePointObj);
							}
						}
					}
					//////////////////////////

					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("客厅"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}
		}
	}
	////////////////////////////////////////////////////////////////////////////////////////////////////


	////////////////////////按用途顺序输出餐厅相关数据json//////////////////////////////////////////////
	for (int _CurNum = 0; _CurNum < DiningRoomUseIndexArr.Num(); ++_CurNum)
	{
		int BaseRoomID = DiningRoomUseIndexMapRoomID[DiningRoomUseIndexArr[_CurNum]];
		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);
					SinglePointObj->SetNumberField("floor", 1);

					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Add(SinglePointObj);
					/////////////////////////////////
					if (RoomIdMapSmallCenters.Contains(TempIDOfRoom))
					{
						TArray<FVector2D> TempSmallCentersArr = RoomIdMapSmallCenters[TempIDOfRoom];

						TArray<int> CutIntArr;
						if (RoomIDMapToRemoveIndexs.Contains(TempIDOfRoom))
						{
							CutIntArr = RoomIDMapToRemoveIndexs[TempIDOfRoom];
						}
						for (int PIndex = 0; PIndex < TempSmallCentersArr.Num(); PIndex++)
						{
							if (!CutIntArr.Contains(PIndex))
							{
								idOrder++;
								UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
								TSinglePointObj->SetNumberField("id", idOrder);
								TSinglePointObj->SetNumberField("x", TempSmallCentersArr[PIndex].X);
								TSinglePointObj->SetNumberField("y", TempSmallCentersArr[PIndex].Y);
								TSinglePointObj->SetNumberField("z", 130);
								TSinglePointObj->SetNumberField("markType", 0);
								TSinglePointObj->SetNumberField("floor", 1);
								

								if (PointMapLocalRegion.Contains(TempSmallCentersArr[PIndex]))
								{
									TArray<FVector2D> LocalPoints = PointMapLocalRegion[TempSmallCentersArr[PIndex]];
									TArray<UVaRestJsonObject*> LocalBoundPoints;
									for (int IP = 0; IP < LocalPoints.Num(); ++IP)
									{
										UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
										TempPoint->SetNumberField("x", LocalPoints[IP].X);
										TempPoint->SetNumberField("y", LocalPoints[IP].Y);
										LocalBoundPoints.Add(TempPoint);
									}
									TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
								}
								PointObjArrTemp.Add(TSinglePointObj);
							}
						}
					}
					//////////////////////////

					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("餐厅"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}

		}
	}


	/////////////////////////按用途顺序输出主卧相关数据json/////////////////////////////////////////////
	for (int _CurNum = 0; _CurNum < FirstRoomUseIndexArr.Num(); ++_CurNum)
	{
		int BaseRoomID = FirstRoomUseIndexMapRoomID[FirstRoomUseIndexArr[_CurNum]];
		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);
					SinglePointObj->SetNumberField("floor", 1);

					

					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;

					PointObjArrTemp.Add(SinglePointObj);



					/////////////////////////////////
					if (RoomIdMapSmallCenters.Contains(TempIDOfRoom))
					{
						TArray<FVector2D> TempSmallCentersArr = RoomIdMapSmallCenters[TempIDOfRoom];

						TArray<int> CutIntArr;
						if (RoomIDMapToRemoveIndexs.Contains(TempIDOfRoom))
						{
							CutIntArr = RoomIDMapToRemoveIndexs[TempIDOfRoom];
						}

						for (int PIndex = 0; PIndex < TempSmallCentersArr.Num(); PIndex++)
						{
							if (!CutIntArr.Contains(PIndex))
							{
								idOrder++;
								UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
								TSinglePointObj->SetNumberField("id", idOrder);
								TSinglePointObj->SetNumberField("x", TempSmallCentersArr[PIndex].X);
								TSinglePointObj->SetNumberField("y", TempSmallCentersArr[PIndex].Y);
								TSinglePointObj->SetNumberField("z", 130);
								TSinglePointObj->SetNumberField("markType", 0);
								TSinglePointObj->SetNumberField("floor", 1);
								
								if (PointMapLocalRegion.Contains(TempSmallCentersArr[PIndex]))
								{
									TArray<FVector2D> LocalPoints = PointMapLocalRegion[TempSmallCentersArr[PIndex]];
									TArray<UVaRestJsonObject*> LocalBoundPoints;
									for (int IP = 0; IP < LocalPoints.Num(); ++IP)
									{
										UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
										TempPoint->SetNumberField("x", LocalPoints[IP].X);
										TempPoint->SetNumberField("y", LocalPoints[IP].Y);
										LocalBoundPoints.Add(TempPoint);
									}
									TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
								}
								PointObjArrTemp.Add(TSinglePointObj);
							}
						}
					}
					///////////////////////////////////////////////
					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("主卧"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}
		}
	}


	//////////////////////////按用途顺序输出次卧相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < SecondRoomUseIndexArr.Num(); ++_CurNum)
	{
		int BaseRoomID = SecondRoomUseIndexMapRoomID[SecondRoomUseIndexArr[_CurNum]];
		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);
					SinglePointObj->SetNumberField("floor", 1);

				
					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Add(SinglePointObj);
					/////////////////////////////////
					if (RoomIdMapSmallCenters.Contains(TempIDOfRoom))
					{
						TArray<FVector2D> TempSmallCentersArr = RoomIdMapSmallCenters[TempIDOfRoom];

						TArray<int> CutIntArr;
						if (RoomIDMapToRemoveIndexs.Contains(TempIDOfRoom))
						{
							CutIntArr = RoomIDMapToRemoveIndexs[TempIDOfRoom];
						}

						for (int PIndex = 0; PIndex < TempSmallCentersArr.Num(); PIndex++)
						{
							if (!CutIntArr.Contains(PIndex))
							{
								idOrder++;
								UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
								TSinglePointObj->SetNumberField("id", idOrder);
								TSinglePointObj->SetNumberField("x", TempSmallCentersArr[PIndex].X);
								TSinglePointObj->SetNumberField("y", TempSmallCentersArr[PIndex].Y);
								TSinglePointObj->SetNumberField("z", 130);
								TSinglePointObj->SetNumberField("markType", 0);
								TSinglePointObj->SetNumberField("floor", 1);
								
								if (PointMapLocalRegion.Contains(TempSmallCentersArr[PIndex]))
								{
									TArray<FVector2D> LocalPoints = PointMapLocalRegion[TempSmallCentersArr[PIndex]];
									TArray<UVaRestJsonObject*> LocalBoundPoints;
									for (int IP = 0; IP < LocalPoints.Num(); ++IP)
									{
										UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
										TempPoint->SetNumberField("x", LocalPoints[IP].X);
										TempPoint->SetNumberField("y", LocalPoints[IP].Y);
										LocalBoundPoints.Add(TempPoint);
									}
									TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
								}
								PointObjArrTemp.Add(TSinglePointObj);
							}
						}
					}
					///////////////////////////////////////////////
					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("次卧"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}
		}
	}

	//////////////////////////按用途顺序输出儿童房相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < ChildRoomUseIndexArr.Num(); ++_CurNum)
	{
		int BaseRoomID = ChildRoomUseIndexMapRoomID[ChildRoomUseIndexArr[_CurNum]];

		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);
					SinglePointObj->SetNumberField("floor", 1);
					
					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Emplace(SinglePointObj);


					/////////////////////////////////
					if (RoomIdMapSmallCenters.Contains(TempIDOfRoom))
					{
						TArray<FVector2D> TempSmallCentersArr = RoomIdMapSmallCenters[TempIDOfRoom];

						TArray<int> CutIntArr;
						if (RoomIDMapToRemoveIndexs.Contains(TempIDOfRoom))
						{
							CutIntArr = RoomIDMapToRemoveIndexs[TempIDOfRoom];
						}

						for (int PIndex = 0; PIndex < TempSmallCentersArr.Num(); PIndex++)
						{
							if (!CutIntArr.Contains(PIndex))
							{
								idOrder++;
								UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
								TSinglePointObj->SetNumberField("id", idOrder);
								TSinglePointObj->SetNumberField("x", TempSmallCentersArr[PIndex].X);
								TSinglePointObj->SetNumberField("y", TempSmallCentersArr[PIndex].Y);
								TSinglePointObj->SetNumberField("z", 130);
								TSinglePointObj->SetNumberField("markType", 0);
								TSinglePointObj->SetNumberField("floor", 1);
								

								if (PointMapLocalRegion.Contains(TempSmallCentersArr[PIndex]))
								{
									TArray<FVector2D> LocalPoints = PointMapLocalRegion[TempSmallCentersArr[PIndex]];
									TArray<UVaRestJsonObject*> LocalBoundPoints;
									for (int IP = 0; IP < LocalPoints.Num(); ++IP)
									{
										UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
										TempPoint->SetNumberField("x", LocalPoints[IP].X);
										TempPoint->SetNumberField("y", LocalPoints[IP].Y);
										LocalBoundPoints.Add(TempPoint);
									}
									TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
								}
								PointObjArrTemp.Add(TSinglePointObj);
							}
						}
					}
					///////////////////////////////////////////////
					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("儿童房"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}
		}
	}

	//////////////////////////按用途顺序输出老人房相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < OlderRoomUseIndexArr.Num(); ++_CurNum)
	{
		int BaseRoomID = OlderRoomUseIndexMapRoomID[OlderRoomUseIndexArr[_CurNum]];

		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);
					SinglePointObj->SetNumberField("floor", 1);
				

					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Emplace(SinglePointObj);

					/////////////////////////////////
					if (RoomIdMapSmallCenters.Contains(TempIDOfRoom))
					{
						TArray<FVector2D> TempSmallCentersArr = RoomIdMapSmallCenters[TempIDOfRoom];

						TArray<int> CutIntArr;
						if (RoomIDMapToRemoveIndexs.Contains(TempIDOfRoom))
						{
							CutIntArr = RoomIDMapToRemoveIndexs[TempIDOfRoom];
						}

						for (int PIndex = 0; PIndex < TempSmallCentersArr.Num(); PIndex++)
						{
							if (!CutIntArr.Contains(PIndex))
							{
								idOrder++;
								UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
								TSinglePointObj->SetNumberField("id", idOrder);
								TSinglePointObj->SetNumberField("x", TempSmallCentersArr[PIndex].X);
								TSinglePointObj->SetNumberField("y", TempSmallCentersArr[PIndex].Y);
								TSinglePointObj->SetNumberField("z", 130);
								TSinglePointObj->SetNumberField("markType", 0);
								TSinglePointObj->SetNumberField("floor", 1);

								

								if (PointMapLocalRegion.Contains(TempSmallCentersArr[PIndex]))
								{
									TArray<FVector2D> LocalPoints = PointMapLocalRegion[TempSmallCentersArr[PIndex]];
									TArray<UVaRestJsonObject*> LocalBoundPoints;
									for (int IP = 0; IP < LocalPoints.Num(); ++IP)
									{
										UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
										TempPoint->SetNumberField("x", LocalPoints[IP].X);
										TempPoint->SetNumberField("y", LocalPoints[IP].Y);
										LocalBoundPoints.Add(TempPoint);
									}
									TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
								}
								PointObjArrTemp.Add(TSinglePointObj);
							}
						}
					}
					///////////////////////////////////////////////
					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("老人房"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}

		}
	}

	//////////////////////////按用途顺序输出榻榻米房相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < TatamiRoomUseIndexArr.Num(); ++_CurNum)
	{
		int BaseRoomID = TatamiRoomUseIndexMapRoomID[TatamiRoomUseIndexArr[_CurNum]];

		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);
					SinglePointObj->SetNumberField("floor", 1);
					
					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Emplace(SinglePointObj);



					/////////////////////////////////
					if (RoomIdMapSmallCenters.Contains(TempIDOfRoom))
					{
						TArray<FVector2D> TempSmallCentersArr = RoomIdMapSmallCenters[TempIDOfRoom];

						TArray<int> CutIntArr;
						if (RoomIDMapToRemoveIndexs.Contains(TempIDOfRoom))
						{
							CutIntArr = RoomIDMapToRemoveIndexs[TempIDOfRoom];
						}

						for (int PIndex = 0; PIndex < TempSmallCentersArr.Num(); PIndex++)
						{
							if (!CutIntArr.Contains(PIndex))
							{
								idOrder++;
								UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
								TSinglePointObj->SetNumberField("id", idOrder);
								TSinglePointObj->SetNumberField("x", TempSmallCentersArr[PIndex].X);
								TSinglePointObj->SetNumberField("y", TempSmallCentersArr[PIndex].Y);
								TSinglePointObj->SetNumberField("z", 130);
								TSinglePointObj->SetNumberField("markType", 0);
								TSinglePointObj->SetNumberField("floor", 1);
								

								if (PointMapLocalRegion.Contains(TempSmallCentersArr[PIndex]))
								{
									TArray<FVector2D> LocalPoints = PointMapLocalRegion[TempSmallCentersArr[PIndex]];
									TArray<UVaRestJsonObject*> LocalBoundPoints;
									for (int IP = 0; IP < LocalPoints.Num(); ++IP)
									{
										UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
										TempPoint->SetNumberField("x", LocalPoints[IP].X);
										TempPoint->SetNumberField("y", LocalPoints[IP].Y);
										LocalBoundPoints.Add(TempPoint);
									}
									TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
								}
								PointObjArrTemp.Add(TSinglePointObj);
							}
						}
					}
					///////////////////////////////////////////////
					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("榻榻米房"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}

		}

	}

	//////////////////////////按用途顺序输出书房相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < StudyRoomUseIndexArr.Num(); ++_CurNum)
	{
		int BaseRoomID = StudyRoomUseIndexMapRoomID[StudyRoomUseIndexArr[_CurNum]];

		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);
					SinglePointObj->SetNumberField("floor", 1);
					
					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Emplace(SinglePointObj);

					/////////////////////////////////
					if (RoomIdMapSmallCenters.Contains(TempIDOfRoom))
					{
						TArray<FVector2D> TempSmallCentersArr = RoomIdMapSmallCenters[TempIDOfRoom];

						TArray<int> CutIntArr;
						if (RoomIDMapToRemoveIndexs.Contains(TempIDOfRoom))
						{
							CutIntArr = RoomIDMapToRemoveIndexs[TempIDOfRoom];
						}

						for (int PIndex = 0; PIndex < TempSmallCentersArr.Num(); PIndex++)
						{
							if (!CutIntArr.Contains(PIndex))
							{
								idOrder++;
								UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
								TSinglePointObj->SetNumberField("id", idOrder);
								TSinglePointObj->SetNumberField("x", TempSmallCentersArr[PIndex].X);
								TSinglePointObj->SetNumberField("y", TempSmallCentersArr[PIndex].Y);
								TSinglePointObj->SetNumberField("z", 130);
								TSinglePointObj->SetNumberField("markType", 0);
								TSinglePointObj->SetNumberField("floor", 1);
								

								if (PointMapLocalRegion.Contains(TempSmallCentersArr[PIndex]))
								{
									TArray<FVector2D> LocalPoints = PointMapLocalRegion[TempSmallCentersArr[PIndex]];
									TArray<UVaRestJsonObject*> LocalBoundPoints;
									for (int IP = 0; IP < LocalPoints.Num(); ++IP)
									{
										UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
										TempPoint->SetNumberField("x", LocalPoints[IP].X);
										TempPoint->SetNumberField("y", LocalPoints[IP].Y);
										LocalBoundPoints.Add(TempPoint);
									}
									TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
								}
								PointObjArrTemp.Add(TSinglePointObj);
							}
						}
					}
					///////////////////////////////////////////////
					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("书房"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}

		}
	}

	//////////////////////////按用途顺序输出多功能房相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < MultiFunctionRoomUseIndexArr.Num(); ++_CurNum)
	{
		int BaseRoomID = MultiFunctionRoomUseIndexMapRoomID[MultiFunctionRoomUseIndexArr[_CurNum]];

		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);
					SinglePointObj->SetNumberField("floor", 1);
					
					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Add(SinglePointObj);


					/////////////////////////////////////////////////////////////////////
					if (RoomIdMapSmallCenters.Contains(TempIDOfRoom))
					{
						TArray<FVector2D> TempSmallCentersArr = RoomIdMapSmallCenters[TempIDOfRoom];

						TArray<int> CutIntArr;
						if (RoomIDMapToRemoveIndexs.Contains(TempIDOfRoom))
						{
							CutIntArr = RoomIDMapToRemoveIndexs[TempIDOfRoom];
						}

						for (int PIndex = 0; PIndex < TempSmallCentersArr.Num(); PIndex++)
						{
							if (!CutIntArr.Contains(PIndex))
							{
								idOrder++;
								UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
								TSinglePointObj->SetNumberField("id", idOrder);
								TSinglePointObj->SetNumberField("x", TempSmallCentersArr[PIndex].X);
								TSinglePointObj->SetNumberField("y", TempSmallCentersArr[PIndex].Y);
								TSinglePointObj->SetNumberField("z", 130);
								TSinglePointObj->SetNumberField("markType", 0);
								TSinglePointObj->SetNumberField("floor", 1);
							
								if (PointMapLocalRegion.Contains(TempSmallCentersArr[PIndex]))
								{
									TArray<FVector2D> LocalPoints = PointMapLocalRegion[TempSmallCentersArr[PIndex]];
									TArray<UVaRestJsonObject*> LocalBoundPoints;
									for (int IP = 0; IP < LocalPoints.Num(); ++IP)
									{
										UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
										TempPoint->SetNumberField("x", LocalPoints[IP].X);
										TempPoint->SetNumberField("y", LocalPoints[IP].Y);
										LocalBoundPoints.Add(TempPoint);
									}
									TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
								}
								PointObjArrTemp.Add(TSinglePointObj);
							}
						}
					}
					///////////////////////////////////////////////
					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("多功能房"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}

		}
	}


	//////////////////////////按用途顺序输出起居室相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < StartRoomUseIndexArr.Num(); ++_CurNum)
	{
		int BaseRoomID = StartRoomUseIndexMapRoomID[StartRoomUseIndexArr[_CurNum]];
		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);
					SinglePointObj->SetNumberField("floor", 1);
					
					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Add(SinglePointObj);
					/////////////////////////////////
					if (RoomIdMapSmallCenters.Contains(TempIDOfRoom))
					{
						TArray<FVector2D> TempSmallCentersArr = RoomIdMapSmallCenters[TempIDOfRoom];

						TArray<int> CutIntArr;
						if (RoomIDMapToRemoveIndexs.Contains(TempIDOfRoom))
						{
							CutIntArr = RoomIDMapToRemoveIndexs[TempIDOfRoom];
						}

						for (int PIndex = 0; PIndex < TempSmallCentersArr.Num(); PIndex++)
						{
							if (!CutIntArr.Contains(PIndex))
							{
								idOrder++;
								UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
								TSinglePointObj->SetNumberField("id", idOrder);
								TSinglePointObj->SetNumberField("x", TempSmallCentersArr[PIndex].X);
								TSinglePointObj->SetNumberField("y", TempSmallCentersArr[PIndex].Y);
								TSinglePointObj->SetNumberField("z", 130);
								TSinglePointObj->SetNumberField("markType", 0);
								TSinglePointObj->SetNumberField("floor", 1);
								

								if (PointMapLocalRegion.Contains(TempSmallCentersArr[PIndex]))
								{
									TArray<FVector2D> LocalPoints = PointMapLocalRegion[TempSmallCentersArr[PIndex]];
									TArray<UVaRestJsonObject*> LocalBoundPoints;
									for (int IP = 0; IP < LocalPoints.Num(); ++IP)
									{
										UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
										TempPoint->SetNumberField("x", LocalPoints[IP].X);
										TempPoint->SetNumberField("y", LocalPoints[IP].Y);
										LocalBoundPoints.Add(TempPoint);
									}
									TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
								}
								PointObjArrTemp.Add(TSinglePointObj);
							}
						}
					}
					//////////////////////////////////
					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("起居室"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}
		}
	}


	//////////////////////////按用途顺序输出储藏间相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < StoreRoomUseIndexArr.Num(); ++_CurNum)
	{
		int BaseRoomID = StoreRoomUseIndexMapRoomID[StoreRoomUseIndexArr[_CurNum]];
		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);
					SinglePointObj->SetNumberField("floor", 1);
					

					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Emplace(SinglePointObj);
					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("储藏间"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}

		}
	}

	//////////////////////////按用途顺序输出衣帽间相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < CloakRoomUseIndexArr.Num(); ++_CurNum)
	{
		int BaseRoomID = CloakRoomUseIndexMapRoomID[CloakRoomUseIndexArr[_CurNum]];
		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);
					SinglePointObj->SetNumberField("floor", 1);
					
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Emplace(SinglePointObj);
					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("衣帽间"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}

		}
	}


	//////////////////////////按用途顺序输出厨房相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < KitchenRoomUseIndexArr.Num(); ++_CurNum)
	{
		int BaseRoomID = KitchenRoomUseIndexMapRoomID[KitchenRoomUseIndexArr[_CurNum]];

		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);
					SinglePointObj->SetNumberField("floor", 1);
					
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Emplace(SinglePointObj);
					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("厨房"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}

		}
	}

	//////////////////////////按用途顺序输出主卫相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < FirstToiletRoomUseIndexArr.Num(); ++_CurNum)
	{
		int BaseRoomID = FirstToiletRoomUseIndexMapRoomID[FirstToiletRoomUseIndexArr[_CurNum]];
		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);
					SinglePointObj->SetNumberField("floor", 1);
					

					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}

					///////////////////////////////////////////////////////////////////
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Add(SinglePointObj);

					if (ToiletRoomIDMapSmallCenters.Contains(TempIDOfRoom))
					{
						TArray<FVector2D> TempSmallCentersArr = ToiletRoomIDMapSmallCenters[TempIDOfRoom];
						for (int PIndex = 0; PIndex < TempSmallCentersArr.Num(); PIndex++)
						{
							idOrder++;
							UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
							TSinglePointObj->SetNumberField("id", idOrder);
							TSinglePointObj->SetNumberField("x", TempSmallCentersArr[PIndex].X);
							TSinglePointObj->SetNumberField("y", TempSmallCentersArr[PIndex].Y);
							TSinglePointObj->SetNumberField("z", 130);
							TSinglePointObj->SetNumberField("markType", 0);
							TSinglePointObj->SetNumberField("floor", 1);
							

							if (PointMapLocalRegion.Contains(TempSmallCentersArr[PIndex]))
							{
								TArray<FVector2D> LocalPoints = PointMapLocalRegion[TempSmallCentersArr[PIndex]];
								TArray<UVaRestJsonObject*> LocalBoundPoints;
								for (int IP = 0; IP < LocalPoints.Num(); ++IP)
								{
									UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
									TempPoint->SetNumberField("x", LocalPoints[IP].X);
									TempPoint->SetNumberField("y", LocalPoints[IP].Y);
									LocalBoundPoints.Add(TempPoint);
								}
								TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);

							}
							PointObjArrTemp.Add(TSinglePointObj);
						}
					}
					///////////////////////////////////////////////////////////////////

					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("主卫"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}

		}

	}

	//////////////////////////按用途顺序输出客卫相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < SecondToiletRoomUseIndexArr.Num(); ++_CurNum)
	{
		int BaseRoomID = SecondToiletRoomUseIndexMapRoomID[SecondToiletRoomUseIndexArr[_CurNum]];

		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);
					SinglePointObj->SetNumberField("floor", 1);
					
					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}

					///////////////////////////////////////////////////////////////////
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Add(SinglePointObj);
					if (ToiletRoomIDMapSmallCenters.Contains(TempIDOfRoom))
					{
						TArray<FVector2D> TempSmallCentersArr = ToiletRoomIDMapSmallCenters[TempIDOfRoom];
						for (int PIndex = 0; PIndex < TempSmallCentersArr.Num(); PIndex++)
						{
							idOrder++;
							UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
							TSinglePointObj->SetNumberField("id", idOrder);
							TSinglePointObj->SetNumberField("x", TempSmallCentersArr[PIndex].X);
							TSinglePointObj->SetNumberField("y", TempSmallCentersArr[PIndex].Y);
							TSinglePointObj->SetNumberField("z", 130);
							TSinglePointObj->SetNumberField("markType", 0);
							TSinglePointObj->SetNumberField("floor", 1);
							
							if (PointMapLocalRegion.Contains(TempSmallCentersArr[PIndex]))
							{
								TArray<FVector2D> LocalPoints = PointMapLocalRegion[TempSmallCentersArr[PIndex]];
								TArray<UVaRestJsonObject*> LocalBoundPoints;
								for (int IP = 0; IP < LocalPoints.Num(); ++IP)
								{
									UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
									TempPoint->SetNumberField("x", LocalPoints[IP].X);
									TempPoint->SetNumberField("y", LocalPoints[IP].Y);
									LocalBoundPoints.Add(TempPoint);
								}
								TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);

							}
							PointObjArrTemp.Add(TSinglePointObj);
						}

					}

					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("客卫"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}

		}
	}

	//////////////////////////按用途顺序输出生活阳台相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < LivingBalconyRoomUseIndexArr.Num(); ++_CurNum)
	{

		int BaseRoomID = LivingBalconyRoomUseIndexMapRoomID[LivingBalconyRoomUseIndexArr[_CurNum]];

		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);
					SinglePointObj->SetNumberField("floor", 1);
					

					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;

					PointObjArrTemp.Add(SinglePointObj);



					/////////////////////////////////
					if (RoomIdMapSmallCenters.Contains(TempIDOfRoom))
					{
						TArray<FVector2D> TempSmallCentersArr = RoomIdMapSmallCenters[TempIDOfRoom];

						TArray<int> CutIntArr;
						if (RoomIDMapToRemoveIndexs.Contains(TempIDOfRoom))
						{
							CutIntArr = RoomIDMapToRemoveIndexs[TempIDOfRoom];
						}

						for (int PIndex = 0; PIndex < TempSmallCentersArr.Num(); PIndex++)
						{
							if (!CutIntArr.Contains(PIndex))
							{
								idOrder++;
								UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
								TSinglePointObj->SetNumberField("id", idOrder);
								TSinglePointObj->SetNumberField("x", TempSmallCentersArr[PIndex].X);
								TSinglePointObj->SetNumberField("y", TempSmallCentersArr[PIndex].Y);
								TSinglePointObj->SetNumberField("z", 130);
								TSinglePointObj->SetNumberField("markType", 0);
								TSinglePointObj->SetNumberField("floor", 1);
								

								if (PointMapLocalRegion.Contains(TempSmallCentersArr[PIndex]))
								{
									TArray<FVector2D> LocalPoints = PointMapLocalRegion[TempSmallCentersArr[PIndex]];
									TArray<UVaRestJsonObject*> LocalBoundPoints;
									for (int IP = 0; IP < LocalPoints.Num(); ++IP)
									{
										UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
										TempPoint->SetNumberField("x", LocalPoints[IP].X);
										TempPoint->SetNumberField("y", LocalPoints[IP].Y);
										LocalBoundPoints.Add(TempPoint);
									}
									TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
								}
								PointObjArrTemp.Add(TSinglePointObj);
							}
						}
					}
					///////////////////////////////////////////////
					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("生活阳台"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}
		}
	}

	//////////////////////////按用途顺序输出休闲阳台相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < LeisureBalconyRoomUseIndexArr.Num(); ++_CurNum)
	{

		int BaseRoomID = LeisureBalconyRoomUseIndexMapRoomID[LeisureBalconyRoomUseIndexArr[_CurNum]];

		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);
					SinglePointObj->SetNumberField("floor", 1);
					

					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;

					PointObjArrTemp.Add(SinglePointObj);



					/////////////////////////////////
					if (RoomIdMapSmallCenters.Contains(TempIDOfRoom))
					{
						TArray<FVector2D> TempSmallCentersArr = RoomIdMapSmallCenters[TempIDOfRoom];

						TArray<int> CutIntArr;
						if (RoomIDMapToRemoveIndexs.Contains(TempIDOfRoom))
						{
							CutIntArr = RoomIDMapToRemoveIndexs[TempIDOfRoom];
						}

						for (int PIndex = 0; PIndex < TempSmallCentersArr.Num(); PIndex++)
						{
							if (!CutIntArr.Contains(PIndex))
							{
								idOrder++;
								UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
								TSinglePointObj->SetNumberField("id", idOrder);
								TSinglePointObj->SetNumberField("x", TempSmallCentersArr[PIndex].X);
								TSinglePointObj->SetNumberField("y", TempSmallCentersArr[PIndex].Y);
								TSinglePointObj->SetNumberField("z", 130);
								TSinglePointObj->SetNumberField("markType", 0);
								TSinglePointObj->SetNumberField("floor", 1);
								
								if (PointMapLocalRegion.Contains(TempSmallCentersArr[PIndex]))
								{
									TArray<FVector2D> LocalPoints = PointMapLocalRegion[TempSmallCentersArr[PIndex]];
									TArray<UVaRestJsonObject*> LocalBoundPoints;
									for (int IP = 0; IP < LocalPoints.Num(); ++IP)
									{
										UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
										TempPoint->SetNumberField("x", LocalPoints[IP].X);
										TempPoint->SetNumberField("y", LocalPoints[IP].Y);
										LocalBoundPoints.Add(TempPoint);
									}
									TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
								}
								PointObjArrTemp.Add(TSinglePointObj);
							}
						}
					}
					///////////////////////////////////////////////
					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("休闲阳台"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}
		}
	}



	for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
	{
		FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
		bool FindNameString = false;

		for (int NIndex = 0; NIndex < AllNameStrings.Num(); NIndex++)
		{
			if (AllNameStrings[NIndex] == TempString)
			{
				FindNameString = true;
				break;
			}
		}
		if (FindNameString == false)
		{
			idOrder++;
			UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", idOrder);
			SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
			SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
			SinglePointObj->SetNumberField("z", 130);
			SinglePointObj->SetNumberField("markType", 1);
			SinglePointObj->SetNumberField("floor", 1);
			
			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Emplace(SinglePointObj);
			OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
			OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
			OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
			OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
			OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
			NewCameraPointArray.Add(OutTempPoint);
			AllNameStrings.Add(TempString);
		}
	}

	LocationJson->SetObjectArrayField("cameraLocation", NewCameraPointArray);
	return true;
}



bool UWriteMeshObj_FunctionLibrary::CreateAdvancedLocationJsonWithFloorsAndMulitiLivings(UObject* WorldContextObject, UVaRestJsonObject* InJson, UVaRestJsonObject* &LocationJson,
	TArray<FVector2D>& CameraLocations, int& NumOfTotalPickPs, TMap<int, FloorGroup>&GroupRoomIDs, TArray<FGroupRoomIDs>&GroupMapLivingOrDiningRoomIDs)
{
	if (InJson == nullptr)
	{
		return false;
	}

	TArray<UVaRestJsonObject*> WallJsonObj = InJson->GetObjectArrayField("walls");
	TArray<Polygon_2> WallPolygon;
	TArray<FVector2D> WallCenters;
	TMap<int, TArray<FVector2D>> IndexMapWallPs;
	for (int Index = 0; Index < WallJsonObj.Num(); Index++)
	{
		TArray<FVector2D> WallRegionPoints;
		TArray<UVaRestJsonObject*> EachWallRegion = WallJsonObj[Index]->GetObjectArrayField("wallPoints");

		for (int WallIndex = 0; WallIndex < EachWallRegion.Num(); WallIndex++)
		{
			float TempX = EachWallRegion[WallIndex]->GetNumberField("x");
			float TempY = EachWallRegion[WallIndex]->GetNumberField("y");
			WallRegionPoints.Add(FVector2D(TempX, TempY));
		}
		Polygon_2 TempWallPolygon;
		float WallCenterX = 0.0, WallCenterY = 0.0;
		for (int PIndex = 0; PIndex < 4; PIndex++)
		{
			TempWallPolygon.push_back(Point_2(WallRegionPoints[PIndex].X, WallRegionPoints[PIndex].Y));
			WallCenterX = WallCenterX + WallRegionPoints[PIndex].X;
			WallCenterY = WallCenterY + WallRegionPoints[PIndex].Y;
		}
		IndexMapWallPs.Add(Index, WallRegionPoints);
		WallCenterX = WallCenterX / 4;
		WallCenterY = WallCenterY / 4;
		WallCenters.Add(FVector2D(WallCenterX, WallCenterY));
		WallPolygon.Add(TempWallPolygon);
		TempWallPolygon.clear();
	}

	TArray<FVector2D> SmallRegionCenters, NewSmallRegionCenters, ThirdDiningSmallCenters, FourthDiningSmallCenters;
	TArray<FString> RoomNameSet, RoomUsageNameSet;
	TArray<int> RoomIDs;
	TArray<float> UsageIDs;
	TArray<float> IDs;
	TArray<UVaRestJsonObject*> RoomJsonObj = InJson->GetObjectArrayField("roomList");

	TMap<int, TArray<FVector2D>> IndexMapRoomPs;
	TMap<FVector2D, TArray<FVector2D>> PointMapLocalRegion;
	TMap<int, TArray<FVector2D>> RoomIdMapSmallCenters;
	TMap<int, TArray<FVector2D>> ToiletRoomIDMapSmallCenters;
	TMap<int, TArray<int>> RoomIDMapToRemoveIndexs;

	for (int Index = 0; Index < RoomJsonObj.Num(); Index++)
	{
		TArray<FVector2D> AreaPoints;
		FVector2D SuitableCenter;
		TArray<UVaRestJsonObject*> AreaCoorJson = RoomJsonObj[Index]->GetObjectArrayField("areas");

		FString TempRoomNameString = RoomJsonObj[Index]->GetStringField("roomName");
		RoomNameSet.Add(TempRoomNameString);

		int TempRoomID = RoomJsonObj[Index]->GetIntegerField("roomId");
		RoomIDs.Add(TempRoomID);

		FString TempRoomUseString = RoomJsonObj[Index]->GetStringField("roomUsageName");
		RoomUsageNameSet.Add(TempRoomUseString);

		float TempUsageID = RoomJsonObj[Index]->GetNumberField("usageId");
		UsageIDs.Add(TempUsageID);

		IDs.Add(Index + 1);

		for (int AreaIndex = 0; AreaIndex < AreaCoorJson.Num(); AreaIndex++)
		{
			float TempX = AreaCoorJson[AreaIndex]->GetNumberField("x");
			float TempY = AreaCoorJson[AreaIndex]->GetNumberField("y");
			AreaPoints.AddUnique(FVector2D(TempX, TempY));
		}


		float VecX1 = AreaPoints[1].X - AreaPoints[0].X;
		float VecY1 = AreaPoints[1].Y - AreaPoints[0].Y;

		float VecX2 = AreaPoints[AreaPoints.Num() - 1].X;
		float VecY2 = AreaPoints[AreaPoints.Num() - 1].Y;
		float CrossResZ = VecX1 * VecY2 - VecY1 * VecX2;
		if (CrossResZ < 0)
		{
			for (int Jindex = 0; Jindex < AreaPoints.Num() / 2; Jindex++)
			{
				FVector2D TempVec = AreaPoints[Jindex];
				AreaPoints[Jindex] = AreaPoints[AreaPoints.Num() - 1 - Jindex];
				AreaPoints[AreaPoints.Num() - 1 - Jindex] = TempVec;
			}
		}

		FString LocalRoomName = RoomJsonObj[Index]->GetStringField("roomName");
		FString LocalUseName = RoomJsonObj[Index]->GetStringField("roomUsageName");

		if ((LocalRoomName == TEXT("客厅")) || (LocalRoomName == TEXT("起居室")))
		{
			TMap<FVector2D, TArray<FVector2D>> TempCenterMapLocalRegions;
			SmallRegionCenters.Empty();
			bool IsSuccess = FPolygonAlg::LocateCentersOfDiningOrLivingRegion(AreaPoints, SuitableCenter, SmallRegionCenters, TempCenterMapLocalRegions);
			if (!IsSuccess)
			{
				return false;
			}
			CameraLocations.Add(SuitableCenter);
			RoomIdMapSmallCenters.Add(TempRoomID, SmallRegionCenters);
			if (TempCenterMapLocalRegions.Contains(SuitableCenter))
			{
				PointMapLocalRegion.Add(SuitableCenter, TempCenterMapLocalRegions[SuitableCenter]);
			}
			TArray<AFurnitureModelActor*> ModelsOfRoom;
			FindModelsOfRoom(WorldContextObject, AreaPoints, ModelsOfRoom);
			TArray<int> TempToRemoveIndexs;
			for (int _CurP = 0; _CurP < SmallRegionCenters.Num(); ++_CurP)
			{
				for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
				{
					FBox TempBox = ModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
					FString ModelName = ModelsOfRoom[_CurM]->GetName();
					if (!ModelName.Contains(FString("Light")))
					{
						bool IfInModel = TempBox.IsInsideOrOn(FVector(SmallRegionCenters[_CurP], 130));
						if (IfInModel)
						{
							FVector FMin = TempBox.Min;
							FVector FMax = TempBox.Max;
							bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
							if (ModelBoxIsUseful)
							{
								TempToRemoveIndexs.AddUnique(_CurP);
							}
						}
					}
				}
			}

			if (TempToRemoveIndexs.Num() > 0)
			{
				RoomIDMapToRemoveIndexs.Add(TempRoomID, TempToRemoveIndexs);
			}

			for (int _CurF = 0; _CurF < SmallRegionCenters.Num(); ++_CurF)
			{
				if (!TempToRemoveIndexs.Contains(_CurF))
				{
					if (TempCenterMapLocalRegions.Contains(SmallRegionCenters[_CurF]))
					{
						PointMapLocalRegion.Add(SmallRegionCenters[_CurF], TempCenterMapLocalRegions[SmallRegionCenters[_CurF]]);
					}
				}
			}
			NumOfTotalPickPs = NumOfTotalPickPs + SmallRegionCenters.Num() - TempToRemoveIndexs.Num();
		}
		else if (LocalRoomName == TEXT("餐厅"))
		{
			TMap<FVector2D, TArray<FVector2D>> TempCenterMapLocalRegions;
			NewSmallRegionCenters.Empty();
			bool IsSuccess = FPolygonAlg::LocateCentersOfDiningOrLivingRegion(AreaPoints, SuitableCenter, NewSmallRegionCenters, TempCenterMapLocalRegions);
			if (!IsSuccess)
			{
				return false;
			}
			CameraLocations.Add(SuitableCenter);
			RoomIdMapSmallCenters.Add(TempRoomID, NewSmallRegionCenters);
			if (TempCenterMapLocalRegions.Contains(SuitableCenter))
			{
				PointMapLocalRegion.Add(SuitableCenter, TempCenterMapLocalRegions[SuitableCenter]);
			}

			TArray<AFurnitureModelActor*> ModelsOfRoom;
			FindModelsOfRoom(WorldContextObject, AreaPoints, ModelsOfRoom);
			TArray<int> TempToRemoveIndexs;
			for (int _CurP = 0; _CurP < NewSmallRegionCenters.Num(); ++_CurP)
			{
				for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
				{
					FBox TempBox = ModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
					FString ModelName = ModelsOfRoom[_CurM]->GetName();
					if (!ModelName.Contains(FString("Light")))
					{
						bool IfInModel = TempBox.IsInsideOrOn(FVector(NewSmallRegionCenters[_CurP], 130));
						if (IfInModel)
						{
							FVector FMin = TempBox.Min;
							FVector FMax = TempBox.Max;
							bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
							if (ModelBoxIsUseful)
							{
								TempToRemoveIndexs.AddUnique(_CurP);
							}
						}
					}
				}
			}

			if (TempToRemoveIndexs.Num() > 0)
			{
				RoomIDMapToRemoveIndexs.Add(TempRoomID, TempToRemoveIndexs);
			}
			
			for (int _CurF = 0; _CurF < NewSmallRegionCenters.Num(); ++_CurF)
			{
				if (!TempToRemoveIndexs.Contains(_CurF))
				{
					if (TempCenterMapLocalRegions.Contains(NewSmallRegionCenters[_CurF]))
					{
						PointMapLocalRegion.Add(NewSmallRegionCenters[_CurF], TempCenterMapLocalRegions[NewSmallRegionCenters[_CurF]]);
					}
				}
			}
			NumOfTotalPickPs = NumOfTotalPickPs + NewSmallRegionCenters.Num() - TempToRemoveIndexs.Num();
		}
		else if ((LocalRoomName == TEXT("主卧")) || (LocalRoomName == TEXT("次卧")) || (LocalRoomName == TEXT("儿童房")) || (LocalRoomName == TEXT("老人房"))
			|| (LocalRoomName == TEXT("榻榻米房")) || (LocalRoomName == TEXT("客人房")) || (LocalRoomName == TEXT("书房")) || (LocalRoomName == TEXT("健身房"))
			|| (LocalRoomName == TEXT("多功能房")))
		{
			TArray<FVector2D> TempSmallCenters;
			TMap<FVector2D, TArray<FVector2D>> TempCenterMapLocalRegions;
			bool IsCreated = FPolygonAlg::LocateCentersOfRoom(AreaPoints, SuitableCenter, TempSmallCenters, TempCenterMapLocalRegions);
			if (!IsCreated)
			{
				return false;
			}
			RoomIdMapSmallCenters.Add(TempRoomID, TempSmallCenters);
			CameraLocations.Add(SuitableCenter);

			if (TempCenterMapLocalRegions.Contains(SuitableCenter))
			{
				PointMapLocalRegion.Add(SuitableCenter, TempCenterMapLocalRegions[SuitableCenter]);
			}


			TArray<AFurnitureModelActor*> ModelsOfRoom;
			FindModelsOfRoom(WorldContextObject, AreaPoints, ModelsOfRoom);
			TArray<int> ToRemoveSmallIndexs;
			for (int _CurP = 0; _CurP < TempSmallCenters.Num(); ++_CurP)
			{
				for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
				{
					FBox TempBox = ModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
					FString ModelName = ModelsOfRoom[_CurM]->GetName();
					if (!ModelName.Contains(FString("Light")))
					{
						bool IfInModel = TempBox.IsInsideOrOn(FVector(TempSmallCenters[_CurP], 130));
						if (IfInModel)
						{
							FVector FMin = TempBox.Min;
							FVector FMax = TempBox.Max;
							bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
							if (ModelBoxIsUseful)
							{
								ToRemoveSmallIndexs.AddUnique(_CurP);
							}
						}
					}
				}
			}
			///////////////////定制家具过滤/////////////////////
			TArray<AHouseCustomActor*> CustomModelsOfRoom;
			FindCustomModelsOfRoom(WorldContextObject, AreaPoints, CustomModelsOfRoom);
			for (int _CurP = 0; _CurP < TempSmallCenters.Num(); ++_CurP)
			{
				for (int _CurM = 0; _CurM < CustomModelsOfRoom.Num(); ++_CurM)
				{
					FBox TempBox = CustomModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
					FString ModelName = CustomModelsOfRoom[_CurM]->GetName();
					if (!ModelName.Contains(FString("Light")))
					{
						bool IfInModel = TempBox.IsInsideOrOn(FVector(TempSmallCenters[_CurP], 130));
						if (IfInModel)
						{
							FVector FMin = TempBox.Min;
							FVector FMax = TempBox.Max;
							bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
							if (ModelBoxIsUseful)
							{
								ToRemoveSmallIndexs.AddUnique(_CurP);
							}
						}
					}
				}
			}
			///////////////////////////////////////////////////
			if (ToRemoveSmallIndexs.Num() > 0)
			{
				RoomIDMapToRemoveIndexs.Add(TempRoomID, ToRemoveSmallIndexs);
			}

			for (int _CurF = 0; _CurF < TempSmallCenters.Num(); ++_CurF)
			{
				if (!ToRemoveSmallIndexs.Contains(_CurF))
				{
					PointMapLocalRegion.Add(TempSmallCenters[_CurF], TempCenterMapLocalRegions[TempSmallCenters[_CurF]]);
				}
			}
			NumOfTotalPickPs = NumOfTotalPickPs + TempSmallCenters.Num() - ToRemoveSmallIndexs.Num();
		}
		else if ((LocalRoomName == TEXT("主阳台")) || (LocalRoomName == TEXT("生活阳台")) || (LocalRoomName == TEXT("休闲阳台")) || (LocalRoomName == TEXT("卧室阳台")))
		{
			TArray<FVector2D> TempSmallCenters;
			TMap<FVector2D, TArray<FVector2D>> TempCenterMapLocalRegions;
			bool IsCreated = FPolygonAlg::LocateCentersOfBalcony(AreaPoints, SuitableCenter, TempSmallCenters, TempCenterMapLocalRegions);
			if (!IsCreated)
			{
				return false;
			}
			RoomIdMapSmallCenters.Add(TempRoomID, TempSmallCenters);
			CameraLocations.Add(SuitableCenter);

			if (TempCenterMapLocalRegions.Contains(SuitableCenter))
			{
				PointMapLocalRegion.Add(SuitableCenter, TempCenterMapLocalRegions[SuitableCenter]);
			}
			TArray<AFurnitureModelActor*> ModelsOfRoom;
			FindModelsOfRoom(WorldContextObject, AreaPoints, ModelsOfRoom);
			TArray<int> ToRemoveSmallIndexs;
			for (int _CurP = 0; _CurP < TempSmallCenters.Num(); ++_CurP)
			{
				for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
				{
					FBox TempBox = ModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
					FString ModelName = ModelsOfRoom[_CurM]->GetName();
					if (!ModelName.Contains(FString("Light")))
					{
						bool IfInModel = TempBox.IsInsideOrOn(FVector(TempSmallCenters[_CurP], 130));
						if (IfInModel)
						{
							FVector FMin = TempBox.Min;
							FVector FMax = TempBox.Max;
							bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
							if (ModelBoxIsUseful)
							{
								ToRemoveSmallIndexs.AddUnique(_CurP);
							}
						}
					}
				}
			}

			if (ToRemoveSmallIndexs.Num() > 0)
			{
				RoomIDMapToRemoveIndexs.Add(TempRoomID, ToRemoveSmallIndexs);
			}

			for (int _CurF = 0; _CurF < TempSmallCenters.Num(); ++_CurF)
			{
				if (!ToRemoveSmallIndexs.Contains(_CurF))
				{
					PointMapLocalRegion.Add(TempSmallCenters[_CurF], TempCenterMapLocalRegions[TempSmallCenters[_CurF]]);
				}
			}
			NumOfTotalPickPs = NumOfTotalPickPs + TempSmallCenters.Num() - ToRemoveSmallIndexs.Num();
		}
		else if (LocalRoomName == TEXT("厨房"))
		{
			bool IsCreated = FPolygonAlg::LocateCenterOfKitchen(AreaPoints, SuitableCenter);
			if (!IsCreated)
			{
				return false;
			}
			bool IsUnUseful = false;
			TArray<AFurnitureModelActor*> TempModelsOfRoom;
			FindModelsOfRoom(WorldContextObject, AreaPoints, TempModelsOfRoom);
			for (int _CurM = 0; _CurM < TempModelsOfRoom.Num(); ++_CurM)
			{
				AFurnitureModelActor* TempFur = TempModelsOfRoom[_CurM];
				FBox TempBox = TempFur->GetComponentsBoundingBox(true);
				FString ModelName = TempFur->GetName();
				if (!ModelName.Contains(FString("Light")))
				{
					bool IsInModel = TempBox.IsInside(FVector(SuitableCenter, 130));
					if (IsInModel)
					{
						FVector FMin = TempBox.Min;
						FVector FMax = TempBox.Max;
						bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
						if (!ModelBoxIsUseful)
						{
							IsUnUseful = true;
						}
					}
				}
			}
			if (!IsUnUseful)
			{
				PointMapLocalRegion.Add(SuitableCenter, AreaPoints);
				CameraLocations.Add(SuitableCenter);
			}
			else
			{
				TArray<FVector>DoorPoints;
				bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomID, DoorPoints);
				if (!GetDoorSuccess)
				{
					PointMapLocalRegion.Add(SuitableCenter, AreaPoints);
					CameraLocations.Add(SuitableCenter);
				}
				else
				{
					TMap<int, TArray<FVector>> RoomIDMapHoleData;
					int NumOfDoors = DoorPoints.Num() / 8;
					RoomIDMapHoleData.Add(TempRoomID, DoorPoints);
					if (NumOfDoors >= 1)
					{
						FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
						FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
						DirVec = DirVec.GetSafeNormal();
						DirVec = DirVec.GetRotated(90);
						FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
						FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
						FVector2D TempVec1 = DoorCenter2D + 45 * DirVec;
						if (FPolygonAlg::JudgePointInPolygon(AreaPoints, TempVec1))
						{
							PointMapLocalRegion.Add(TempVec1, AreaPoints);
							CameraLocations.Add(TempVec1);
						}
						else
						{
							FVector2D TempP = DoorCenter2D - 45 * DirVec;
							if (FPolygonAlg::JudgePointInPolygon(AreaPoints, TempP))
							{
								PointMapLocalRegion.Add(TempP, AreaPoints);
								CameraLocations.Add(TempP);
							}
							else
							{
								PointMapLocalRegion.Add(SuitableCenter, AreaPoints);
								CameraLocations.Add(SuitableCenter);
							}
						}
					}
				}
			}

		}
		else if ((LocalRoomName == TEXT("主卫")) || (LocalRoomName == TEXT("客卫")) || (LocalRoomName == TEXT("卫生间")))
		{
			bool FindWall = false;
			int TargetIndex = 0;
			for (int _CurIndex = 0; _CurIndex < WallCenters.Num(); ++_CurIndex)
			{
				bool JudgeIfInRegion = FPolygonAlg::JudgePointInPolygon(AreaPoints, WallCenters[_CurIndex]);
				if (JudgeIfInRegion)
				{
					FindWall = true;
					TargetIndex = _CurIndex;
					break;
				}
			}

			if (FindWall)
			{
				TArray<int> LocalRemoveIndexs;
				TArray<FVector2D> PickCenters;
				TArray<FVector2D> WallPoints = IndexMapWallPs[TargetIndex];
				bool LocateSuccess = FPolygonAlg::LocateCentersOfSecondToilet(AreaPoints, WallPoints, PickCenters);
				if (LocateSuccess)
				{
					PointMapLocalRegion.Add(PickCenters[0], AreaPoints);
					PointMapLocalRegion.Add(PickCenters[1], AreaPoints);
					CameraLocations.Add(PickCenters[0]);
					TArray<FVector2D> TempToiletArr;
					TempToiletArr.Add(PickCenters[1]);
					ToiletRoomIDMapSmallCenters.Add(TempRoomID, TempToiletArr);
					NumOfTotalPickPs = NumOfTotalPickPs + 1;
				}
			}
			else
			{
				FVector2D TempLocateCenter;
				bool IsSuccess = FPolygonAlg::LocateCenterOfOneToilet(AreaPoints, TempLocateCenter);
				if (IsSuccess)
				{
					PointMapLocalRegion.Add(TempLocateCenter, AreaPoints);
					CameraLocations.Add(TempLocateCenter);
				}
			}
		}
		else if (LocalRoomName == TEXT("储藏间"))
		{
			FVector2D TempLoc;
			bool HasFound = FPolygonAlg::LocateSuitableCenter(AreaPoints, TempLoc);
			if (HasFound)
			{
				bool IsUnUseful = false;
				TArray<AFurnitureModelActor*> TempModelsOfRoom;
				FindModelsOfRoom(WorldContextObject, AreaPoints, TempModelsOfRoom);
				for (int _CurM = 0; _CurM < TempModelsOfRoom.Num(); ++_CurM)
				{
					AFurnitureModelActor* TempFur = TempModelsOfRoom[_CurM];
					FBox TempBox = TempFur->GetComponentsBoundingBox(true);
					FString ModelName = TempFur->GetName();
					if (!ModelName.Contains(FString("Light")))
					{
						bool IsInModel = TempBox.IsInside(FVector(TempLoc, 130));
						if (IsInModel)
						{
							IsUnUseful = true;
							break;
						}
					}
				}
				if (!IsUnUseful)
				{
					PointMapLocalRegion.Add(TempLoc, AreaPoints);
					CameraLocations.Add(TempLoc);
				}
				else
				{
					TArray<FVector>DoorPoints;
					bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomID, DoorPoints);
					if (!GetDoorSuccess)
					{
						PointMapLocalRegion.Add(TempLoc, AreaPoints);
						CameraLocations.Add(TempLoc);
					}
					else
					{
						TMap<int, TArray<FVector>> RoomIDMapHoleData;
						int NumOfDoors = DoorPoints.Num() / 8;
						RoomIDMapHoleData.Add(TempRoomID, DoorPoints);
						if (NumOfDoors >= 1)
						{
							FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
							FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
							DirVec = DirVec.GetSafeNormal();
							DirVec = DirVec.GetRotated(90);
							FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
							FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
							FVector2D TempVec1 = DoorCenter2D + 22 * DirVec;
							if (FPolygonAlg::JudgePointInPolygon(AreaPoints, TempVec1))
							{
								PointMapLocalRegion.Add(TempVec1, AreaPoints);
								CameraLocations.Add(TempVec1);
							}
							else
							{
								FVector2D TempP = DoorCenter2D - 22 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(AreaPoints, TempP))
								{
									PointMapLocalRegion.Add(TempP, AreaPoints);
									CameraLocations.Add(TempP);
								}
								else
								{
									PointMapLocalRegion.Add(TempLoc, AreaPoints);
									CameraLocations.Add(TempLoc);
								}
							}
						}
					}
				}
			}
		}
		else if ((LocalRoomName == TEXT("衣帽间")) || (LocalRoomName == TEXT("茶室")))
		{
			FVector2D TempLoc;
			bool HasFound = FPolygonAlg::LocateSuitableCenter(AreaPoints, TempLoc);
			if (HasFound)
			{
				bool IsUnUseful = false;
				TArray<AFurnitureModelActor*> TempModelsOfRoom;
				FindModelsOfRoom(WorldContextObject, AreaPoints, TempModelsOfRoom);
				for (int _CurM = 0; _CurM < TempModelsOfRoom.Num(); ++_CurM)
				{
					AFurnitureModelActor* TempFur = TempModelsOfRoom[_CurM];
					FBox TempBox = TempFur->GetComponentsBoundingBox(true);
					FString ModelName = TempFur->GetName();
					if (!ModelName.Contains(FString("Light")))
					{
						bool IsInModel = TempBox.IsInside(FVector(TempLoc, 130));
						if (IsInModel)
						{
							IsUnUseful = true;
							break;
						}
					}
				}
				if (!IsUnUseful)
				{
					PointMapLocalRegion.Add(TempLoc, AreaPoints);
					CameraLocations.Add(TempLoc);
				}
				else
				{
					TArray<FVector>DoorPoints;
					bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRoomID, DoorPoints);
					if (!GetDoorSuccess)
					{
						PointMapLocalRegion.Add(TempLoc, AreaPoints);
						CameraLocations.Add(TempLoc);
					}
					else
					{
						TMap<int, TArray<FVector>> RoomIDMapHoleData;
						int NumOfDoors = DoorPoints.Num() / 8;
						RoomIDMapHoleData.Add(TempRoomID, DoorPoints);
						if (NumOfDoors >= 1)
						{
							FVector TempDirVec = DoorPoints[1] - DoorPoints[0];
							FVector2D DirVec = FVector2D(TempDirVec.X, TempDirVec.Y);
							DirVec = DirVec.GetSafeNormal();
							DirVec = DirVec.GetRotated(90);
							FVector DoorCenter3D = 0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]);
							FVector2D DoorCenter2D = FVector2D(DoorCenter3D.X, DoorCenter3D.Y);
							FVector2D TempVec1 = DoorCenter2D + 40 * DirVec;
							if (FPolygonAlg::JudgePointInPolygon(AreaPoints, TempVec1))
							{
								PointMapLocalRegion.Add(TempVec1, AreaPoints);
								CameraLocations.Add(TempVec1);
							}
							else
							{
								FVector2D TempP = DoorCenter2D - 40 * DirVec;
								if (FPolygonAlg::JudgePointInPolygon(AreaPoints, TempP))
								{
									PointMapLocalRegion.Add(TempP, AreaPoints);
									CameraLocations.Add(TempP);
								}
								else
								{
									PointMapLocalRegion.Add(TempLoc, AreaPoints);
									CameraLocations.Add(TempLoc);
								}
							}
						}
					}
				}
			}
		}
		else
		{
			bool IsCreated = FPolygonAlg::LocateSuitableCenter(AreaPoints, SuitableCenter);
			if (!IsCreated)
			{
				return false;
			}
			PointMapLocalRegion.Add(SuitableCenter, AreaPoints);
			CameraLocations.Add(SuitableCenter);
		}
	}
	NumOfTotalPickPs = NumOfTotalPickPs + CameraLocations.Num();

	if (!LocationJson)
		LocationJson = UVaRestJsonObject::ConstructJsonObject(WorldContextObject);


	float WallHeight = 0.0;
	TArray<UVaRestJsonObject*> WallArray = InJson->GetObjectArrayField("walls");
	for (int Index = 0; Index < WallArray.Num(); Index++)
	{
		TArray<FVector2D> AreaPoints;
		FVector2D SuitableCenter;
		TArray<UVaRestJsonObject*> WallCoorJson = WallArray[Index]->GetObjectArrayField("wallPoints");
		for (int WallIndex = 0; WallIndex < WallCoorJson.Num(); WallIndex++)
		{
			float TempZ = WallCoorJson[WallIndex]->GetNumberField("z");
			if (TempZ != 0)
			{
				WallHeight = TempZ;
				break;
			}
		}
	}

	int AreaNum = CameraLocations.Num();
	TArray<UVaRestJsonObject*> CameraPointArray;
	for (int Index = 0; Index < AreaNum; Index++)
	{
		UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();

		UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
		SinglePointObj->SetNumberField("x", CameraLocations[Index].X);
		SinglePointObj->SetNumberField("y", CameraLocations[Index].Y);
		SinglePointObj->SetNumberField("z", 130);

		TArray<UVaRestJsonObject*> PointObjArrTemp;
		PointObjArrTemp.Emplace(SinglePointObj);
		TempPoint->SetObjectArrayField("point", PointObjArrTemp);
		TempPoint->SetStringField("roomName", RoomNameSet[Index]);
		TempPoint->SetIntegerField("roomId", RoomIDs[Index]);
		TempPoint->SetStringField("roomUsageName", RoomUsageNameSet[Index]);
		TempPoint->SetNumberField("usageId", UsageIDs[Index]);
		TempPoint->SetNumberField("id", IDs[Index]);
		CameraPointArray.Add(TempPoint);

	}
	bool DivideAreaSuccess = DivideAreas(WorldContextObject, InJson, GroupRoomIDs);
	int NumOfFloors = GroupRoomIDs.Num();
	TArray<UVaRestJsonObject*> NewCameraPointArray;
	int idOrder = 0;
	TArray<FString> AllNameStrings;
	/////////////////////统计客厅用途信息并排序////////////////////////////

	TMap<int, int> LivingRoomUseIndexMapRoomID;
	TArray<int> LivingRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("客厅")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					LivingRoomUseIndexArr.Add(TempNumber);
					LivingRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				LivingRoomUseIndexArr.Add(0);
				LivingRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	LivingRoomUseIndexArr.Sort();
	TArray<int> TotalLivingRoomIDs;
	for (int _CurI = 0; _CurI < LivingRoomUseIndexArr.Num(); ++_CurI)
	{
		int UseIndex = LivingRoomUseIndexArr[_CurI];
		int PairedRoomID = LivingRoomUseIndexMapRoomID[UseIndex];
		TotalLivingRoomIDs.Add(PairedRoomID);
	}
	FGroupRoomIDs TempLivingInts;
	TempLivingInts.GroupIndex = 0;
	TempLivingInts.RoomIDs = TotalLivingRoomIDs;
	GroupMapLivingOrDiningRoomIDs.Add(TempLivingInts);
	/////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////统计餐厅用途信息并排序//////////////////////////////////////////////
	TMap<int, int> DiningRoomUseIndexMapRoomID;
	TArray<int> DiningRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("餐厅")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					DiningRoomUseIndexArr.Add(TempNumber);
					DiningRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				DiningRoomUseIndexArr.Add(0);
				DiningRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	DiningRoomUseIndexArr.Sort();

	TArray<int> TotalDiningRoomIDs;
	for (int _CurI = 0; _CurI < DiningRoomUseIndexArr.Num(); ++_CurI)
	{
		int UseIndex = DiningRoomUseIndexArr[_CurI];
		int PairedRoomID = DiningRoomUseIndexMapRoomID[UseIndex];
		TotalDiningRoomIDs.Add(PairedRoomID);
	}
	FGroupRoomIDs TempDiningInts;
	TempDiningInts.GroupIndex = 1;
	TempDiningInts.RoomIDs = TotalDiningRoomIDs;
	GroupMapLivingOrDiningRoomIDs.Add(TempDiningInts);
	//////////////////////////////////////////////////////////////////////////////////////////
	////////////////////统计主卧用途信息并排序////////////////////////////////////////////////
	TMap<int, int> FirstRoomUseIndexMapRoomID;
	TArray<int> FirstRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("主卧")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					FirstRoomUseIndexArr.Add(TempNumber);
					FirstRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				FirstRoomUseIndexArr.Add(0);
				FirstRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	FirstRoomUseIndexArr.Sort();
	//////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计次卧个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> SecondRoomUseIndexMapRoomID;
	TArray<int> SecondRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("次卧")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					SecondRoomUseIndexArr.Add(TempNumber);
					SecondRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				SecondRoomUseIndexArr.Add(0);
				SecondRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	SecondRoomUseIndexArr.Sort();
	/////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计儿童房的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> ChildRoomUseIndexMapRoomID;
	TArray<int> ChildRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("儿童房")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					ChildRoomUseIndexArr.Add(TempNumber);
					ChildRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				ChildRoomUseIndexArr.Add(0);
				ChildRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	ChildRoomUseIndexArr.Sort();
	//////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计老人房的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> OlderRoomUseIndexMapRoomID;
	TArray<int> OlderRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("老人房")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					OlderRoomUseIndexArr.Add(TempNumber);
					OlderRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				OlderRoomUseIndexArr.Add(0);
				OlderRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	OlderRoomUseIndexArr.Sort();
	////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计榻榻米房的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> TatamiRoomUseIndexMapRoomID;
	TArray<int>TatamiRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("榻榻米房")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					TatamiRoomUseIndexArr.Add(TempNumber);
					TatamiRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				TatamiRoomUseIndexArr.Add(0);
				TatamiRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	TatamiRoomUseIndexArr.Sort();
	////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计书房的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> StudyRoomUseIndexMapRoomID;
	TArray<int>StudyRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("书房")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					StudyRoomUseIndexArr.Add(TempNumber);
					StudyRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				StudyRoomUseIndexArr.Add(0);
				StudyRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	StudyRoomUseIndexArr.Sort();
	////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计多功能房的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> MultiFunctionRoomUseIndexMapRoomID;
	TArray<int>MultiFunctionRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("多功能房")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					MultiFunctionRoomUseIndexArr.Add(TempNumber);
					MultiFunctionRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				MultiFunctionRoomUseIndexArr.Add(0);
				MultiFunctionRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	MultiFunctionRoomUseIndexArr.Sort();
	////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计起居室的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> StartRoomUseIndexMapRoomID;
	TArray<int> StartRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("起居室")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					StartRoomUseIndexArr.Add(TempNumber);
					StartRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				StartRoomUseIndexArr.Add(0);
				StartRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	StartRoomUseIndexArr.Sort();
	////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计储藏间的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> StoreRoomUseIndexMapRoomID;
	TArray<int> StoreRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("储藏间")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					StoreRoomUseIndexArr.Add(TempNumber);
					StoreRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				StoreRoomUseIndexArr.Add(0);
				StoreRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	StoreRoomUseIndexArr.Sort();
	////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计衣帽间的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> CloakRoomUseIndexMapRoomID;
	TArray<int> CloakRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("衣帽间")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					CloakRoomUseIndexArr.Add(TempNumber);
					CloakRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				CloakRoomUseIndexArr.Add(0);
				CloakRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	CloakRoomUseIndexArr.Sort();
	////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计厨房的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> KitchenRoomUseIndexMapRoomID;
	TArray<int> KitchenRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("厨房")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					KitchenRoomUseIndexArr.Add(TempNumber);
					KitchenRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				KitchenRoomUseIndexArr.Add(0);
				KitchenRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	KitchenRoomUseIndexArr.Sort();
	////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计主卫的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> FirstToiletRoomUseIndexMapRoomID;
	TArray<int> FirstToiletRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("主卫")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					FirstToiletRoomUseIndexArr.Add(TempNumber);
					FirstToiletRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				FirstToiletRoomUseIndexArr.Add(0);
				FirstToiletRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	FirstToiletRoomUseIndexArr.Sort();
	//////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计客卫的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> SecondToiletRoomUseIndexMapRoomID;
	TArray<int> SecondToiletRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("客卫")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					SecondToiletRoomUseIndexArr.Add(TempNumber);
					SecondToiletRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				SecondToiletRoomUseIndexArr.Add(0);
				SecondToiletRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	SecondToiletRoomUseIndexArr.Sort();
	//////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计生活阳台的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> LivingBalconyRoomUseIndexMapRoomID;
	TArray<int> LivingBalconyRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("生活阳台")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					LivingBalconyRoomUseIndexArr.Add(TempNumber);
					LivingBalconyRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				LivingBalconyRoomUseIndexArr.Add(0);
				LivingBalconyRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	LivingBalconyRoomUseIndexArr.Sort();
	//////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////统计休闲阳台的个数以及匹配情况////////////////////////////////////////////
	TMap<int, int> LeisureBalconyRoomUseIndexMapRoomID;
	TArray<int> LeisureBalconyRoomUseIndexArr;
	for (int _CurRoom = 0; _CurRoom < AreaNum; ++_CurRoom)
	{
		FString TempString = CameraPointArray[_CurRoom]->GetStringField("roomUsageName");
		int TempRoomID = CameraPointArray[_CurRoom]->GetIntegerField("roomId");
		if (TempString.Contains(TEXT("休闲阳台")))
		{
			FString LeftStr;
			FString RightStr;
			bool IsSplitted = RoomUsageNameSet[_CurRoom].Split("-", &LeftStr, &RightStr);
			if (IsSplitted)
			{
				if ((*LeftStr != nullptr) && (*RightStr != nullptr))
				{
					int32 TempNumber = FCString::Atoi(*RightStr);
					LeisureBalconyRoomUseIndexArr.Add(TempNumber);
					LeisureBalconyRoomUseIndexMapRoomID.Add(TempNumber, TempRoomID);
				}
			}
			else
			{
				LeisureBalconyRoomUseIndexArr.Add(0);
				LeisureBalconyRoomUseIndexMapRoomID.Add(0, TempRoomID);
			}
		}
	}
	LeisureBalconyRoomUseIndexArr.Sort();
	//////////////////////////////////////////////////////////////////////////////////////////////////////
	TArray<int> HasProcessed;


	////////////////////////按用途顺序输出客厅相关数据json////////////////////////////////////////////////
	for (int _CurNum = 0; _CurNum < LivingRoomUseIndexArr.Num(); ++_CurNum)
	{
		int BaseRoomID = LivingRoomUseIndexMapRoomID[LivingRoomUseIndexArr[_CurNum]];
		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);
					if (NumOfFloors == 1)
					{
						SinglePointObj->SetNumberField("floor", 1);
					}
					else if (NumOfFloors == 2)
					{
						for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
						{
							TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
							if (TempRoomIDs.Contains(BaseRoomID))
							{
								SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
							}
						}
					}
					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Add(SinglePointObj);
					/////////////////////////////////
					if (RoomIdMapSmallCenters.Contains(BaseRoomID))
					{
						TArray<FVector2D> TempSmallCentersArr = RoomIdMapSmallCenters[BaseRoomID];
						TArray<int> CutIntArr;
						if (RoomIDMapToRemoveIndexs.Contains(TempIDOfRoom))
						{
							CutIntArr = RoomIDMapToRemoveIndexs[TempIDOfRoom];
						}
						for (int PIndex = 0; PIndex < TempSmallCentersArr.Num(); PIndex++)
						{
							if (!CutIntArr.Contains(PIndex))
							{
								idOrder++;
								UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
								TSinglePointObj->SetNumberField("id", idOrder);
								TSinglePointObj->SetNumberField("x", TempSmallCentersArr[PIndex].X);
								TSinglePointObj->SetNumberField("y", TempSmallCentersArr[PIndex].Y);
								TSinglePointObj->SetNumberField("z", 130);
								TSinglePointObj->SetNumberField("markType", 0);

								if (NumOfFloors == 1)
								{
									TSinglePointObj->SetNumberField("floor", 1);
								}
								else if (NumOfFloors == 2)
								{
									for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
									{
										TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
										if (TempRoomIDs.Contains(TempIDOfRoom))
										{
											TSinglePointObj->SetNumberField("floor", 1 + _CurFloor);
										}
									}
								}

								if (PointMapLocalRegion.Contains(TempSmallCentersArr[PIndex]))
								{
									TArray<FVector2D> LocalPoints = PointMapLocalRegion[TempSmallCentersArr[PIndex]];
									TArray<UVaRestJsonObject*> LocalBoundPoints;
									for (int IP = 0; IP < LocalPoints.Num(); ++IP)
									{
										UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
										TempPoint->SetNumberField("x", LocalPoints[IP].X);
										TempPoint->SetNumberField("y", LocalPoints[IP].Y);
										LocalBoundPoints.Add(TempPoint);
									}
									TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
								}
								PointObjArrTemp.Add(TSinglePointObj);
							}
						}
					}
					//////////////////////////

					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("客厅"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}
		}
	}
	////////////////////////////////////////////////////////////////////////////////////////////////////


	////////////////////////按用途顺序输出餐厅相关数据json//////////////////////////////////////////////
	for (int _CurNum = 0; _CurNum < DiningRoomUseIndexArr.Num(); ++_CurNum)
	{
		int BaseRoomID = DiningRoomUseIndexMapRoomID[DiningRoomUseIndexArr[_CurNum]];
		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);

					if (NumOfFloors == 1)
					{
						SinglePointObj->SetNumberField("floor", 1);
					}
					else if (NumOfFloors == 2)
					{
						for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
						{
							TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
							if (TempRoomIDs.Contains(TempIDOfRoom))
							{
								SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
							}
						}
					}

					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Add(SinglePointObj);
					/////////////////////////////////
					if (RoomIdMapSmallCenters.Contains(TempIDOfRoom))
					{
						TArray<FVector2D> TempSmallCentersArr = RoomIdMapSmallCenters[TempIDOfRoom];

						TArray<int> CutIntArr;
						if (RoomIDMapToRemoveIndexs.Contains(TempIDOfRoom))
						{
							CutIntArr = RoomIDMapToRemoveIndexs[TempIDOfRoom];
						}
						for (int PIndex = 0; PIndex < TempSmallCentersArr.Num(); PIndex++)
						{
							if (!CutIntArr.Contains(PIndex))
							{
								idOrder++;
								UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
								TSinglePointObj->SetNumberField("id", idOrder);
								TSinglePointObj->SetNumberField("x", TempSmallCentersArr[PIndex].X);
								TSinglePointObj->SetNumberField("y", TempSmallCentersArr[PIndex].Y);
								TSinglePointObj->SetNumberField("z", 130);
								TSinglePointObj->SetNumberField("markType", 0);

								if (NumOfFloors == 1)
								{
									TSinglePointObj->SetNumberField("floor", 1);
								}
								else if (NumOfFloors == 2)
								{
									for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
									{
										TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
										if (TempRoomIDs.Contains(TempIDOfRoom))
										{
											TSinglePointObj->SetNumberField("floor", 1 + _CurFloor);
										}
									}
								}

								if (PointMapLocalRegion.Contains(TempSmallCentersArr[PIndex]))
								{
									TArray<FVector2D> LocalPoints = PointMapLocalRegion[TempSmallCentersArr[PIndex]];
									TArray<UVaRestJsonObject*> LocalBoundPoints;
									for (int IP = 0; IP < LocalPoints.Num(); ++IP)
									{
										UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
										TempPoint->SetNumberField("x", LocalPoints[IP].X);
										TempPoint->SetNumberField("y", LocalPoints[IP].Y);
										LocalBoundPoints.Add(TempPoint);
									}
									TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
								}
								PointObjArrTemp.Add(TSinglePointObj);
							}
						}
					}
					//////////////////////////

					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("餐厅"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}

		}
	}


	/////////////////////////按用途顺序输出主卧相关数据json/////////////////////////////////////////////
	for (int _CurNum = 0; _CurNum < FirstRoomUseIndexArr.Num(); ++_CurNum)
	{
		int BaseRoomID = FirstRoomUseIndexMapRoomID[FirstRoomUseIndexArr[_CurNum]];
		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);

					if (NumOfFloors == 1)
					{
						SinglePointObj->SetNumberField("floor", 1);
					}
					else if (NumOfFloors == 2)
					{
						for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
						{
							TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
							if (TempRoomIDs.Contains(TempIDOfRoom))
							{
								SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
							}
						}
					}

					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;

					PointObjArrTemp.Add(SinglePointObj);



					/////////////////////////////////
					if (RoomIdMapSmallCenters.Contains(TempIDOfRoom))
					{
						TArray<FVector2D> TempSmallCentersArr = RoomIdMapSmallCenters[TempIDOfRoom];

						TArray<int> CutIntArr;
						if (RoomIDMapToRemoveIndexs.Contains(TempIDOfRoom))
						{
							CutIntArr = RoomIDMapToRemoveIndexs[TempIDOfRoom];
						}

						for (int PIndex = 0; PIndex < TempSmallCentersArr.Num(); PIndex++)
						{
							if (!CutIntArr.Contains(PIndex))
							{
								idOrder++;
								UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
								TSinglePointObj->SetNumberField("id", idOrder);
								TSinglePointObj->SetNumberField("x", TempSmallCentersArr[PIndex].X);
								TSinglePointObj->SetNumberField("y", TempSmallCentersArr[PIndex].Y);
								TSinglePointObj->SetNumberField("z", 130);
								TSinglePointObj->SetNumberField("markType", 0);

								if (NumOfFloors == 1)
								{
									TSinglePointObj->SetNumberField("floor", 1);
								}
								else if (NumOfFloors == 2)
								{
									for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
									{
										TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
										if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
										{
											TSinglePointObj->SetNumberField("floor", 1 + _CurFloor);
										}
									}
								}

								if (PointMapLocalRegion.Contains(TempSmallCentersArr[PIndex]))
								{
									TArray<FVector2D> LocalPoints = PointMapLocalRegion[TempSmallCentersArr[PIndex]];
									TArray<UVaRestJsonObject*> LocalBoundPoints;
									for (int IP = 0; IP < LocalPoints.Num(); ++IP)
									{
										UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
										TempPoint->SetNumberField("x", LocalPoints[IP].X);
										TempPoint->SetNumberField("y", LocalPoints[IP].Y);
										LocalBoundPoints.Add(TempPoint);
									}
									TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
								}
								PointObjArrTemp.Add(TSinglePointObj);
							}
						}
					}
					///////////////////////////////////////////////
					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("主卧"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}
		}
	}


	//////////////////////////按用途顺序输出次卧相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < SecondRoomUseIndexArr.Num(); ++_CurNum)
	{
		int BaseRoomID = SecondRoomUseIndexMapRoomID[SecondRoomUseIndexArr[_CurNum]];
		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);

					if (NumOfFloors == 1)
					{
						SinglePointObj->SetNumberField("floor", 1);
					}
					else if (NumOfFloors == 2)
					{
						for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
						{
							TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
							if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
							{
								SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
							}
						}
					}

					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Add(SinglePointObj);
					/////////////////////////////////
					if (RoomIdMapSmallCenters.Contains(TempIDOfRoom))
					{
						TArray<FVector2D> TempSmallCentersArr = RoomIdMapSmallCenters[TempIDOfRoom];

						TArray<int> CutIntArr;
						if (RoomIDMapToRemoveIndexs.Contains(TempIDOfRoom))
						{
							CutIntArr = RoomIDMapToRemoveIndexs[TempIDOfRoom];
						}

						for (int PIndex = 0; PIndex < TempSmallCentersArr.Num(); PIndex++)
						{
							if (!CutIntArr.Contains(PIndex))
							{
								idOrder++;
								UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
								TSinglePointObj->SetNumberField("id", idOrder);
								TSinglePointObj->SetNumberField("x", TempSmallCentersArr[PIndex].X);
								TSinglePointObj->SetNumberField("y", TempSmallCentersArr[PIndex].Y);
								TSinglePointObj->SetNumberField("z", 130);
								TSinglePointObj->SetNumberField("markType", 0);

								if (NumOfFloors == 1)
								{
									TSinglePointObj->SetNumberField("floor", 1);
								}
								else if (NumOfFloors == 2)
								{
									for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
									{
										TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
										if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
										{
											TSinglePointObj->SetNumberField("floor", 1 + _CurFloor);
										}
									}
								}

								if (PointMapLocalRegion.Contains(TempSmallCentersArr[PIndex]))
								{
									TArray<FVector2D> LocalPoints = PointMapLocalRegion[TempSmallCentersArr[PIndex]];
									TArray<UVaRestJsonObject*> LocalBoundPoints;
									for (int IP = 0; IP < LocalPoints.Num(); ++IP)
									{
										UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
										TempPoint->SetNumberField("x", LocalPoints[IP].X);
										TempPoint->SetNumberField("y", LocalPoints[IP].Y);
										LocalBoundPoints.Add(TempPoint);
									}
									TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
								}
								PointObjArrTemp.Add(TSinglePointObj);
							}
						}
					}
					///////////////////////////////////////////////
					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("次卧"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}
		}
	}

	//////////////////////////按用途顺序输出儿童房相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < ChildRoomUseIndexArr.Num(); ++_CurNum)
	{
		int BaseRoomID = ChildRoomUseIndexMapRoomID[ChildRoomUseIndexArr[_CurNum]];

		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);

					if (NumOfFloors == 1)
					{
						SinglePointObj->SetNumberField("floor", 1);
					}
					else if (NumOfFloors == 2)
					{
						for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
						{
							TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
							if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
							{
								SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
							}
						}
					}

					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Emplace(SinglePointObj);


					/////////////////////////////////
					if (RoomIdMapSmallCenters.Contains(TempIDOfRoom))
					{
						TArray<FVector2D> TempSmallCentersArr = RoomIdMapSmallCenters[TempIDOfRoom];

						TArray<int> CutIntArr;
						if (RoomIDMapToRemoveIndexs.Contains(TempIDOfRoom))
						{
							CutIntArr = RoomIDMapToRemoveIndexs[TempIDOfRoom];
						}

						for (int PIndex = 0; PIndex < TempSmallCentersArr.Num(); PIndex++)
						{
							if (!CutIntArr.Contains(PIndex))
							{
								idOrder++;
								UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
								TSinglePointObj->SetNumberField("id", idOrder);
								TSinglePointObj->SetNumberField("x", TempSmallCentersArr[PIndex].X);
								TSinglePointObj->SetNumberField("y", TempSmallCentersArr[PIndex].Y);
								TSinglePointObj->SetNumberField("z", 130);
								TSinglePointObj->SetNumberField("markType", 0);

								if (NumOfFloors == 1)
								{
									TSinglePointObj->SetNumberField("floor", 1);
								}
								else if (NumOfFloors == 2)
								{
									for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
									{
										TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
										if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
										{
											TSinglePointObj->SetNumberField("floor", 1 + _CurFloor);
										}
									}
								}

								if (PointMapLocalRegion.Contains(TempSmallCentersArr[PIndex]))
								{
									TArray<FVector2D> LocalPoints = PointMapLocalRegion[TempSmallCentersArr[PIndex]];
									TArray<UVaRestJsonObject*> LocalBoundPoints;
									for (int IP = 0; IP < LocalPoints.Num(); ++IP)
									{
										UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
										TempPoint->SetNumberField("x", LocalPoints[IP].X);
										TempPoint->SetNumberField("y", LocalPoints[IP].Y);
										LocalBoundPoints.Add(TempPoint);
									}
									TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
								}
								PointObjArrTemp.Add(TSinglePointObj);
							}
						}
					}
					///////////////////////////////////////////////
					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("儿童房"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}
		}
	}

	//////////////////////////按用途顺序输出老人房相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < OlderRoomUseIndexArr.Num(); ++_CurNum)
	{
		int BaseRoomID = OlderRoomUseIndexMapRoomID[OlderRoomUseIndexArr[_CurNum]];

		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);

					if (NumOfFloors == 1)
					{
						SinglePointObj->SetNumberField("floor", 1);
					}
					else if (NumOfFloors == 2)
					{
						for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
						{
							TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
							if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
							{
								SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
							}
						}
					}

					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Emplace(SinglePointObj);

					/////////////////////////////////
					if (RoomIdMapSmallCenters.Contains(TempIDOfRoom))
					{
						TArray<FVector2D> TempSmallCentersArr = RoomIdMapSmallCenters[TempIDOfRoom];

						TArray<int> CutIntArr;
						if (RoomIDMapToRemoveIndexs.Contains(TempIDOfRoom))
						{
							CutIntArr = RoomIDMapToRemoveIndexs[TempIDOfRoom];
						}

						for (int PIndex = 0; PIndex < TempSmallCentersArr.Num(); PIndex++)
						{
							if (!CutIntArr.Contains(PIndex))
							{
								idOrder++;
								UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
								TSinglePointObj->SetNumberField("id", idOrder);
								TSinglePointObj->SetNumberField("x", TempSmallCentersArr[PIndex].X);
								TSinglePointObj->SetNumberField("y", TempSmallCentersArr[PIndex].Y);
								TSinglePointObj->SetNumberField("z", 130);
								TSinglePointObj->SetNumberField("markType", 0);

								if (NumOfFloors == 1)
								{
									TSinglePointObj->SetNumberField("floor", 1);
								}
								else if (NumOfFloors == 2)
								{
									for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
									{
										TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
										if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
										{
											TSinglePointObj->SetNumberField("floor", 1 + _CurFloor);
										}
									}
								}

								if (PointMapLocalRegion.Contains(TempSmallCentersArr[PIndex]))
								{
									TArray<FVector2D> LocalPoints = PointMapLocalRegion[TempSmallCentersArr[PIndex]];
									TArray<UVaRestJsonObject*> LocalBoundPoints;
									for (int IP = 0; IP < LocalPoints.Num(); ++IP)
									{
										UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
										TempPoint->SetNumberField("x", LocalPoints[IP].X);
										TempPoint->SetNumberField("y", LocalPoints[IP].Y);
										LocalBoundPoints.Add(TempPoint);
									}
									TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
								}
								PointObjArrTemp.Add(TSinglePointObj);
							}
						}
					}
					///////////////////////////////////////////////
					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("老人房"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}

		}
	}

	//////////////////////////按用途顺序输出榻榻米房相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < TatamiRoomUseIndexArr.Num(); ++_CurNum)
	{
		int BaseRoomID = TatamiRoomUseIndexMapRoomID[TatamiRoomUseIndexArr[_CurNum]];

		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);
					if (NumOfFloors == 1)
					{
						SinglePointObj->SetNumberField("floor", 1);
					}
					else if (NumOfFloors == 2)
					{
						for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
						{
							TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
							if (TempRoomIDs.Contains(TempIDOfRoom))
							{
								SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
							}
						}
					}

					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Emplace(SinglePointObj);



					/////////////////////////////////
					if (RoomIdMapSmallCenters.Contains(TempIDOfRoom))
					{
						TArray<FVector2D> TempSmallCentersArr = RoomIdMapSmallCenters[TempIDOfRoom];

						TArray<int> CutIntArr;
						if (RoomIDMapToRemoveIndexs.Contains(TempIDOfRoom))
						{
							CutIntArr = RoomIDMapToRemoveIndexs[TempIDOfRoom];
						}

						for (int PIndex = 0; PIndex < TempSmallCentersArr.Num(); PIndex++)
						{
							if (!CutIntArr.Contains(PIndex))
							{
								idOrder++;
								UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
								TSinglePointObj->SetNumberField("id", idOrder);
								TSinglePointObj->SetNumberField("x", TempSmallCentersArr[PIndex].X);
								TSinglePointObj->SetNumberField("y", TempSmallCentersArr[PIndex].Y);
								TSinglePointObj->SetNumberField("z", 130);
								TSinglePointObj->SetNumberField("markType", 0);

								if (NumOfFloors == 1)
								{
									TSinglePointObj->SetNumberField("floor", 1);
								}
								else if (NumOfFloors == 2)
								{
									for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
									{
										TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
										if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
										{
											TSinglePointObj->SetNumberField("floor", 1 + _CurFloor);
										}
									}
								}

								if (PointMapLocalRegion.Contains(TempSmallCentersArr[PIndex]))
								{
									TArray<FVector2D> LocalPoints = PointMapLocalRegion[TempSmallCentersArr[PIndex]];
									TArray<UVaRestJsonObject*> LocalBoundPoints;
									for (int IP = 0; IP < LocalPoints.Num(); ++IP)
									{
										UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
										TempPoint->SetNumberField("x", LocalPoints[IP].X);
										TempPoint->SetNumberField("y", LocalPoints[IP].Y);
										LocalBoundPoints.Add(TempPoint);
									}
									TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
								}
								PointObjArrTemp.Add(TSinglePointObj);
							}
						}
					}
					///////////////////////////////////////////////
					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("榻榻米房"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}

		}

	}

	//////////////////////////按用途顺序输出书房相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum <StudyRoomUseIndexArr.Num(); ++_CurNum)
	{
		int BaseRoomID =StudyRoomUseIndexMapRoomID[StudyRoomUseIndexArr[_CurNum]];

		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);

					if (NumOfFloors == 1)
					{
						SinglePointObj->SetNumberField("floor", 1);
					}
					else if (NumOfFloors == 2)
					{
						for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
						{
							TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
							if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
							{
								SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
							}
						}
					}

					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Emplace(SinglePointObj);

					/////////////////////////////////
					if (RoomIdMapSmallCenters.Contains(TempIDOfRoom))
					{
						TArray<FVector2D> TempSmallCentersArr = RoomIdMapSmallCenters[TempIDOfRoom];

						TArray<int> CutIntArr;
						if (RoomIDMapToRemoveIndexs.Contains(TempIDOfRoom))
						{
							CutIntArr = RoomIDMapToRemoveIndexs[TempIDOfRoom];
						}

						for (int PIndex = 0; PIndex < TempSmallCentersArr.Num(); PIndex++)
						{
							if (!CutIntArr.Contains(PIndex))
							{
								idOrder++;
								UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
								TSinglePointObj->SetNumberField("id", idOrder);
								TSinglePointObj->SetNumberField("x", TempSmallCentersArr[PIndex].X);
								TSinglePointObj->SetNumberField("y", TempSmallCentersArr[PIndex].Y);
								TSinglePointObj->SetNumberField("z", 130);
								TSinglePointObj->SetNumberField("markType", 0);

								if (NumOfFloors == 1)
								{
									TSinglePointObj->SetNumberField("floor", 1);
								}
								else if (NumOfFloors == 2)
								{
									for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
									{
										TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
										if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
										{
											TSinglePointObj->SetNumberField("floor", 1 + _CurFloor);
										}
									}
								}

								if (PointMapLocalRegion.Contains(TempSmallCentersArr[PIndex]))
								{
									TArray<FVector2D> LocalPoints = PointMapLocalRegion[TempSmallCentersArr[PIndex]];
									TArray<UVaRestJsonObject*> LocalBoundPoints;
									for (int IP = 0; IP < LocalPoints.Num(); ++IP)
									{
										UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
										TempPoint->SetNumberField("x", LocalPoints[IP].X);
										TempPoint->SetNumberField("y", LocalPoints[IP].Y);
										LocalBoundPoints.Add(TempPoint);
									}
									TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
								}
								PointObjArrTemp.Add(TSinglePointObj);
							}
						}
					}
					///////////////////////////////////////////////
					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("书房"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}

		}
	}

	//////////////////////////按用途顺序输出多功能房相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < MultiFunctionRoomUseIndexArr.Num(); ++_CurNum)
	{
		int BaseRoomID = MultiFunctionRoomUseIndexMapRoomID[MultiFunctionRoomUseIndexArr[_CurNum]];

		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);

					if (NumOfFloors == 1)
					{
						SinglePointObj->SetNumberField("floor", 1);
					}
					else if (NumOfFloors == 2)
					{
						for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
						{
							TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
							if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
							{
								SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
							}
						}
					}

					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Add(SinglePointObj);


					/////////////////////////////////////////////////////////////////////
					if (RoomIdMapSmallCenters.Contains(TempIDOfRoom))
					{
						TArray<FVector2D> TempSmallCentersArr = RoomIdMapSmallCenters[TempIDOfRoom];

						TArray<int> CutIntArr;
						if (RoomIDMapToRemoveIndexs.Contains(TempIDOfRoom))
						{
							CutIntArr = RoomIDMapToRemoveIndexs[TempIDOfRoom];
						}

						for (int PIndex = 0; PIndex < TempSmallCentersArr.Num(); PIndex++)
						{
							if (!CutIntArr.Contains(PIndex))
							{
								idOrder++;
								UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
								TSinglePointObj->SetNumberField("id", idOrder);
								TSinglePointObj->SetNumberField("x", TempSmallCentersArr[PIndex].X);
								TSinglePointObj->SetNumberField("y", TempSmallCentersArr[PIndex].Y);
								TSinglePointObj->SetNumberField("z", 130);
								TSinglePointObj->SetNumberField("markType", 0);

								if (NumOfFloors == 1)
								{
									TSinglePointObj->SetNumberField("floor", 1);
								}
								else if (NumOfFloors == 2)
								{
									for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
									{
										TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
										if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
										{
											TSinglePointObj->SetNumberField("floor", 1 + _CurFloor);
										}
									}
								}

								if (PointMapLocalRegion.Contains(TempSmallCentersArr[PIndex]))
								{
									TArray<FVector2D> LocalPoints = PointMapLocalRegion[TempSmallCentersArr[PIndex]];
									TArray<UVaRestJsonObject*> LocalBoundPoints;
									for (int IP = 0; IP < LocalPoints.Num(); ++IP)
									{
										UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
										TempPoint->SetNumberField("x", LocalPoints[IP].X);
										TempPoint->SetNumberField("y", LocalPoints[IP].Y);
										LocalBoundPoints.Add(TempPoint);
									}
									TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
								}
								PointObjArrTemp.Add(TSinglePointObj);
							}
						}
					}
					///////////////////////////////////////////////
					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("多功能房"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}

		}
	}


	//////////////////////////按用途顺序输出起居室相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < StartRoomUseIndexArr.Num(); ++_CurNum)
	{
		int BaseRoomID = StartRoomUseIndexMapRoomID[StartRoomUseIndexArr[_CurNum]];
		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);

					if (NumOfFloors == 1)
					{
						SinglePointObj->SetNumberField("floor", 1);
					}
					else if (NumOfFloors == 2)
					{
						for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
						{
							TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
							if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
							{
								SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
							}
						}
					}

					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Add(SinglePointObj);
					/////////////////////////////////
					if (RoomIdMapSmallCenters.Contains(TempIDOfRoom))
					{
						TArray<FVector2D> TempSmallCentersArr = RoomIdMapSmallCenters[TempIDOfRoom];

						TArray<int> CutIntArr;
						if (RoomIDMapToRemoveIndexs.Contains(TempIDOfRoom))
						{
							CutIntArr = RoomIDMapToRemoveIndexs[TempIDOfRoom];
						}

						for (int PIndex = 0; PIndex < TempSmallCentersArr.Num(); PIndex++)
						{
							if (!CutIntArr.Contains(PIndex))
							{
								idOrder++;
								UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
								TSinglePointObj->SetNumberField("id", idOrder);
								TSinglePointObj->SetNumberField("x", TempSmallCentersArr[PIndex].X);
								TSinglePointObj->SetNumberField("y", TempSmallCentersArr[PIndex].Y);
								TSinglePointObj->SetNumberField("z", 130);
								TSinglePointObj->SetNumberField("markType", 0);

								if (NumOfFloors == 1)
								{
									TSinglePointObj->SetNumberField("floor", 1);
								}
								else if (NumOfFloors == 2)
								{
									for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
									{
										TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
										if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
										{
											TSinglePointObj->SetNumberField("floor", 1 + _CurFloor);
										}
									}
								}

								if (PointMapLocalRegion.Contains(TempSmallCentersArr[PIndex]))
								{
									TArray<FVector2D> LocalPoints = PointMapLocalRegion[TempSmallCentersArr[PIndex]];
									TArray<UVaRestJsonObject*> LocalBoundPoints;
									for (int IP = 0; IP < LocalPoints.Num(); ++IP)
									{
										UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
										TempPoint->SetNumberField("x", LocalPoints[IP].X);
										TempPoint->SetNumberField("y", LocalPoints[IP].Y);
										LocalBoundPoints.Add(TempPoint);
									}
									TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
								}
								PointObjArrTemp.Add(TSinglePointObj);
							}
						}
					}
					//////////////////////////////////
					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("起居室"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}
		}
	}


	//////////////////////////按用途顺序输出储藏间相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < StoreRoomUseIndexArr.Num(); ++_CurNum)
	{
		int BaseRoomID=StoreRoomUseIndexMapRoomID[StoreRoomUseIndexArr[_CurNum]];
		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);

					if (NumOfFloors == 1)
					{
						SinglePointObj->SetNumberField("floor", 1);
					}
					else if (NumOfFloors == 2)
					{
						for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
						{
							TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
							if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
							{
								SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
							}
						}
					}

					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Emplace(SinglePointObj);
					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("储藏间"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}

		}
	}

	//////////////////////////按用途顺序输出衣帽间相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < CloakRoomUseIndexArr.Num(); ++_CurNum)
	{
		int BaseRoomID = CloakRoomUseIndexMapRoomID[CloakRoomUseIndexArr[_CurNum]];
		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom ==BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);

					if (NumOfFloors == 1)
					{
						SinglePointObj->SetNumberField("floor", 1);
					}
					else if (NumOfFloors == 2)
					{
						for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
						{
							TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
							if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
							{
								SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
							}
						}
					}

					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Emplace(SinglePointObj);
					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("衣帽间"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}

		}
	}


	//////////////////////////按用途顺序输出厨房相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < KitchenRoomUseIndexArr.Num(); ++_CurNum)
	{
		int BaseRoomID = KitchenRoomUseIndexMapRoomID[KitchenRoomUseIndexArr[_CurNum]];

		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);
					if (NumOfFloors == 1)
					{
						SinglePointObj->SetNumberField("floor", 1);
					}
					else if (NumOfFloors == 2)
					{
						for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
						{
							TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
							if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
							{
								SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
							}
						}
					}

					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Emplace(SinglePointObj);
					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("厨房"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}

		}
	}

	//////////////////////////按用途顺序输出主卫相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < FirstToiletRoomUseIndexArr.Num(); ++_CurNum)
	{
		int BaseRoomID = FirstToiletRoomUseIndexMapRoomID[FirstToiletRoomUseIndexArr[_CurNum]];
		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);

					if (NumOfFloors == 1)
					{
						SinglePointObj->SetNumberField("floor", 1);
					}
					else if (NumOfFloors == 2)
					{
						for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
						{
							TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
							if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
							{
								SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
							}
						}
					}

					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}

					///////////////////////////////////////////////////////////////////
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Add(SinglePointObj);

					if (ToiletRoomIDMapSmallCenters.Contains(TempIDOfRoom))
					{
						TArray<FVector2D> TempSmallCentersArr = ToiletRoomIDMapSmallCenters[TempIDOfRoom];
						for (int PIndex = 0; PIndex < TempSmallCentersArr.Num(); PIndex++)
						{
							idOrder++;
							UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
							TSinglePointObj->SetNumberField("id", idOrder);
							TSinglePointObj->SetNumberField("x", TempSmallCentersArr[PIndex].X);
							TSinglePointObj->SetNumberField("y", TempSmallCentersArr[PIndex].Y);
							TSinglePointObj->SetNumberField("z", 130);
							TSinglePointObj->SetNumberField("markType", 0);

							if (NumOfFloors == 1)
							{
								TSinglePointObj->SetNumberField("floor", 1);
							}
							else if (NumOfFloors == 2)
							{
								for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
								{
									TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
									if (TempRoomIDs.Contains(TempIDOfRoom))
									{
										TSinglePointObj->SetNumberField("floor", 1 + _CurFloor);
									}
								}
							}

							if (PointMapLocalRegion.Contains(TempSmallCentersArr[PIndex]))
							{
								TArray<FVector2D> LocalPoints = PointMapLocalRegion[TempSmallCentersArr[PIndex]];
								TArray<UVaRestJsonObject*> LocalBoundPoints;
								for (int IP = 0; IP < LocalPoints.Num(); ++IP)
								{
									UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
									TempPoint->SetNumberField("x", LocalPoints[IP].X);
									TempPoint->SetNumberField("y", LocalPoints[IP].Y);
									LocalBoundPoints.Add(TempPoint);
								}
								TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);

							}
							PointObjArrTemp.Add(TSinglePointObj);
						}
					}
					///////////////////////////////////////////////////////////////////

					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("主卫"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}

		}

	}

	//////////////////////////按用途顺序输出客卫相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < SecondToiletRoomUseIndexArr.Num(); ++_CurNum)
	{
		int BaseRoomID = SecondToiletRoomUseIndexMapRoomID[SecondToiletRoomUseIndexArr[_CurNum]];

		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);

					if (NumOfFloors == 1)
					{
						SinglePointObj->SetNumberField("floor", 1);
					}
					else if (NumOfFloors == 2)
					{
						for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
						{
							TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
							if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
							{
								SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
							}
						}
					}

					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}

					///////////////////////////////////////////////////////////////////
					TArray<UVaRestJsonObject*> PointObjArrTemp;
					PointObjArrTemp.Add(SinglePointObj);
					if (ToiletRoomIDMapSmallCenters.Contains(TempIDOfRoom))
					{
						TArray<FVector2D> TempSmallCentersArr = ToiletRoomIDMapSmallCenters[TempIDOfRoom];
						for (int PIndex = 0; PIndex < TempSmallCentersArr.Num(); PIndex++)
						{
								idOrder++;
								UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
								TSinglePointObj->SetNumberField("id", idOrder);
								TSinglePointObj->SetNumberField("x", TempSmallCentersArr[PIndex].X);
								TSinglePointObj->SetNumberField("y", TempSmallCentersArr[PIndex].Y);
								TSinglePointObj->SetNumberField("z", 130);
								TSinglePointObj->SetNumberField("markType", 0);

								if (NumOfFloors == 1)
								{
									TSinglePointObj->SetNumberField("floor", 1);
								}
								else if (NumOfFloors == 2)
								{
									for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
									{
										TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
										if (TempRoomIDs.Contains(TempIDOfRoom))
										{
											TSinglePointObj->SetNumberField("floor", 1 + _CurFloor);
										}
									}
								}

								if (PointMapLocalRegion.Contains(TempSmallCentersArr[PIndex]))
								{
									TArray<FVector2D> LocalPoints = PointMapLocalRegion[TempSmallCentersArr[PIndex]];
									TArray<UVaRestJsonObject*> LocalBoundPoints;
									for (int IP = 0; IP < LocalPoints.Num(); ++IP)
									{
										UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
										TempPoint->SetNumberField("x", LocalPoints[IP].X);
										TempPoint->SetNumberField("y", LocalPoints[IP].Y);
										LocalBoundPoints.Add(TempPoint);
									}
									TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);

								}
								PointObjArrTemp.Add(TSinglePointObj);
						}

					}

					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("客卫"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}

		}
	}

	//////////////////////////按用途顺序输出生活阳台相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < LivingBalconyRoomUseIndexArr.Num(); ++_CurNum)
	{

		int BaseRoomID = LivingBalconyRoomUseIndexMapRoomID[LivingBalconyRoomUseIndexArr[_CurNum]];

		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);


					if (NumOfFloors == 1)
					{
						SinglePointObj->SetNumberField("floor", 1);
					}
					else if (NumOfFloors == 2)
					{
						for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
						{
							TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
							if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
							{
								SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
							}
						}
					}

					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;

					PointObjArrTemp.Add(SinglePointObj);



					/////////////////////////////////
					if (RoomIdMapSmallCenters.Contains(TempIDOfRoom))
					{
						TArray<FVector2D> TempSmallCentersArr = RoomIdMapSmallCenters[TempIDOfRoom];

						TArray<int> CutIntArr;
						if (RoomIDMapToRemoveIndexs.Contains(TempIDOfRoom))
						{
							CutIntArr = RoomIDMapToRemoveIndexs[TempIDOfRoom];
						}

						for (int PIndex = 0; PIndex < TempSmallCentersArr.Num(); PIndex++)
						{
							if (!CutIntArr.Contains(PIndex))
							{
								idOrder++;
								UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
								TSinglePointObj->SetNumberField("id", idOrder);
								TSinglePointObj->SetNumberField("x", TempSmallCentersArr[PIndex].X);
								TSinglePointObj->SetNumberField("y", TempSmallCentersArr[PIndex].Y);
								TSinglePointObj->SetNumberField("z", 130);
								TSinglePointObj->SetNumberField("markType", 0);

								if (NumOfFloors == 1)
								{
									TSinglePointObj->SetNumberField("floor", 1);
								}
								else if (NumOfFloors == 2)
								{
									for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
									{
										TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
										if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
										{
											TSinglePointObj->SetNumberField("floor", 1 + _CurFloor);
										}
									}
								}

								if (PointMapLocalRegion.Contains(TempSmallCentersArr[PIndex]))
								{
									TArray<FVector2D> LocalPoints = PointMapLocalRegion[TempSmallCentersArr[PIndex]];
									TArray<UVaRestJsonObject*> LocalBoundPoints;
									for (int IP = 0; IP < LocalPoints.Num(); ++IP)
									{
										UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
										TempPoint->SetNumberField("x", LocalPoints[IP].X);
										TempPoint->SetNumberField("y", LocalPoints[IP].Y);
										LocalBoundPoints.Add(TempPoint);
									}
									TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
								}
								PointObjArrTemp.Add(TSinglePointObj);
							}
						}
					}
					///////////////////////////////////////////////
					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("生活阳台"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}
		}
	}

	//////////////////////////按用途顺序输出休闲阳台相关数据json///////////////////////////////////////
	for (int _CurNum = 0; _CurNum < LeisureBalconyRoomUseIndexArr.Num(); ++_CurNum)
	{

		int BaseRoomID = LeisureBalconyRoomUseIndexMapRoomID[LeisureBalconyRoomUseIndexArr[_CurNum]];

		for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
		{
			if (!HasProcessed.Contains(NewIndex))
			{
				FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
				int TempIDOfRoom = CameraPointArray[NewIndex]->GetIntegerField("roomId");
				if (TempIDOfRoom == BaseRoomID)
				{
					HasProcessed.Add(NewIndex);
					idOrder++;
					UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

					UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
					SinglePointObj->SetNumberField("id", idOrder);
					SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
					SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
					SinglePointObj->SetNumberField("z", 130);
					SinglePointObj->SetNumberField("markType", 1);


					if (NumOfFloors == 1)
					{
						SinglePointObj->SetNumberField("floor", 1);
					}
					else if (NumOfFloors == 2)
					{
						for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
						{
							TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
							if (TempRoomIDs.Contains(TempIDOfRoom))
							{
								SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
							}
						}
					}

					if (PointMapLocalRegion.Contains(CameraLocations[NewIndex]))
					{
						TArray<FVector2D> LocalPoints = PointMapLocalRegion[CameraLocations[NewIndex]];
						TArray<UVaRestJsonObject*> LocalBoundPoints;
						for (int IP = 0; IP < LocalPoints.Num(); ++IP)
						{
							UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
							TempPoint->SetNumberField("x", LocalPoints[IP].X);
							TempPoint->SetNumberField("y", LocalPoints[IP].Y);
							LocalBoundPoints.Add(TempPoint);
						}
						SinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
					}
					TArray<UVaRestJsonObject*> PointObjArrTemp;

					PointObjArrTemp.Add(SinglePointObj);



					/////////////////////////////////
					if (RoomIdMapSmallCenters.Contains(TempIDOfRoom))
					{
						TArray<FVector2D> TempSmallCentersArr = RoomIdMapSmallCenters[TempIDOfRoom];

						TArray<int> CutIntArr;
						if (RoomIDMapToRemoveIndexs.Contains(TempIDOfRoom))
						{
							CutIntArr = RoomIDMapToRemoveIndexs[TempIDOfRoom];
						}

						for (int PIndex = 0; PIndex < TempSmallCentersArr.Num(); PIndex++)
						{
							if (!CutIntArr.Contains(PIndex))
							{
								idOrder++;
								UVaRestJsonObject* TSinglePointObj = NewObject<UVaRestJsonObject>();
								TSinglePointObj->SetNumberField("id", idOrder);
								TSinglePointObj->SetNumberField("x", TempSmallCentersArr[PIndex].X);
								TSinglePointObj->SetNumberField("y", TempSmallCentersArr[PIndex].Y);
								TSinglePointObj->SetNumberField("z", 130);
								TSinglePointObj->SetNumberField("markType", 0);

								if (NumOfFloors == 1)
								{
									TSinglePointObj->SetNumberField("floor", 1);
								}
								else if (NumOfFloors == 2)
								{
									for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
									{
										TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
										if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
										{
											TSinglePointObj->SetNumberField("floor", 1 + _CurFloor);
										}
									}
								}

								if (PointMapLocalRegion.Contains(TempSmallCentersArr[PIndex]))
								{
									TArray<FVector2D> LocalPoints = PointMapLocalRegion[TempSmallCentersArr[PIndex]];
									TArray<UVaRestJsonObject*> LocalBoundPoints;
									for (int IP = 0; IP < LocalPoints.Num(); ++IP)
									{
										UVaRestJsonObject* TempPoint = NewObject<UVaRestJsonObject>();
										TempPoint->SetNumberField("x", LocalPoints[IP].X);
										TempPoint->SetNumberField("y", LocalPoints[IP].Y);
										LocalBoundPoints.Add(TempPoint);
									}
									TSinglePointObj->SetObjectArrayField("boundedpoints", LocalBoundPoints);
								}
								PointObjArrTemp.Add(TSinglePointObj);
							}
						}
					}
					///////////////////////////////////////////////
					OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
					OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
					OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
					OutTempPoint->SetStringField("roomOldUsageName", TEXT("休闲阳台"));
					OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
					OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
					NewCameraPointArray.Add(OutTempPoint);
					AllNameStrings.Add(TempString);
					break;
				}
			}
		}
	}



	for (int NewIndex = 0; NewIndex < AreaNum; NewIndex++)
	{
		FString TempString = CameraPointArray[NewIndex]->GetStringField("roomName");
		bool FindNameString = false;

		for (int NIndex = 0; NIndex < AllNameStrings.Num(); NIndex++)
		{
			if (AllNameStrings[NIndex] == TempString)
			{
				FindNameString = true;
				break;
			}
		}
		if (FindNameString == false)
		{
			idOrder++;
			UVaRestJsonObject* OutTempPoint = NewObject<UVaRestJsonObject>();

			UVaRestJsonObject* SinglePointObj = NewObject<UVaRestJsonObject>();
			SinglePointObj->SetNumberField("id", idOrder);
			SinglePointObj->SetNumberField("x", CameraLocations[NewIndex].X);
			SinglePointObj->SetNumberField("y", CameraLocations[NewIndex].Y);
			SinglePointObj->SetNumberField("z", 130);
			SinglePointObj->SetNumberField("markType", 1);

			if (NumOfFloors == 1)
			{
				SinglePointObj->SetNumberField("floor", 1);
			}
			else if (NumOfFloors == 2)
			{
				for (int _CurFloor = 0; _CurFloor < NumOfFloors; ++_CurFloor)
				{
					TArray<int> TempRoomIDs = GroupRoomIDs[1 + _CurFloor].RoomIDs;
					if (TempRoomIDs.Contains(RoomIDs[NewIndex]))
					{
						SinglePointObj->SetNumberField("floor", 1 + _CurFloor);
					}
				}
			}

			TArray<UVaRestJsonObject*> PointObjArrTemp;
			PointObjArrTemp.Emplace(SinglePointObj);
			OutTempPoint->SetObjectArrayField("point", PointObjArrTemp);
			OutTempPoint->SetStringField("roomName", RoomNameSet[NewIndex]);
			OutTempPoint->SetIntegerField("roomId", RoomIDs[NewIndex]);
			OutTempPoint->SetStringField("roomUsageName", RoomUsageNameSet[NewIndex]);
			OutTempPoint->SetNumberField("usageId", UsageIDs[NewIndex]);
			NewCameraPointArray.Add(OutTempPoint);
			AllNameStrings.Add(TempString);
		}
	}

	LocationJson->SetObjectArrayField("cameraLocation", NewCameraPointArray);
	return true;
}


/////////////////////////////////////////////RTX小视频自动路径算法相关////////////////////////////////////////////////////////

bool UWriteMeshObj_FunctionLibrary::AutoMaticCreatePath(UObject* WorldContextObject, UVaRestJsonObject* InJson, const TArray<int>InPutRoomIDs, TArray<FPathLine>& AllPathLines, const float FlyingHeight)
{
	if (InJson == NULL)
	{
		return false;
	}
	//////////////飞行高度设置////////////////
	const float LivingOrDiningHeight = FlyingHeight - 10;
	const float OtherHeight = FlyingHeight - 20;
	const float ShortDisLimit = 110.0f;
	const float HeightBound = 180;
	//////////////控制循环异常参数////////////////
	const int MaxNumIter = 50;
	//////////获取资源数据////////////////////
	int SolutionID = 0;
	SolutionID = InJson->GetNumberField("solutionId");
	TArray<UVaRestJsonObject*> RoomJsonObj = InJson->GetObjectArrayField("roomList");
	TArray<UVaRestJsonObject*> NewRoomJsonObj;
	TArray<FRegionPsOfMovieProject> RoomIDMapRegions;
	TMap<int, TArray<FVector2D>> RoomIDMapBoundary;
	TMap<int, FString> RoomIDMapName;
	TMap<int, FPathLine> RoomIDMapPathLine;
	TArray<int> AllRoomIDs;
	TMap<int, FString> RoomIDMapUseageName;
	TMap<int, int> RoomIDMapUsageID;
	for (int RoomIndex = 0; RoomIndex < RoomJsonObj.Num(); RoomIndex++)
	{
		UVaRestJsonObject* NewRoomJson = NewObject<UVaRestJsonObject>();
		TArray<UVaRestJsonObject*> EachRoomRegion = RoomJsonObj[RoomIndex]->GetObjectArrayField("areas");
		TArray<UVaRestJsonObject*> NewEachRoomRegion;
		TArray<FVector2D> TempRegionPs;


		int RoomId = RoomJsonObj[RoomIndex]->GetIntegerField("roomId");
		NewRoomJson->SetIntegerField("roomId", RoomId);
		AllRoomIDs.Add(RoomId);


		for (int NumIndex = 0; NumIndex < EachRoomRegion.Num(); NumIndex++)
		{
			UVaRestJsonObject* TempXY = NewObject<UVaRestJsonObject>();
			float TempX = EachRoomRegion[NumIndex]->GetNumberField("x");
			float TempY = EachRoomRegion[NumIndex]->GetNumberField("y");
			TempRegionPs.Add(FVector2D(TempX, TempY));
			TempXY->SetNumberField("x", TempX);
			TempXY->SetNumberField("y", TempY);
			NewEachRoomRegion.Add(TempXY);
		}
		NewRoomJson->SetObjectArrayField("areas", NewEachRoomRegion);

		FString RoomName = RoomJsonObj[RoomIndex]->GetStringField("roomName");
		NewRoomJson->SetStringField("roomName", RoomName);
		FRegionPsOfMovieProject  TempRegionPsOfMovie;
		TempRegionPsOfMovie.RoomID = RoomId;
		TempRegionPsOfMovie.RegionPs = TempRegionPs;
		RoomIDMapRegions.Add(TempRegionPsOfMovie);
		RoomIDMapBoundary.Add(RoomId, TempRegionPs);
		RoomIDMapName.Add(RoomId, RoomName);
		FString RoomUsageName = RoomJsonObj[RoomIndex]->GetStringField("roomUsageName");
		NewRoomJson->SetStringField("roomUsageName", RoomUsageName);
		RoomIDMapUseageName.Add(RoomId, RoomUsageName);
		int RoomUsageId = RoomJsonObj[RoomIndex]->GetNumberField("usageId");
		RoomIDMapUsageID.Add(RoomId, RoomUsageId);
		NewRoomJson->SetNumberField("usageId", RoomUsageId);
		NewRoomJsonObj.Add(NewRoomJson);
	}

	TArray<UVaRestJsonObject*> WallJsonObj = InJson->GetObjectArrayField("walls");
	TArray<UVaRestJsonObject*> NewWallJsonObj;

	TMap<int, TArray<FVector>> IndexMapWalls;
	TMap<int, FVector2D>IndexMapWallCenter;
	TMap<int, TArray<FVector2D>> IndexMapWalls2D;
	TArray<FVector2D> AllWallCenters;
	for (int WallIndex = 0; WallIndex < WallJsonObj.Num(); WallIndex++)
	{
		UVaRestJsonObject* NewWallJson = NewObject<UVaRestJsonObject>();
		TArray<UVaRestJsonObject*> WallPs = WallJsonObj[WallIndex]->GetObjectArrayField("wallPoints");
		TArray<UVaRestJsonObject*> NewWallPs;
		TArray<FVector> TempWall;
		TArray<FVector2D> TempWall2D;
		FVector2D TempWallCenter(0.0, 0.0);
		for (int NumIndex = 0; NumIndex < WallPs.Num(); NumIndex++)
		{
			UVaRestJsonObject* TempWallXYZ = NewObject<UVaRestJsonObject>();
			float TempX = WallPs[NumIndex]->GetNumberField("x");
			float TempY = WallPs[NumIndex]->GetNumberField("y");
			float TempZ = WallPs[NumIndex]->GetNumberField("z");
			TempWallXYZ->SetNumberField("x", TempX);
			TempWallXYZ->SetNumberField("y", TempY);
			TempWallXYZ->SetNumberField("z", TempZ);
			NewWallPs.Add(TempWallXYZ);
			TempWall.Add(FVector(TempX, TempY, TempZ));
			TempWall2D.Add(FVector2D(TempX, TempY));
			TempWallCenter = TempWallCenter + FVector2D(TempX, TempY);
		}
		TempWallCenter = TempWallCenter / WallPs.Num();
		AllWallCenters.Add(TempWallCenter);
		IndexMapWalls.Add(WallIndex, TempWall);
		IndexMapWalls2D.Add(WallIndex, TempWall2D);
		IndexMapWallCenter.Add(WallIndex, TempWallCenter);
		NewWallJson->SetObjectArrayField("wallPoints", NewWallPs);
		NewWallJsonObj.Add(NewWallJson);
	}
	////////////////////////////////////////定位入户门(兼容更多户型）/////////////////////////////////////////
	int GlobaleEntranceRoomID = 0;
	FVector2D GlobaleEntranceDoorCenter;
	FVector2D GlobaleEntranceDir;
	TArray<FRoomGroup> RoomGroups;
	bool IsLocated = LocateEntranceRoomID(WorldContextObject, InJson, RoomGroups, GlobaleEntranceRoomID, GlobaleEntranceDoorCenter, GlobaleEntranceDir);
	if (!IsLocated)
	{
		return false;
	}

	//////////预处理客餐厅数据////////////////////////////
	TArray<FVector2D> LivingRoomPs, DiningRoomPs, KitchenRoomPs, StartRoomPs;
	int LivingRoomID = 0, DiningRoomID = 0, KitchenRoomID = 0, StartRoomID = 0;
	bool IsLivingRoom = false;
	bool IsDiningRoom = false;
	bool IsKitchenRoom = false;
	bool IsStartRoom = false;
	for (int I = 0; I < AllRoomIDs.Num(); ++I)
	{
		int TempRoomId = AllRoomIDs[I];
		FString TempRoomName = RoomIDMapName[TempRoomId];
		if ((TempRoomName == TEXT("客厅")) && (!IsLivingRoom))
		{
			LivingRoomPs = RoomIDMapBoundary[TempRoomId];
			LivingRoomID = TempRoomId;
			IsLivingRoom = true;
		}
		else if ((TempRoomName == TEXT("餐厅")) && (!IsDiningRoom))
		{
			DiningRoomPs = RoomIDMapBoundary[TempRoomId];
			DiningRoomID = TempRoomId;
			IsDiningRoom = true;
		}
		else if ((TempRoomName == TEXT("厨房")) && (!IsKitchenRoom))
		{
			KitchenRoomID = TempRoomId;
			KitchenRoomPs = RoomIDMapBoundary[TempRoomId];
			IsKitchenRoom = true;
		}
		else if ((TempRoomName == TEXT("起居室")) && (!IsStartRoom))
		{
			StartRoomID = TempRoomId;
			StartRoomPs = RoomIDMapBoundary[TempRoomId];
			IsStartRoom = true;
		}
	}


	TArray<FPointPair> TempPointPairs;
	TArray<int> HasCalculatedRoomIDs;
	int NumOfIter = 0;
	const float ShrinkRatio = 0.65;

	if ((IsLivingRoom) && (IsDiningRoom))
	{
		if ((RoomIDMapName[GlobaleEntranceRoomID] == TEXT("客厅")) || (RoomIDMapName[GlobaleEntranceRoomID] == TEXT("餐厅")))
		{
			bool IFInterSect = false;
			bool HasCommonPoints = false;
			if ((LivingRoomPs.Num() != 0) && (DiningRoomPs.Num() != 0))
			{
				IFInterSect = FPolygonAlg::JudgePolygonInterSect(LivingRoomPs, DiningRoomPs);
				HasCommonPoints = FPolygonAlg::JudgeHasClosePoint(LivingRoomPs, DiningRoomPs);
			}
			//////////////预处理第三厅以及第四厅数据///////////////////////////
			TArray<FVector2D> ThirdDinging, FourthDining;
			int ThirdDingingRoomID = 0, FourthDiningRoomID = 0;
			bool IsThirdDining = false;
			bool IsFourthDining = false;
			for (int I = 0; I < AllRoomIDs.Num(); ++I)
			{
				int TempRoomId = AllRoomIDs[I];
				FString TempRoomName = RoomIDMapName[TempRoomId];
				if ((TempRoomName == TEXT("客厅")) && (TempRoomId != LivingRoomID) && (!IsThirdDining))
				{
					FPolygonAlg::MergeShortEdgesPreProcess(RoomIDMapBoundary[TempRoomId], ThirdDinging, 0.1);
					ThirdDingingRoomID = TempRoomId;
					IsThirdDining = true;
				}
				else if ((TempRoomName == TEXT("餐厅")) && (TempRoomId != DiningRoomID) && (!IsFourthDining))
				{
					FPolygonAlg::MergeShortEdgesPreProcess(RoomIDMapBoundary[TempRoomId], FourthDining, 0.1);
					FourthDiningRoomID = TempRoomId;
					IsFourthDining = true;
				}
			}
			bool IFInterSectOfThirdAndFourth = false;
			bool HasCommonPointsOfThirdAndFourth = false;
			if ((ThirdDinging.Num() != 0) && (FourthDining.Num() != 0))
			{
				IFInterSectOfThirdAndFourth = FPolygonAlg::JudgePolygonInterSect(ThirdDinging, FourthDining);
				HasCommonPointsOfThirdAndFourth = FPolygonAlg::JudgeHasClosePoint(ThirdDinging, FourthDining);
			}
			////////////////////定位入户门///////////////////////////////////////
			///////////获取客厅的门洞数据////////////////////////
			TArray<FVector> LivingRoomDoors;
			bool GetLivingDoor = false;
			if (LivingRoomID != 0)
			{
				GetLivingDoor = GetDoorsOfRegion(WorldContextObject, LivingRoomID, LivingRoomDoors);
			}

			////////////获取餐厅的门洞数据//////////////////////
			TArray<FVector> DiningRoomDoors;
			bool GetDiningDoor = false;
			if (DiningRoomID != 0)
			{
				GetDiningDoor = GetDoorsOfRegion(WorldContextObject, DiningRoomID, DiningRoomDoors);
			}
			///////////定位入户门////////////////////////
			FVector2D EntranceDoorCenter;
			FVector2D EntranceDir;
			FVector StartPoint;


			bool FindEntrance = false;
			bool FirstIsLiving = false;
			if (GetLivingDoor)
			{
				int TargetLivingDoor = 0;
				int NumOfLivingRoomDoors = LivingRoomDoors.Num() / 8;
				for (int _CurDoor = 0; _CurDoor < NumOfLivingRoomDoors; ++_CurDoor)
				{
					FVector2D FindDir;
					FVector TempDoorCenter = 0.25*(LivingRoomDoors[8 * _CurDoor + 0] + LivingRoomDoors[8 * _CurDoor + 1] + LivingRoomDoors[8 * _CurDoor + 2] + LivingRoomDoors[8 * _CurDoor + 3]);
					FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter);
					FVector2D DoorDir = FVector2D(LivingRoomDoors[8 * _CurDoor + 1] - LivingRoomDoors[8 * _CurDoor]);
					DoorDir = DoorDir.GetSafeNormal();
					FVector2D DoorDirOfRotated = DoorDir.GetRotated(90);
					FVector2D ExtendP1 = TempDoorCenter2D + 35 * DoorDirOfRotated;
					FVector2D ExtendP2 = TempDoorCenter2D - 35 * DoorDirOfRotated;
					int CountTime = 0;
					for (int _CurRoom = 0; _CurRoom < AllRoomIDs.Num(); ++_CurRoom)
					{

						TArray<FVector2D> TempRegionPs = RoomIDMapBoundary[AllRoomIDs[_CurRoom]];
						bool P1IsInRegion = FPolygonAlg::JudgePointInPolygon(TempRegionPs, ExtendP1);
						bool P2IsInRegion = FPolygonAlg::JudgePointInPolygon(TempRegionPs, ExtendP2);

						if (P1IsInRegion)
						{
							CountTime++;
							FindDir = DoorDirOfRotated;
						}

						if (P2IsInRegion)
						{
							CountTime++;
							FindDir = -DoorDirOfRotated;
						}
					}

					if (CountTime == 1)
					{
						TargetLivingDoor = _CurDoor;
						FindEntrance = true;
						EntranceDoorCenter = TempDoorCenter2D;
						EntranceDir = FindDir;
						break;
					}
				}
			}
			if (FindEntrance)
			{
				FVector2D TempTestP = EntranceDoorCenter + 30 * EntranceDir;
				FVector2D TempTestInterSectP1, TempTestInterSectP2;
				FPolygonAlg::CalculateRayToInterSectP(LivingRoomPs, TempTestP, EntranceDir, TempTestInterSectP1);
				FPolygonAlg::CalculateRayToInterSectP(LivingRoomPs, TempTestP, -EntranceDir, TempTestInterSectP2);
				float LengthOfSide1 = FVector2D::Distance(TempTestP, TempTestInterSectP1);
				float LengthOfSide2 = FVector2D::Distance(TempTestP, TempTestInterSectP2);
				float TotalLengthOfCase1 = LengthOfSide1 + LengthOfSide2;

				FVector2D TempRoV = EntranceDir.GetRotated(90);
				FVector2D TempTestInterSectP3, TempTestInterSectP4;
				FVector2D SecondTestP = 0.5*(TempTestInterSectP1 + TempTestInterSectP2);
				if (TotalLengthOfCase1 > 150.0f)
				{
					SecondTestP = TempTestP;
				}

				FPolygonAlg::CalculateRayToInterSectP(LivingRoomPs, SecondTestP, TempRoV, TempTestInterSectP3);
				FPolygonAlg::CalculateRayToInterSectP(LivingRoomPs, SecondTestP, -TempRoV, TempTestInterSectP4);
				float LengthOfSide3 = FVector2D::Distance(SecondTestP, TempTestInterSectP3);
				float LengthOfSide4 = FVector2D::Distance(SecondTestP, TempTestInterSectP4);
				float TotalLengthOfCase2 = LengthOfSide3 + LengthOfSide4;

				if ((TotalLengthOfCase1 > TotalLengthOfCase2) || (abs(TotalLengthOfCase1 - TotalLengthOfCase2) <= 100))
				{
					StartPoint = FVector(EntranceDoorCenter + 50 * EntranceDir, LivingOrDiningHeight);
				}
				else
				{
					if (TotalLengthOfCase1 <= 150.0f)
					{
						StartPoint = FVector(EntranceDoorCenter + 0.5*TotalLengthOfCase1 * EntranceDir, LivingOrDiningHeight);
					}
					else
					{
						StartPoint = FVector(EntranceDoorCenter + 50 * EntranceDir, LivingOrDiningHeight);
					}

					if (LengthOfSide3 > LengthOfSide4)
					{
						EntranceDir = TempRoV;
					}
					else
					{
						EntranceDir = -TempRoV;
					}
				}
				FirstIsLiving = true;
			}
			else
			{
				if (GetDiningDoor)
				{
					int TargetDiningDoor = 0;
					int NumOfDiningRoomDoors = DiningRoomDoors.Num() / 8;
					for (int _CurDoor = 0; _CurDoor < NumOfDiningRoomDoors; ++_CurDoor)
					{
						FVector2D FindDir;
						FVector TempDoorCenter = 0.25*(DiningRoomDoors[8 * _CurDoor + 0] + DiningRoomDoors[8 * _CurDoor + 1] + DiningRoomDoors[8 * _CurDoor + 2] + DiningRoomDoors[8 * _CurDoor + 3]);
						FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter);
						FVector2D DoorDir = FVector2D(DiningRoomDoors[8 * _CurDoor + 1] - DiningRoomDoors[8 * _CurDoor]);
						DoorDir = DoorDir.GetSafeNormal();
						FVector2D DoorDirOfRotated = DoorDir.GetRotated(90);
						FVector2D ExtendP1 = TempDoorCenter2D + 35 * DoorDirOfRotated;
						FVector2D ExtendP2 = TempDoorCenter2D - 35 * DoorDirOfRotated;
						int CountTime = 0;
						for (int _CurRoom = 0; _CurRoom < AllRoomIDs.Num(); ++_CurRoom)
						{

							TArray<FVector2D> TempRegionPs = RoomIDMapBoundary[AllRoomIDs[_CurRoom]];
							bool P1IsInRegion = FPolygonAlg::JudgePointInPolygon(TempRegionPs, ExtendP1);
							bool P2IsInRegion = FPolygonAlg::JudgePointInPolygon(TempRegionPs, ExtendP2);

							if (P1IsInRegion)
							{
								CountTime++;
								FindDir = DoorDirOfRotated;
							}

							if (P2IsInRegion)
							{
								CountTime++;
								FindDir = -DoorDirOfRotated;
							}
						}

						if (CountTime == 1)
						{
							TargetDiningDoor = _CurDoor;
							FindEntrance = true;
							EntranceDoorCenter = TempDoorCenter2D;
							EntranceDir = FindDir;
							break;
						}
					}
				}
				if (FindEntrance)
				{
					StartPoint = FVector(EntranceDoorCenter + 50 * EntranceDir, LivingOrDiningHeight);
					FVector2D TempTestP = EntranceDoorCenter + 30 * EntranceDir;
					FVector2D TempTestInterSectP1, TempTestInterSectP2;
					FPolygonAlg::CalculateRayToInterSectP(DiningRoomPs, TempTestP, EntranceDir, TempTestInterSectP1);
					FPolygonAlg::CalculateRayToInterSectP(DiningRoomPs, TempTestP, -EntranceDir, TempTestInterSectP2);
					float LengthOfSide1 = FVector2D::Distance(TempTestP, TempTestInterSectP1);
					float LengthOfSide2 = FVector2D::Distance(TempTestP, TempTestInterSectP2);
					float TotalLengthOfCase1 = LengthOfSide1 + LengthOfSide2;

					FVector2D TempRoV = EntranceDir.GetRotated(90);
					FVector2D TempTestInterSectP3, TempTestInterSectP4;
					FVector2D SecondTestP = 0.5*(TempTestInterSectP1 + TempTestInterSectP2);
					if (TotalLengthOfCase1 > 150.0f)
					{
						SecondTestP = TempTestP;
					}
					FPolygonAlg::CalculateRayToInterSectP(DiningRoomPs, SecondTestP, TempRoV, TempTestInterSectP3);
					FPolygonAlg::CalculateRayToInterSectP(DiningRoomPs, SecondTestP, -TempRoV, TempTestInterSectP4);



					float LengthOfSide3 = FVector2D::Distance(SecondTestP, TempTestInterSectP3);
					float LengthOfSide4 = FVector2D::Distance(SecondTestP, TempTestInterSectP4);
					float TotalLengthOfCase2 = LengthOfSide3 + LengthOfSide4;

					if ((TotalLengthOfCase1 > TotalLengthOfCase2) || (abs(TotalLengthOfCase1 - TotalLengthOfCase2) <= 100))
					{
						StartPoint = FVector(EntranceDoorCenter + 50 * EntranceDir, LivingOrDiningHeight);
					}
					else
					{
						if (TotalLengthOfCase1 <= 150.0f)
						{
							StartPoint = FVector(EntranceDoorCenter + 0.5*TotalLengthOfCase1 * EntranceDir, LivingOrDiningHeight);
						}
						else
						{
							StartPoint = FVector(EntranceDoorCenter + 50 * EntranceDir, LivingOrDiningHeight);
						}

						if (LengthOfSide3 > LengthOfSide4)
						{
							EntranceDir = TempRoV;
						}
						else
						{
							EntranceDir = -TempRoV;
						}
					}
				}
			}

			if (!FindEntrance)
			{
				return false;
			}
			///////////////客餐厅是相邻的情况下计算客厅路径/////////////////////

			TMap<int, FVector2D> LivingChildRoomIDMapDoorCenter, DiningChildRoomIDMapDoorCenter;
			TArray<int> LivingChildRoomIDs, DiningChildRoomIDs;
			TArray<FVector2D> CriticalLivingPoints, CriticalDiningPoints;
			FVector2D LivingRoomCenter;
			FVector2D DiningRoomCenter;
			bool LocateLivingSuccess = false;
			bool LocateDiningSuccess = false;
			if (LivingRoomID != 0)
			{
				LocateLivingSuccess = LocateCriticalPointsOfLivingOrDining(WorldContextObject,
					LivingRoomPs,
					LivingRoomID,
					DiningRoomPs,
					AllRoomIDs,
					RoomIDMapRegions,
					CriticalLivingPoints,
					LivingChildRoomIDMapDoorCenter,
					LivingChildRoomIDs,
					LivingRoomCenter,
					true);
				HasCalculatedRoomIDs.AddUnique(LivingRoomID);
			}

			if (DiningRoomID != 0)
			{
				LocateDiningSuccess = LocateCriticalPointsOfLivingOrDining(WorldContextObject,
					DiningRoomPs,
					DiningRoomID,
					LivingRoomPs,
					AllRoomIDs,
					RoomIDMapRegions,
					CriticalDiningPoints,
					DiningChildRoomIDMapDoorCenter,
					DiningChildRoomIDs,
					DiningRoomCenter,
					false);
				HasCalculatedRoomIDs.AddUnique(DiningRoomID);
			}

			bool BControlDirOfFirstP = false;

			if (FirstIsLiving)
			{
				if (LocateLivingSuccess)
				{
					TArray<FVector2D> PostLivingPs;
					bool IsMergedLiving = FPolygonAlg::StricMergeCollinear(LivingRoomPs, PostLivingPs);
					if (IsMergedLiving)
					{
						if (PostLivingPs.Num() == 4)
						{
							FPointPair _StartPoint;
							_StartPoint.RoutinePoint = StartPoint;
							_StartPoint.WatchPoint = FVector(LivingRoomCenter, LivingOrDiningHeight);
							_StartPoint.ActionMarker = 0;
							TempPointPairs.Add(_StartPoint);

							if (CriticalLivingPoints.Num() > 0)
							{
								float StartToFirst = FVector2D::Distance(FVector2D(StartPoint), CriticalLivingPoints[0]);
								float StartToLast = FVector2D::Distance(FVector2D(StartPoint), CriticalLivingPoints.Last());
								if (StartToFirst > StartToLast)
								{
									for (int _CurP = CriticalLivingPoints.Num() - 1; _CurP >= 0; --_CurP)
									{
										FPointPair _CurPair;
										_CurPair.RoutinePoint = FVector(CriticalLivingPoints[_CurP], LivingOrDiningHeight);
										_CurPair.WatchPoint = FVector(LivingRoomCenter, LivingOrDiningHeight);
										_CurPair.ActionMarker = 0;
										TempPointPairs.Add(_CurPair);
									}
								}
								else
								{
									for (int _CurP = 0; _CurP < CriticalLivingPoints.Num(); ++_CurP)
									{
										FPointPair _CurPair;
										_CurPair.RoutinePoint = FVector(CriticalLivingPoints[_CurP], LivingOrDiningHeight);
										_CurPair.WatchPoint = FVector(LivingRoomCenter, LivingOrDiningHeight);
										_CurPair.ActionMarker = 0;
										TempPointPairs.Add(_CurPair);
									}
								}
							}

						}
						else
						{

							TArray<FVector2D> LivingMaxLocalRegion;
							bool Finded = FPolygonAlg::LocateMaxLocalRegionOfLivingOrDiningRoom(LivingRoomPs, LivingRoomID, DiningRoomPs, LivingMaxLocalRegion);
							if (Finded)
							{
								FVector2D BasePoint;
								if (!FPolygonAlg::JudgePointInPolygon(LivingMaxLocalRegion, FVector2D(StartPoint)))
								{
									BControlDirOfFirstP = true;

									FPointPair _StartPoint;
									_StartPoint.RoutinePoint = StartPoint;
									_StartPoint.WatchPoint = FVector(LivingRoomCenter, LivingOrDiningHeight);
									_StartPoint.ActionMarker = 0;
									TempPointPairs.Add(_StartPoint);

									FVector2D ExtendPointOfEntranceP = FVector2D(StartPoint) + 1000 * EntranceDir;
									FVector CloestPointOfExtendPoint = FMath::ClosestPointOnInfiniteLine(StartPoint, FVector(ExtendPointOfEntranceP, 0), FVector(CriticalLivingPoints[0], 0));

									float TempJudgeDis = 0.0f;
									int _NextCurP = 0;
									for (int _CurP = 0; _CurP < 4; _CurP++)
									{
										if (_CurP == 3)
										{
											_NextCurP = 0;
										}
										else
										{
											_NextCurP = 0;
										}
										float TempL = FMath::PointDistToSegment(CloestPointOfExtendPoint, FVector(LivingMaxLocalRegion[_CurP], 0.0), FVector(LivingMaxLocalRegion[_NextCurP], 0.0));
										if ((TempJudgeDis <= 1.0*10E-5) || (TempL < TempJudgeDis))
										{
											TempJudgeDis = TempL;
										}
									}
									if (TempJudgeDis <= ShortDisLimit)
									{
										FPointPair TempPair;
										TempPair.RoutinePoint = FVector(CloestPointOfExtendPoint.X, CloestPointOfExtendPoint.Y, LivingOrDiningHeight);
										TempPair.WatchPoint = FVector(LivingRoomCenter, LivingOrDiningHeight);
										TempPair.ActionMarker = 0;
										TempPointPairs.Add(TempPair);
										BasePoint = FVector2D(CloestPointOfExtendPoint);
									}
									else
									{
										FVector2D TempAddNode1 = FVector2D(CloestPointOfExtendPoint) + 50 * EntranceDir;
										FVector2D TempMoveDir = CriticalLivingPoints[0] - FVector2D(CloestPointOfExtendPoint);
										TempMoveDir.Normalize();
										FVector2D TempExtendPoint = FVector2D(TempAddNode1) + 1000 * TempMoveDir;
										FVector TempCloestPointOfTempExtendPoint = FMath::ClosestPointOnInfiniteLine(FVector(TempAddNode1, 0), FVector(TempExtendPoint, 0), FVector(CriticalLivingPoints[0], 0));
										FPointPair TempPair1, TempPair2;
										TempPair1.RoutinePoint = FVector(TempAddNode1.X, TempAddNode1.Y, LivingOrDiningHeight);
										TempPair1.WatchPoint = FVector(LivingRoomCenter, LivingOrDiningHeight);
										TempPair1.ActionMarker = 0;
										TempPointPairs.Add(TempPair1);
										TempPair2.RoutinePoint = FVector(TempCloestPointOfTempExtendPoint.X, TempCloestPointOfTempExtendPoint.Y, LivingOrDiningHeight);
										TempPair2.WatchPoint = FVector(LivingRoomCenter, LivingOrDiningHeight);
										TempPair2.ActionMarker = 0;
										TempPointPairs.Add(TempPair2);
										BasePoint = FVector2D(TempCloestPointOfTempExtendPoint);
									}


									///////////////微调此处路径点/////////////////
									if (CriticalLivingPoints.Num() > 0)
									{
										float StartToFirst = FVector2D::Distance(BasePoint, CriticalLivingPoints[0]);
										float StartToLast = FVector2D::Distance(BasePoint, CriticalLivingPoints.Last());
										if (StartToFirst > StartToLast)
										{
											for (int _CurP = CriticalLivingPoints.Num() - 1; _CurP >= 1; --_CurP)
											{
												FPointPair _CurPair;
												_CurPair.RoutinePoint = FVector(CriticalLivingPoints[_CurP], LivingOrDiningHeight);
												_CurPair.WatchPoint = FVector(LivingRoomCenter, LivingOrDiningHeight);
												_CurPair.ActionMarker = 0;
												TempPointPairs.Add(_CurPair);
											}
										}
										else
										{
											for (int _CurP = 1; _CurP < CriticalLivingPoints.Num(); ++_CurP)
											{
												FPointPair _CurPair;
												_CurPair.RoutinePoint = FVector(CriticalLivingPoints[_CurP], LivingOrDiningHeight);
												_CurPair.WatchPoint = FVector(LivingRoomCenter, LivingOrDiningHeight);
												_CurPair.ActionMarker = 0;
												TempPointPairs.Add(_CurPair);
											}
										}
									}

								}
								else
								{
									/////////////////微调此处路径点/////////////////
									FPointPair _StartPoint;
									_StartPoint.RoutinePoint = StartPoint;
									_StartPoint.WatchPoint = FVector(LivingRoomCenter, LivingOrDiningHeight);
									_StartPoint.ActionMarker = 0;
									TempPointPairs.Add(_StartPoint);

									if (CriticalLivingPoints.Num() > 0)
									{
										float StartToFirst = FVector2D::Distance(FVector2D(StartPoint), CriticalLivingPoints[0]);
										float StartToLast = FVector2D::Distance(FVector2D(StartPoint), CriticalLivingPoints.Last());
										if (StartToFirst > StartToLast)
										{
											for (int _CurP = CriticalLivingPoints.Num() - 1; _CurP >= 0; --_CurP)
											{
												FPointPair _CurPair;
												_CurPair.RoutinePoint = FVector(CriticalLivingPoints[_CurP], LivingOrDiningHeight);
												_CurPair.WatchPoint = FVector(LivingRoomCenter, LivingOrDiningHeight);
												_CurPair.ActionMarker = 0;
												TempPointPairs.Add(_CurPair);
											}
										}
										else
										{
											for (int _CurP = 0; _CurP < CriticalLivingPoints.Num(); ++_CurP)
											{
												FPointPair _CurPair;
												_CurPair.RoutinePoint = FVector(CriticalLivingPoints[_CurP], LivingOrDiningHeight);
												_CurPair.WatchPoint = FVector(LivingRoomCenter, LivingOrDiningHeight);
												_CurPair.ActionMarker = 0;
												TempPointPairs.Add(_CurPair);
											}
										}
									}


								}
							}
						}
						//////////////////添加路线////////////////////
						if (TempPointPairs.Num() > 0)
						{
							FPathLine TempLine;
							TempLine.RoutinePoints = TempPointPairs;
							TempPointPairs.Empty();
							RoomIDMapPathLine.Add(LivingRoomID, TempLine);
							HasCalculatedRoomIDs.AddUnique(LivingRoomID);
						}

						if (LivingChildRoomIDs.Num() > 0)
						{
							int TargetLivingChildID = 0;
							bool FindLivingChild = false;
							for (int _CurChild = 0; _CurChild < LivingChildRoomIDs.Num(); ++_CurChild)
							{
								int TempChildRoomID = LivingChildRoomIDs[_CurChild];
								FVector2D TempMapDoorCenter = LivingChildRoomIDMapDoorCenter[TempChildRoomID];
								float X_Differ = abs(TempMapDoorCenter.X - CriticalLivingPoints.Last().X);
								float Y_Differ = abs(TempMapDoorCenter.Y - CriticalLivingPoints.Last().Y);
								if ((X_Differ <= 85) || (Y_Differ <= 85))
								{
									TargetLivingChildID = LivingChildRoomIDs[_CurChild];
									FindLivingChild = true;
									break;
								}
							}
							if (FindLivingChild)
							{
								TArray<FVector> DoorPoints;
								TArray<FVector2D> CriticalLivingChildPoints;
								bool GetLivingChildDoors = GetDoorsOfRegion(WorldContextObject, TargetLivingChildID, DoorPoints);
								if (GetLivingChildDoors)
								{
									if ((RoomIDMapName[TargetLivingChildID] == TEXT("生活阳台")) || (RoomIDMapName[TargetLivingChildID] == TEXT("休闲阳台")))
									{
										FVector2D TempWatchPoint;
										bool LocalChildSuccess = LocateTwoCriticalPointsOfBalcony(WorldContextObject, RoomIDMapBoundary[TargetLivingChildID], TargetLivingChildID,
											CriticalLivingChildPoints, TempWatchPoint);
										if (LocalChildSuccess)
										{
											for (int _CurP = 0; _CurP < CriticalLivingChildPoints.Num(); ++_CurP)
											{
												FPointPair TempChildPair;
												TempChildPair.RoutinePoint = FVector(CriticalLivingChildPoints[_CurP], OtherHeight);
												TempChildPair.WatchPoint = FVector(TempWatchPoint, OtherHeight);
												TempChildPair.ActionMarker = 0;
												TempPointPairs.Add(TempChildPair);
											}
											if (TempPointPairs.Num() > 0)
											{
												FPathLine TempLine;
												TempLine.RoutinePoints = TempPointPairs;
												TempPointPairs.Empty();
												RoomIDMapPathLine.Add(TargetLivingChildID, TempLine);
											}
											HasCalculatedRoomIDs.AddUnique(TargetLivingChildID);
										}
									}
								}
							}

							if (LivingChildRoomIDs.Num() >= 2)
							{
								for (int _CurR = 0; _CurR < LivingChildRoomIDs.Num(); ++_CurR)
								{
									if (LivingChildRoomIDs[_CurR] != TargetLivingChildID)
									{
										TArray<FVector> TempDoorPoints;
										TArray<FVector2D> TempChildCriticalPoints;
										bool GetChildSuccess = GetDoorsOfRegion(WorldContextObject, LivingChildRoomIDs[_CurR], TempDoorPoints);
										if (GetChildSuccess)
										{
											if ((RoomIDMapName[LivingChildRoomIDs[_CurR]] == TEXT("生活阳台")) || (RoomIDMapName[LivingChildRoomIDs[_CurR]] == TEXT("休闲阳台")))
											{
												FVector2D TempLocalRegionCenter;
												TArray<FVector2D> TempCriticalChildPoints;
												bool LocalChildSuccess = LocateTwoCriticalPointsOfBalcony(WorldContextObject, RoomIDMapBoundary[LivingChildRoomIDs[_CurR]], LivingChildRoomIDs[_CurR],
													TempCriticalChildPoints, TempLocalRegionCenter);

												if (LocalChildSuccess)
												{
													for (int _CurP = 0; _CurP < TempCriticalChildPoints.Num(); ++_CurP)
													{
														FPointPair _CurPair;
														_CurPair.RoutinePoint = FVector(TempCriticalChildPoints[_CurP], OtherHeight);
														_CurPair.WatchPoint = FVector(TempLocalRegionCenter, OtherHeight);
														_CurPair.ActionMarker = 0;
														TempPointPairs.Add(_CurPair);
													}

													if (TempPointPairs.Num() > 0)
													{
														FPathLine TempLine;
														TempLine.RoutinePoints = TempPointPairs;
														TempPointPairs.Empty();
														RoomIDMapPathLine.Add(LivingChildRoomIDs[_CurR], TempLine);
													}

													HasCalculatedRoomIDs.AddUnique(LivingChildRoomIDs[_CurR]);
												}
											}
										}

									}

								}
							}
						}
					}

					if (LocateDiningSuccess)
					{
						for (int _CurP = 0; _CurP < CriticalDiningPoints.Num(); ++_CurP)
						{
							FPointPair _CurPair;
							_CurPair.RoutinePoint = FVector(CriticalDiningPoints[_CurP], LivingOrDiningHeight);
							_CurPair.WatchPoint = FVector(DiningRoomCenter, LivingOrDiningHeight);
							_CurPair.ActionMarker = 0;
							TempPointPairs.Add(_CurPair);
						}

						if (TempPointPairs.Num() > 0)
						{
							FPathLine TempLine;
							TempLine.RoutinePoints = TempPointPairs;
							TempPointPairs.Empty();
							RoomIDMapPathLine.Add(DiningRoomID, TempLine);
							HasCalculatedRoomIDs.AddUnique(DiningRoomID);
						}

						if (DiningChildRoomIDs.Num() > 0)
						{
							int TargetDiningChildID = 0;
							bool FindDiningChild = false;
							for (int _CurChild = 0; _CurChild < DiningChildRoomIDs.Num(); ++_CurChild)
							{
								int TempChildRoomID = DiningChildRoomIDs[_CurChild];
								FVector2D TempMapDoorCenter = DiningChildRoomIDMapDoorCenter[TempChildRoomID];
								float X_Differ = abs(TempMapDoorCenter.X - CriticalLivingPoints.Last().X);
								float Y_Differ = abs(TempMapDoorCenter.Y - CriticalLivingPoints.Last().Y);
								if ((X_Differ <= 85) || (Y_Differ <= 85))
								{
									TargetDiningChildID = DiningChildRoomIDs[_CurChild];
									FindDiningChild = true;
									break;
								}
							}
							if (FindDiningChild)
							{
								TArray<FVector> DoorPoints;
								TArray<FVector2D> CriticalDiningChildPoints;
								bool GetDiningChildDoors = GetDoorsOfRegion(WorldContextObject, TargetDiningChildID, DoorPoints);
								if (GetDiningChildDoors)
								{
									if ((RoomIDMapName[TargetDiningChildID] == TEXT("生活阳台")) || (RoomIDMapName[TargetDiningChildID] == TEXT("休闲阳台")))
									{
										FVector2D TempLocalRegionCenter;
										bool LocalChildSuccess = LocateTwoCriticalPointsOfBalcony(WorldContextObject, RoomIDMapBoundary[TargetDiningChildID], TargetDiningChildID,
											CriticalDiningChildPoints, TempLocalRegionCenter);

										if (LocalChildSuccess)
										{
											for (int _CurP = 0; _CurP < CriticalDiningChildPoints.Num(); ++_CurP)
											{
												FPointPair _CurPair;
												_CurPair.RoutinePoint = FVector(CriticalDiningChildPoints[_CurP], OtherHeight);
												_CurPair.WatchPoint = FVector(TempLocalRegionCenter, OtherHeight);
												_CurPair.ActionMarker = 0;
												TempPointPairs.Add(_CurPair);
											}

											if (TempPointPairs.Num() > 0)
											{
												FPathLine TempLine;
												TempLine.RoutinePoints = TempPointPairs;
												TempPointPairs.Empty();
												RoomIDMapPathLine.Add(TargetDiningChildID, TempLine);
											}

											HasCalculatedRoomIDs.AddUnique(TargetDiningChildID);

										}
									}
								}
							}
							if (DiningChildRoomIDs.Num() >= 2)
							{
								for (int _CurR = 0; _CurR < DiningChildRoomIDs.Num(); ++_CurR)
								{
									if (DiningChildRoomIDs[_CurR] != TargetDiningChildID)
									{
										TArray<FVector> TempDoorPoints;
										TArray<FVector2D> TempChildCriticalPoints;
										bool GetChildSuccess = GetDoorsOfRegion(WorldContextObject, DiningChildRoomIDs[_CurR], TempDoorPoints);
										if (GetChildSuccess)
										{
											if ((RoomIDMapName[DiningChildRoomIDs[_CurR]] == TEXT("生活阳台")) || (RoomIDMapName[DiningChildRoomIDs[_CurR]] == TEXT("休闲阳台")))
											{
												FVector2D TempLocalRegionCenter;
												TArray<FVector2D> TempCriticalChildPoints;

												bool LocalChildSuccess = LocateTwoCriticalPointsOfBalcony(WorldContextObject, RoomIDMapBoundary[DiningChildRoomIDs[_CurR]], DiningChildRoomIDs[_CurR],
													TempCriticalChildPoints, TempLocalRegionCenter);

												if (LocalChildSuccess)
												{
													for (int _CurP = 0; _CurP < TempCriticalChildPoints.Num(); ++_CurP)
													{
														FPointPair _CurPair;
														_CurPair.RoutinePoint = FVector(TempCriticalChildPoints[_CurP], OtherHeight);
														_CurPair.WatchPoint = FVector(TempLocalRegionCenter, OtherHeight);
														_CurPair.ActionMarker = 0;
														TempPointPairs.Add(_CurPair);
													}

													if (TempPointPairs.Num() > 0)
													{
														FPathLine TempLine;
														TempLine.RoutinePoints = TempPointPairs;
														TempPointPairs.Empty();
														RoomIDMapPathLine.Add(DiningChildRoomIDs[_CurR], TempLine);
													}

													HasCalculatedRoomIDs.AddUnique(DiningChildRoomIDs[_CurR]);
												}
											}
										}

									}

								}

							}
						}

					}
				}
			}
			else
			{

				if (LocateDiningSuccess)
				{
					/////////////////////判断入户门附近点距离关键点哪个最近////////////////////////////////////
					TArray<FVector2D> PostDiningPs;
					bool IsMergedDining = FPolygonAlg::StricMergeCollinear(DiningRoomPs, PostDiningPs);
					if (IsMergedDining)
					{
						if (PostDiningPs.Num() == 4)
						{
							FPointPair _StartPoint;
							_StartPoint.RoutinePoint = StartPoint;
							_StartPoint.WatchPoint = FVector(DiningRoomCenter, LivingOrDiningHeight);
							_StartPoint.ActionMarker = 0;
							TempPointPairs.Add(_StartPoint);

							if (CriticalDiningPoints.Num() > 0)
							{
								float StartToFirst = FVector2D::Distance(FVector2D(StartPoint), CriticalDiningPoints[0]);
								float StartToLast = FVector2D::Distance(FVector2D(StartPoint), CriticalDiningPoints.Last());
								if (StartToFirst > StartToLast)
								{
									for (int _CurP = CriticalDiningPoints.Num() - 1; _CurP >= 0; --_CurP)
									{
										FPointPair _CurPair;
										_CurPair.RoutinePoint = FVector(CriticalDiningPoints[_CurP], LivingOrDiningHeight);
										_CurPair.WatchPoint = FVector(DiningRoomCenter, LivingOrDiningHeight);
										_CurPair.ActionMarker = 0;
										TempPointPairs.Add(_CurPair);
									}
								}
								else
								{
									for (int _CurP = 0; _CurP < CriticalDiningPoints.Num(); ++_CurP)
									{
										FPointPair _CurPair;
										_CurPair.RoutinePoint = FVector(CriticalDiningPoints[_CurP], LivingOrDiningHeight);
										_CurPair.WatchPoint = FVector(DiningRoomCenter, LivingOrDiningHeight);
										_CurPair.ActionMarker = 0;
										TempPointPairs.Add(_CurPair);
									}
								}
							}
						}
						else
						{
							TArray<FVector2D> DiningMaxLocalRegion;
							bool FindMaxLocal = FPolygonAlg::LocateMaxLocalRegionOfLivingOrDiningRoom(DiningRoomPs, DiningRoomID, LivingRoomPs, DiningMaxLocalRegion);
							if (FindMaxLocal)
							{

								FVector2D BasePoint;
								if (!FPolygonAlg::JudgePointInPolygon(DiningMaxLocalRegion, FVector2D(StartPoint)))
								{
									BControlDirOfFirstP = true;
									FPointPair _StartPoint;
									_StartPoint.RoutinePoint = StartPoint;
									_StartPoint.WatchPoint = FVector(DiningRoomCenter, LivingOrDiningHeight);
									_StartPoint.ActionMarker = 0;
									TempPointPairs.Add(_StartPoint);


									FVector2D ExtendPointOfEntranceP = FVector2D(StartPoint) + 1000 * EntranceDir;
									FVector CloestPointOfExtendPoint = FMath::ClosestPointOnInfiniteLine(StartPoint, FVector(ExtendPointOfEntranceP, 0), FVector(CriticalDiningPoints[0], 0));


									float TempJudgeDis = 0.0f;
									int _NextCurP = 0;
									for (int _CurP = 0; _CurP < 4; _CurP++)
									{
										if (_CurP == 3)
										{
											_NextCurP = 0;
										}
										else
										{
											_NextCurP = 0;
										}
										float TempL = FMath::PointDistToSegment(CloestPointOfExtendPoint, FVector(DiningMaxLocalRegion[_CurP], 0.0), FVector(DiningMaxLocalRegion[_NextCurP], 0.0));
										if ((TempJudgeDis <= 1.0*10E-5) || (TempL < TempJudgeDis))
										{
											TempJudgeDis = TempL;
										}
									}

									if (TempJudgeDis <= ShortDisLimit)
									{
										FPointPair TempPair;
										TempPair.RoutinePoint = FVector(CloestPointOfExtendPoint.X, CloestPointOfExtendPoint.Y, LivingOrDiningHeight);
										TempPair.WatchPoint = FVector(DiningRoomCenter, LivingOrDiningHeight);
										TempPair.ActionMarker = 0;
										TempPointPairs.Add(TempPair);
										BasePoint = FVector2D(CloestPointOfExtendPoint);
									}
									else
									{
										FVector2D TempAddNode1 = FVector2D(CloestPointOfExtendPoint) + 50 * EntranceDir;
										FVector2D TempMoveDir = CriticalDiningPoints[0] - FVector2D(CloestPointOfExtendPoint);
										FVector2D TempExtendPoint = FVector2D(TempAddNode1) + 1000 * TempMoveDir;
										FVector TempCloestPointOfTempExtendPoint = FMath::ClosestPointOnInfiniteLine(FVector(TempAddNode1, 0), FVector(TempExtendPoint, 0), FVector(CriticalDiningPoints[0], 0));
										FPointPair TempPair1, TempPair2;
										TempPair1.RoutinePoint = FVector(TempAddNode1.X, TempAddNode1.Y, LivingOrDiningHeight);
										TempPair1.WatchPoint = FVector(DiningRoomCenter, LivingOrDiningHeight);
										TempPair1.ActionMarker = 0;
										TempPointPairs.Add(TempPair1);
										TempPair2.RoutinePoint = FVector(TempCloestPointOfTempExtendPoint.X, TempCloestPointOfTempExtendPoint.Y, LivingOrDiningHeight);
										TempPair2.WatchPoint = FVector(DiningRoomCenter, LivingOrDiningHeight);
										TempPair2.ActionMarker = 0;
										TempPointPairs.Add(TempPair2);
										BasePoint = FVector2D(TempCloestPointOfTempExtendPoint);
									}
									///////微调此处路径点/////////////////

									if (CriticalDiningPoints.Num() > 0)
									{
										float StartToFirst = FVector2D::Distance(BasePoint, CriticalDiningPoints[0]);
										float StartToLast = FVector2D::Distance(BasePoint, CriticalDiningPoints.Last());
										if (StartToFirst > StartToLast)
										{
											for (int _CurP = CriticalDiningPoints.Num() - 1; _CurP >= 1; --_CurP)
											{
												FPointPair _CurPair;
												_CurPair.RoutinePoint = FVector(CriticalDiningPoints[_CurP], LivingOrDiningHeight);
												_CurPair.WatchPoint = FVector(DiningRoomCenter, LivingOrDiningHeight);
												_CurPair.ActionMarker = 0;
												TempPointPairs.Add(_CurPair);
											}
										}
										else
										{
											for (int _CurP = 1; _CurP < CriticalDiningPoints.Num(); ++_CurP)
											{
												FPointPair _CurPair;
												_CurPair.RoutinePoint = FVector(CriticalDiningPoints[_CurP], LivingOrDiningHeight);
												_CurPair.WatchPoint = FVector(DiningRoomCenter, LivingOrDiningHeight);
												_CurPair.ActionMarker = 0;
												TempPointPairs.Add(_CurPair);
											}
										}
									}
								}
								else
								{
									///////微调此处路径点/////////////////

									FPointPair _StartPoint;
									_StartPoint.RoutinePoint = StartPoint;
									_StartPoint.WatchPoint = FVector(DiningRoomCenter, LivingOrDiningHeight);
									_StartPoint.ActionMarker = 0;
									TempPointPairs.Add(_StartPoint);


									if (CriticalDiningPoints.Num() > 0)
									{
										float StartToFirst = FVector2D::Distance(FVector2D(StartPoint), CriticalDiningPoints[0]);
										float StartToLast = FVector2D::Distance(FVector2D(StartPoint), CriticalDiningPoints.Last());
										if (StartToFirst > StartToLast)
										{
											for (int _CurP = CriticalDiningPoints.Num() - 1; _CurP >= 1; --_CurP)
											{
												FPointPair _CurPair;
												_CurPair.RoutinePoint = FVector(CriticalDiningPoints[_CurP], LivingOrDiningHeight);
												_CurPair.WatchPoint = FVector(DiningRoomCenter, LivingOrDiningHeight);
												_CurPair.ActionMarker = 0;
												TempPointPairs.Add(_CurPair);
											}
										}
										else
										{
											for (int _CurP = 0; _CurP < CriticalDiningPoints.Num(); ++_CurP)
											{
												FPointPair _CurPair;
												_CurPair.RoutinePoint = FVector(CriticalDiningPoints[_CurP], LivingOrDiningHeight);
												_CurPair.WatchPoint = FVector(DiningRoomCenter, LivingOrDiningHeight);
												_CurPair.ActionMarker = 0;
												TempPointPairs.Add(_CurPair);
											}
										}
									}

								}

							}
						}
					}

					if (TempPointPairs.Num() > 0)
					{
						FPathLine TempLine;
						TempLine.RoutinePoints = TempPointPairs;
						TempPointPairs.Empty();
						RoomIDMapPathLine.Add(DiningRoomID, TempLine);
					}
					HasCalculatedRoomIDs.AddUnique(DiningRoomID);

					if (DiningChildRoomIDs.Num() > 0)
					{
						int TargetDiningChildID = 0;
						bool FindDiningChild = false;
						for (int _CurChild = 0; _CurChild < DiningChildRoomIDs.Num(); ++_CurChild)
						{
							int TempChildRoomID = DiningChildRoomIDs[_CurChild];
							FVector2D TempMapDoorCenter = DiningChildRoomIDMapDoorCenter[TempChildRoomID];
							float X_Differ = abs(TempMapDoorCenter.X - CriticalLivingPoints.Last().X);
							float Y_Differ = abs(TempMapDoorCenter.Y - CriticalLivingPoints.Last().Y);
							if ((X_Differ <= 85) || (Y_Differ <= 85))
							{
								TargetDiningChildID = DiningChildRoomIDs[_CurChild];
								FindDiningChild = true;
								break;
							}
						}
						if (FindDiningChild)
						{
							TArray<FVector> DoorPoints;
							TArray<FVector2D> CriticalDiningChildPoints;
							bool GetDiningChildDoors = GetDoorsOfRegion(WorldContextObject, TargetDiningChildID, DoorPoints);
							if (GetDiningChildDoors)
							{
								if ((RoomIDMapName[TargetDiningChildID] == TEXT("生活阳台")) || (RoomIDMapName[TargetDiningChildID] == TEXT("休闲阳台")))
								{
									FVector2D TempLocalRegionCenter;
									bool LocalChildSuccess = LocateTwoCriticalPointsOfBalcony(WorldContextObject, RoomIDMapBoundary[TargetDiningChildID], TargetDiningChildID,
										CriticalDiningChildPoints, TempLocalRegionCenter);
									if (LocalChildSuccess)
									{
										for (int _CurP = 0; _CurP < CriticalDiningChildPoints.Num(); ++_CurP)
										{
											FPointPair _CurPair;
											_CurPair.RoutinePoint = FVector(CriticalDiningPoints[_CurP], OtherHeight);
											_CurPair.WatchPoint = FVector(TempLocalRegionCenter, OtherHeight);
											_CurPair.ActionMarker = 0;
											TempPointPairs.Add(_CurPair);
										}
										if (TempPointPairs.Num() > 0)
										{
											FPathLine TempLine;
											TempLine.RoutinePoints = TempPointPairs;
											TempPointPairs.Empty();
											RoomIDMapPathLine.Add(TargetDiningChildID, TempLine);
										}

										HasCalculatedRoomIDs.AddUnique(TargetDiningChildID);
									}
								}
							}
						}

						if (DiningChildRoomIDs.Num() >= 2)
						{
							for (int _CurR = 0; _CurR < DiningChildRoomIDs.Num(); ++_CurR)
							{
								if (DiningChildRoomIDs[_CurR] != TargetDiningChildID)
								{
									TArray<FVector> TempDoorPoints;
									TArray<FVector2D> TempChildCriticalPoints;
									bool GetChildSuccess = GetDoorsOfRegion(WorldContextObject, DiningChildRoomIDs[_CurR], TempDoorPoints);
									if (GetChildSuccess)
									{
										if ((RoomIDMapName[DiningChildRoomIDs[_CurR]] == TEXT("生活阳台")) || (RoomIDMapName[DiningChildRoomIDs[_CurR]] == TEXT("休闲阳台")))
										{
											FVector2D TempLocalRegionCenter;
											TArray<FVector2D> TempCriticalChildPoints;
											bool LocalChildSuccess = LocateTwoCriticalPointsOfBalcony(WorldContextObject, RoomIDMapBoundary[DiningChildRoomIDs[_CurR]], DiningChildRoomIDs[_CurR],
												TempCriticalChildPoints, TempLocalRegionCenter);
											if (LocalChildSuccess)
											{
												for (int _CurP = 0; _CurP < TempCriticalChildPoints.Num(); ++_CurP)
												{
													FPointPair _CurPair;
													_CurPair.RoutinePoint = FVector(TempCriticalChildPoints[_CurP], OtherHeight);
													_CurPair.WatchPoint = FVector(TempLocalRegionCenter, OtherHeight);
													_CurPair.ActionMarker = 0;
													TempPointPairs.Add(_CurPair);
												}

												if (TempPointPairs.Num() > 0)
												{
													FPathLine TempLine;
													TempLine.RoutinePoints = TempPointPairs;
													TempPointPairs.Empty();
													RoomIDMapPathLine.Add(DiningChildRoomIDs[_CurR], TempLine);
												}

												HasCalculatedRoomIDs.AddUnique(DiningChildRoomIDs[_CurR]);
											}
										}
										else if (RoomIDMapName[DiningChildRoomIDs[_CurR]] == TEXT("厨房"))
										{
											TArray<FVector2D> TempCriticalChildPoints;
											FVector2D TempRegionCenter;
											bool LocalChildSuccess = LocateCriticalPointsOfKitchen(WorldContextObject,
												RoomIDMapBoundary[DiningChildRoomIDs[_CurR]],
												DiningChildRoomIDs[_CurR],
												TempCriticalChildPoints,
												TempRegionCenter);

											if (LocalChildSuccess)
											{
												for (int _CurP = 0; _CurP < TempCriticalChildPoints.Num(); ++_CurP)
												{
													FPointPair _CurPair;
													_CurPair.RoutinePoint = FVector(TempCriticalChildPoints[_CurP], OtherHeight);
													_CurPair.WatchPoint = FVector(TempRegionCenter, OtherHeight);
													if (_CurP == 0)
													{
														_CurPair.ActionMarker = 1;
													}
													else
													{
														_CurPair.ActionMarker = 0;
													}
													TempPointPairs.Add(_CurPair);
												}

												if (TempPointPairs.Num() > 0)
												{
													FPathLine TempLine;
													TempLine.RoutinePoints = TempPointPairs;
													TempPointPairs.Empty();
													RoomIDMapPathLine.Add(DiningChildRoomIDs[_CurR], TempLine);
												}

												HasCalculatedRoomIDs.AddUnique(DiningChildRoomIDs[_CurR]);
											}

										}


									}

								}

							}
						}
					}
				}

				if (LocateLivingSuccess)
				{
					for (int _CurP = 0; _CurP < CriticalLivingPoints.Num(); ++_CurP)
					{
						FPointPair _CurPair;
						_CurPair.RoutinePoint = FVector(CriticalLivingPoints[_CurP], LivingOrDiningHeight);
						_CurPair.WatchPoint = FVector(LivingRoomCenter, LivingOrDiningHeight);
						_CurPair.ActionMarker = 0;
						TempPointPairs.Add(_CurPair);
					}

					if (TempPointPairs.Num() > 0)
					{
						FPathLine TempLine;
						TempLine.RoutinePoints = TempPointPairs;
						TempPointPairs.Empty();
						RoomIDMapPathLine.Add(LivingRoomID, TempLine);
					}
					HasCalculatedRoomIDs.AddUnique(LivingRoomID);

					if (LivingChildRoomIDs.Num() > 0)
					{
						int TargetLivingChildID = 0;
						bool FindLivingChild = false;
						for (int _CurChild = 0; _CurChild < LivingChildRoomIDs.Num(); ++_CurChild)
						{
							int TempChildRoomID = LivingChildRoomIDs[_CurChild];
							FVector2D TempMapDoorCenter = LivingChildRoomIDMapDoorCenter[TempChildRoomID];
							float X_Differ = abs(TempMapDoorCenter.X - CriticalLivingPoints.Last().X);
							float Y_Differ = abs(TempMapDoorCenter.Y - CriticalLivingPoints.Last().Y);
							if ((X_Differ <= 85) || (Y_Differ <= 85))
							{
								TargetLivingChildID = LivingChildRoomIDs[_CurChild];
								FindLivingChild = true;
								break;
							}
						}
						if (FindLivingChild)
						{
							TArray<FVector> DoorPoints;
							TArray<FVector2D> CriticalLivingChildPoints;
							bool GetLivingChildDoors = GetDoorsOfRegion(WorldContextObject, TargetLivingChildID, DoorPoints);
							if (GetLivingChildDoors)
							{

								if ((RoomIDMapName[TargetLivingChildID] == TEXT("生活阳台")) || (RoomIDMapName[TargetLivingChildID] == TEXT("休闲阳台")))
								{
									FVector2D TempLocalRegionCenter;
									bool LocalChildSuccess = LocateTwoCriticalPointsOfBalcony(WorldContextObject, RoomIDMapBoundary[TargetLivingChildID], TargetLivingChildID,
										CriticalLivingChildPoints, TempLocalRegionCenter);
									if (LocalChildSuccess)
									{
										for (int _CurP = 0; _CurP < CriticalLivingChildPoints.Num(); ++_CurP)
										{
											FPointPair TempChildPair;
											TempChildPair.RoutinePoint = FVector(CriticalLivingChildPoints[_CurP], OtherHeight);
											TempChildPair.WatchPoint = FVector(TempLocalRegionCenter, OtherHeight);
											TempChildPair.ActionMarker = 0;
											TempPointPairs.Add(TempChildPair);
										}

										if (TempPointPairs.Num() > 0)
										{
											FPathLine TempLine;
											TempLine.RoutinePoints = TempPointPairs;
											TempPointPairs.Empty();
											RoomIDMapPathLine.Add(TargetLivingChildID, TempLine);
										}
										HasCalculatedRoomIDs.AddUnique(TargetLivingChildID);
									}
								}
							}
						}

						if (LivingChildRoomIDs.Num() >= 2)
						{
							for (int _CurR = 0; _CurR < LivingChildRoomIDs.Num(); ++_CurR)
							{
								if (LivingChildRoomIDs[_CurR] != TargetLivingChildID)
								{
									TArray<FVector> TempDoorPoints;
									TArray<FVector2D> TempChildCriticalPoints;
									bool GetChildSuccess = GetDoorsOfRegion(WorldContextObject, LivingChildRoomIDs[_CurR], TempDoorPoints);
									if (GetChildSuccess)
									{
										if ((RoomIDMapName[LivingChildRoomIDs[_CurR]] == TEXT("生活阳台")) || (RoomIDMapName[LivingChildRoomIDs[_CurR]] == TEXT("休闲阳台")))
										{
											FVector2D TempLocalRegionCenter;
											TArray<FVector2D> TempCriticalChildPoints;
											bool LocalChildSuccess = LocateTwoCriticalPointsOfBalcony(WorldContextObject, RoomIDMapBoundary[LivingChildRoomIDs[_CurR]], LivingChildRoomIDs[_CurR],
												TempCriticalChildPoints, TempLocalRegionCenter);
											if (LocalChildSuccess)
											{
												for (int _CurP = 0; _CurP < TempCriticalChildPoints.Num(); ++_CurP)
												{
													FPointPair _CurPair;
													_CurPair.RoutinePoint = FVector(TempCriticalChildPoints[_CurP], OtherHeight);
													_CurPair.WatchPoint = FVector(TempLocalRegionCenter, OtherHeight);
													_CurPair.ActionMarker = 0;
													TempPointPairs.Add(_CurPair);
												}

												if (TempPointPairs.Num() > 0)
												{
													FPathLine TempLine;
													TempLine.RoutinePoints = TempPointPairs;
													TempPointPairs.Empty();
													RoomIDMapPathLine.Add(LivingChildRoomIDs[_CurR], TempLine);
												}

												HasCalculatedRoomIDs.AddUnique(LivingChildRoomIDs[_CurR]);
											}
										}
									}

								}

							}
						}

					}
				}
			}

			NumOfIter = 0;
			while (AllRoomIDs.Num() != HasCalculatedRoomIDs.Num())
			{
				NumOfIter++;
				for (int _CurRoom = 0; _CurRoom < AllRoomIDs.Num(); ++_CurRoom)
				{
					if (!HasCalculatedRoomIDs.Contains(AllRoomIDs[_CurRoom]))
					{
						FString TempName = RoomIDMapName[AllRoomIDs[_CurRoom]];
						if ((TempName == TEXT("主卧")) || (TempName == TEXT("次卧")) || (TempName == TEXT("儿童房")) || (TempName == TEXT("老人房")) ||
							(TempName == TEXT("榻榻米房")) || (TempName == TEXT("多功能房")) || (TempName == TEXT("书房"))
							|| (TempName == TEXT("客人房")) || (TempName == TEXT("健身房")))
						{
							TArray<FVector2D> TempRoomCriticalPoints;
							FVector2D TempCenter;
							bool IsSuccess = LocateCriticalPointsOfRoom(WorldContextObject, LivingRoomPs, DiningRoomPs, RoomIDMapBoundary[AllRoomIDs[_CurRoom]], AllRoomIDs[_CurRoom], TempRoomCriticalPoints, TempCenter);
							if (IsSuccess)
							{
								for (int _CurP = 0; _CurP < TempRoomCriticalPoints.Num(); ++_CurP)
								{
									FPointPair _CurPair;
									_CurPair.RoutinePoint = FVector(TempRoomCriticalPoints[_CurP], OtherHeight);
									_CurPair.WatchPoint = FVector(TempCenter, OtherHeight);
									if (TempRoomCriticalPoints.Num() == 1)
									{
										_CurPair.ActionMarker = 1;
									}
									else
									{
										_CurPair.ActionMarker = 0;
									}
									TempPointPairs.Add(_CurPair);
								}
								if (TempPointPairs.Num() > 0)
								{
									FPathLine TempLine;
									TempLine.RoutinePoints = TempPointPairs;
									TempPointPairs.Empty();
									RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
								}
								HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
							}
						}
						else if ((TempName == TEXT("主卫")) || (TempName == TEXT("客卫")) || (TempName == TEXT("卫生间")))
						{
							TArray<FVector2D> TempToiletCriticalPoints;
							FVector2D TempLocalCenter;
							bool LocateToiletSuccess = LocateCriticalPointsOfToilet(WorldContextObject,
								RoomIDMapBoundary[AllRoomIDs[_CurRoom]],
								AllWallCenters,
								AllRoomIDs[_CurRoom],
								TempToiletCriticalPoints,
								TempLocalCenter);
							if (LocateToiletSuccess)
							{
								for (int _CurP = 0; _CurP < TempToiletCriticalPoints.Num(); ++_CurP)
								{
									FPointPair _CurPair;
									_CurPair.RoutinePoint = FVector(TempToiletCriticalPoints[_CurP], OtherHeight);
									_CurPair.WatchPoint = FVector(TempLocalCenter, OtherHeight);
									if (_CurP == 0)
									{
										_CurPair.ActionMarker = 1;
									}
									else
									{
										_CurPair.ActionMarker = 0;
									}
									TempPointPairs.Add(_CurPair);
								}

								if (TempPointPairs.Num() > 0)
								{
									FPathLine TempLine;
									TempLine.RoutinePoints = TempPointPairs;
									TempPointPairs.Empty();
									RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
								}
								HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
							}
						}
						else if ((TempName == TEXT("生活阳台")) || (TempName == TEXT("休闲阳台")))
						{
							TArray<FVector2D> TempCriticalPoints;
							FVector2D  LocalRegionCenter;
							bool IsGetted = LocateTwoCriticalPointsOfBalcony(WorldContextObject, RoomIDMapBoundary[AllRoomIDs[_CurRoom]], AllRoomIDs[_CurRoom],
								TempCriticalPoints, LocalRegionCenter);
							if (IsGetted)
							{
								for (int _CurP = 0; _CurP < TempCriticalPoints.Num(); ++_CurP)
								{
									FPointPair _CurPair;
									_CurPair.RoutinePoint = FVector(TempCriticalPoints[_CurP], OtherHeight);
									_CurPair.WatchPoint = FVector(LocalRegionCenter, OtherHeight);
									_CurPair.ActionMarker = 0;
									TempPointPairs.Add(_CurPair);
								}

								if (TempPointPairs.Num() > 0)
								{
									FPathLine TempLine;
									TempLine.RoutinePoints = TempPointPairs;
									TempPointPairs.Empty();
									RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
								}
								HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
							}
						}
						else if (TempName == TEXT("厨房"))
						{
							TArray<FVector2D> TempKitchenCriticalPoints;
							FVector2D  KitchenRegionCenter;
							bool IsLocated = LocateCriticalPointsOfKitchen(WorldContextObject,
								RoomIDMapBoundary[AllRoomIDs[_CurRoom]],
								AllRoomIDs[_CurRoom],
								TempKitchenCriticalPoints,
								KitchenRegionCenter);
							if (IsLocated)
							{
								for (int _CurP = 0; _CurP < TempKitchenCriticalPoints.Num(); ++_CurP)
								{
									FPointPair _CurPair;
									_CurPair.RoutinePoint = FVector(TempKitchenCriticalPoints[_CurP], OtherHeight);
									_CurPair.WatchPoint = FVector(KitchenRegionCenter, OtherHeight);
									if (_CurP == 0)
									{
										_CurPair.ActionMarker = 1;
									}
									else
									{
										_CurPair.ActionMarker = 0;
									}
									TempPointPairs.Add(_CurPair);
								}

								if (TempPointPairs.Num() > 0)
								{
									FPathLine TempLine;
									TempLine.RoutinePoints = TempPointPairs;
									TempPointPairs.Empty();
									RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
								}
								HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
							}
						}
						else if ((TempName == TEXT("衣帽间")) || (TempName == TEXT("储藏间")))
						{
							FVector2D TempCenter;
							bool IsLocateCenter = FPolygonAlg::LocateSuitableCenter(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], TempCenter);
							if (IsLocateCenter)
							{
								TArray<FVector> DoorPoints;
								bool GetDoors = GetDoorsOfRegion(WorldContextObject, AllRoomIDs[_CurRoom], DoorPoints);
								if (GetDoors)
								{
									int NumOfDoors = DoorPoints.Num() / 8;
									if (NumOfDoors >= 1)
									{
										FVector2D TempFinalNode;
										for (int _CurDoor = 0; _CurDoor < NumOfDoors; ++_CurDoor)
										{
											FVector2D TempDoorCenter = FVector2D(0.25*(DoorPoints[0 + 8 * _CurDoor] + DoorPoints[1 + 8 * _CurDoor] + DoorPoints[2 + 8 * _CurDoor] + DoorPoints[3 + 8 * _CurDoor]));
											FVector2D TempSide1 = FVector2D(DoorPoints[1 + 8 * _CurDoor] - DoorPoints[0 + 8 * _CurDoor]);
											FVector2D TempSide2 = FVector2D(DoorPoints[2 + 8 * _CurDoor] - DoorPoints[0 + 8 * _CurDoor]);
											float TempLength1 = TempSide1.Size();
											float TempLength2 = TempSide2.Size();
											TempSide1.Normalize();
											TempSide2.Normalize();
											FVector2D TempBaseDir;
											if (TempLength1 > TempLength2)
											{
												TempBaseDir = TempSide2;
											}
											else
											{
												TempBaseDir = TempSide1;
											}

											FVector2D TempNode1 = TempDoorCenter + 25 * TempBaseDir;
											FVector2D TempNode2 = TempDoorCenter - 25 * TempBaseDir;
											if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], TempNode1))
											{
												TempFinalNode = TempNode1;
												break;
											}
											if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], TempNode2))
											{
												TempFinalNode = TempNode2;
												break;
											}
										}

										FPointPair _CurPair1;
										_CurPair1.RoutinePoint = FVector(TempFinalNode, OtherHeight);
										_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
										_CurPair1.ActionMarker = 1;
										TempPointPairs.Add(_CurPair1);


										if (TempPointPairs.Num() > 0)
										{
											FPathLine TempLine;
											TempLine.RoutinePoints = TempPointPairs;
											TempPointPairs.Empty();
											RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
										}

										HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
									}
								}
								else
								{
									int CurrentEdge = 0, NextEdge = 0;
									for (int _CurEdge = 0; _CurEdge < RoomIDMapBoundary[AllRoomIDs[_CurRoom]].Num(); ++_CurEdge)
									{
										if (_CurEdge == RoomIDMapBoundary[AllRoomIDs[_CurRoom]].Num() - 1)
										{
											NextEdge = 0;
										}
										else
										{
											NextEdge = _CurEdge + 1;
										}
										FVector2D TempMiddleP = 0.5*(RoomIDMapBoundary[AllRoomIDs[_CurRoom]][_CurEdge] + RoomIDMapBoundary[AllRoomIDs[_CurRoom]][NextEdge]);
										FVector2D EdgeDir = RoomIDMapBoundary[AllRoomIDs[_CurRoom]][NextEdge] - RoomIDMapBoundary[AllRoomIDs[_CurRoom]][_CurEdge];
										EdgeDir.Normalize();
										FVector2D RotatedEdgeDir = EdgeDir.GetRotated(90);
										FVector2D TempExtendP1 = TempMiddleP + 5 * RotatedEdgeDir;
										FVector2D TempExtendP2 = TempMiddleP - 5 * RotatedEdgeDir;
										for (int IRoom = 0; IRoom < AllRoomIDs.Num(); ++IRoom)
										{
											if (AllRoomIDs[IRoom] != AllRoomIDs[_CurRoom])
											{
												if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[IRoom]], TempExtendP1))
												{
													FPointPair _CurPair1;
													_CurPair1.RoutinePoint = FVector(TempExtendP1 - 10 * RotatedEdgeDir, OtherHeight);
													_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
													_CurPair1.ActionMarker = 1;
													TempPointPairs.Add(_CurPair1);


													HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
													break;
												}

												if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[IRoom]], TempExtendP2))
												{
													FPointPair _CurPair1;
													_CurPair1.RoutinePoint = FVector(TempExtendP2 + 10 * RotatedEdgeDir, OtherHeight);
													_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
													_CurPair1.ActionMarker = 1;
													TempPointPairs.Add(_CurPair1);


													HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
													break;
												}
											}
										}
									}

									if (TempPointPairs.Num() > 0)
									{
										FPathLine TempLine;
										TempLine.RoutinePoints = TempPointPairs;
										TempPointPairs.Empty();
										RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
									}
								}

							}
						}
						else
						{
							FVector2D TempCenter;
							bool IsLocateCenter = FPolygonAlg::LocateSuitableCenter(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], TempCenter);
							if (IsLocateCenter)
							{
								TArray<FVector> DoorPoints;
								bool GetDoors = GetDoorsOfRegion(WorldContextObject, AllRoomIDs[_CurRoom], DoorPoints);
								if (GetDoors)
								{
									int NumOfDoors = DoorPoints.Num() / 8;
									if (NumOfDoors >= 1)
									{
										FVector2D TempDoorCenter = FVector2D(0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]));
										FVector2D TempDir = TempCenter - TempDoorCenter;
										FVector2D TempNode1 = TempDoorCenter + 0.25*TempDir;
										FVector2D TempNode2 = 0.5*(TempDoorCenter + TempCenter);
										FPointPair _CurPair1;
										_CurPair1.RoutinePoint = FVector(TempNode1, OtherHeight);
										_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
										_CurPair1.ActionMarker = 1;
										TempPointPairs.Add(_CurPair1);
										FPointPair _CurPair2;
										_CurPair2.RoutinePoint = FVector(TempNode2, OtherHeight);
										_CurPair2.WatchPoint = FVector(TempCenter, OtherHeight);
										_CurPair2.ActionMarker = 0;
										TempPointPairs.Add(_CurPair2);

										if (TempPointPairs.Num() > 0)
										{
											FPathLine TempLine;
											TempLine.RoutinePoints = TempPointPairs;
											TempPointPairs.Empty();
											RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
										}

										HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
									}
									else
									{
										FPointPair _CurPair1;
										_CurPair1.RoutinePoint = FVector(TempCenter, OtherHeight);
										_CurPair1.WatchPoint = FVector(0.0, 0.0, OtherHeight);
										_CurPair1.ActionMarker = 1;
										TempPointPairs.Add(_CurPair1);

										if (TempPointPairs.Num() > 0)
										{
											FPathLine TempLine;
											TempLine.RoutinePoints = TempPointPairs;
											TempPointPairs.Empty();
											RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
										}

										HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
									}
								}
							}
						}
					}
				}
				if (NumOfIter >= MaxNumIter)
				{
					return false;
				}
			}
			/////////////////////////////////纠正第一个点的指向点////////////////////////////////////////////
			if (BControlDirOfFirstP)
			{
				/*auto MapLineBegin = RoomIDMapPathLine.begin();
				int LocalIDOfRoom = (*MapLineBegin).Key;
				FPathLine TempMapLine = RoomIDMapPathLine[LocalIDOfRoom];
				TArray<FPointPair> TempPointPairArr = TempMapLine.RoutinePoints;
				if (TempPointPairArr.Num() > 1)
				{
					TempPointPairArr[0].WatchPoint = TempPointPairArr[1].RoutinePoint;
					TempMapLine.RoutinePoints = TempPointPairArr;
					RoomIDMapPathLine[LocalIDOfRoom]
				}*/

				FPathLine *TempMapLine = RoomIDMapPathLine.Find(GlobaleEntranceRoomID);
				if (TempMapLine != nullptr)
				{
					TArray<FPointPair> TempPointPairArr = (*TempMapLine).RoutinePoints;
					if (TempPointPairArr.Num() > 1)
					{
						TempPointPairArr[0].WatchPoint = TempPointPairArr[1].RoutinePoint;
						(*TempMapLine).RoutinePoints = TempPointPairArr;
						RoomIDMapPathLine[GlobaleEntranceRoomID] = (*TempMapLine);
					}
				}
			}
		}
		else
		{
			FString EntranceRoomName = RoomIDMapName[GlobaleEntranceRoomID];
			if (EntranceRoomName == TEXT("厨房"))
			{
				TArray<FVector2D> TempKitchenCriticalPoints;
				FVector2D  KitchenRegionCenter;
				bool IsLocated = LocateCriticalPointsOfKitchen(WorldContextObject,
					RoomIDMapBoundary[GlobaleEntranceRoomID],
					GlobaleEntranceRoomID,
					TempKitchenCriticalPoints,
					KitchenRegionCenter);
				if (IsLocated)
				{
					for (int _CurP = 0; _CurP < TempKitchenCriticalPoints.Num(); ++_CurP)
					{
						FPointPair _CurPair;
						_CurPair.RoutinePoint = FVector(TempKitchenCriticalPoints[_CurP], OtherHeight);
						_CurPair.WatchPoint = FVector(KitchenRegionCenter, OtherHeight);
						if (_CurP == 0)
						{
							_CurPair.ActionMarker = 1;
						}
						else
						{
							_CurPair.ActionMarker = 0;
						}
						TempPointPairs.Add(_CurPair);
					}

					if (TempPointPairs.Num() > 0)
					{
						FPathLine TempLine;
						TempLine.RoutinePoints = TempPointPairs;
						TempPointPairs.Empty();
						RoomIDMapPathLine.Add(GlobaleEntranceRoomID, TempLine);
					}
					HasCalculatedRoomIDs.AddUnique(GlobaleEntranceRoomID);
				}
			}
			else if ((EntranceRoomName == TEXT("主卫")) || (EntranceRoomName == TEXT("客卫")))
			{
				TArray<FVector2D> TempToiletCriticalPoints;
				FVector2D TempLocalCenter;
				bool LocateToiletSuccess = LocateCriticalPointsOfToilet(WorldContextObject,
					RoomIDMapBoundary[GlobaleEntranceRoomID],
					AllWallCenters,
					GlobaleEntranceRoomID,
					TempToiletCriticalPoints,
					TempLocalCenter);
				if (LocateToiletSuccess)
				{
					for (int _CurP = 0; _CurP < TempToiletCriticalPoints.Num(); ++_CurP)
					{
						FPointPair _CurPair;
						_CurPair.RoutinePoint = FVector(TempToiletCriticalPoints[_CurP], OtherHeight);
						_CurPair.WatchPoint = FVector(TempLocalCenter, OtherHeight);
						if (_CurP == 0)
						{
							_CurPair.ActionMarker = 1;
						}
						else
						{
							_CurPair.ActionMarker = 0;
						}
						TempPointPairs.Add(_CurPair);
					}

					if (TempPointPairs.Num() > 0)
					{
						FPathLine TempLine;
						TempLine.RoutinePoints = TempPointPairs;
						TempPointPairs.Empty();
						RoomIDMapPathLine.Add(GlobaleEntranceRoomID, TempLine);
					}
					HasCalculatedRoomIDs.AddUnique(GlobaleEntranceRoomID);
				}
			}
			else if ((EntranceRoomName == TEXT("衣帽间")) || (EntranceRoomName == TEXT("储藏间")))
			{
				FVector2D TempCenter;
				bool IsLocateCenter = FPolygonAlg::LocateSuitableCenter(RoomIDMapBoundary[GlobaleEntranceRoomID], TempCenter);
				if (IsLocateCenter)
				{
					TArray<FVector> DoorPoints;
					bool GetDoors = GetDoorsOfRegion(WorldContextObject, GlobaleEntranceRoomID, DoorPoints);
					if (GetDoors)
					{
						int NumOfDoors = DoorPoints.Num() / 8;
						if (NumOfDoors >= 1)
						{
							FVector2D TempFinalNode;
							for (int _CurDoor = 0; _CurDoor < NumOfDoors; ++_CurDoor)
							{
								FVector2D TempDoorCenter = FVector2D(0.25*(DoorPoints[0 + 8 * _CurDoor] + DoorPoints[1 + 8 * _CurDoor] + DoorPoints[2 + 8 * _CurDoor] + DoorPoints[3 + 8 * _CurDoor]));
								FVector2D TempSide1 = FVector2D(DoorPoints[1 + 8 * _CurDoor] - DoorPoints[0 + 8 * _CurDoor]);
								FVector2D TempSide2 = FVector2D(DoorPoints[2 + 8 * _CurDoor] - DoorPoints[0 + 8 * _CurDoor]);
								float TempLength1 = TempSide1.Size();
								float TempLength2 = TempSide2.Size();
								TempSide1.Normalize();
								TempSide2.Normalize();
								FVector2D TempBaseDir;
								if (TempLength1 > TempLength2)
								{
									TempBaseDir = TempSide2;
								}
								else
								{
									TempBaseDir = TempSide1;
								}

								FVector2D TempNode1 = TempDoorCenter + 25 * TempBaseDir;
								FVector2D TempNode2 = TempDoorCenter - 25 * TempBaseDir;
								if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[GlobaleEntranceRoomID], TempNode1))
								{
									TempFinalNode = TempNode1;
									break;
								}
								if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[GlobaleEntranceRoomID], TempNode2))
								{
									TempFinalNode = TempNode2;
									break;
								}
							}

							FPointPair _CurPair1;
							_CurPair1.RoutinePoint = FVector(TempFinalNode, OtherHeight);
							_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
							_CurPair1.ActionMarker = 1;
							TempPointPairs.Add(_CurPair1);


							if (TempPointPairs.Num() > 0)
							{
								FPathLine TempLine;
								TempLine.RoutinePoints = TempPointPairs;
								TempPointPairs.Empty();
								RoomIDMapPathLine.Add(GlobaleEntranceRoomID, TempLine);
							}

							HasCalculatedRoomIDs.AddUnique(GlobaleEntranceRoomID);
						}
					}
					else
					{
						int CurrentEdge = 0, NextEdge = 0;
						for (int _CurEdge = 0; _CurEdge < RoomIDMapBoundary[GlobaleEntranceRoomID].Num(); ++_CurEdge)
						{
							if (_CurEdge == RoomIDMapBoundary[GlobaleEntranceRoomID].Num() - 1)
							{
								NextEdge = 0;
							}
							else
							{
								NextEdge = _CurEdge + 1;
							}
							FVector2D TempMiddleP = 0.5*(RoomIDMapBoundary[GlobaleEntranceRoomID][_CurEdge] + RoomIDMapBoundary[GlobaleEntranceRoomID][NextEdge]);
							FVector2D EdgeDir = RoomIDMapBoundary[GlobaleEntranceRoomID][NextEdge] - RoomIDMapBoundary[GlobaleEntranceRoomID][_CurEdge];
							EdgeDir.Normalize();
							FVector2D RotatedEdgeDir = EdgeDir.GetRotated(90);
							FVector2D TempExtendP1 = TempMiddleP + 5 * RotatedEdgeDir;
							FVector2D TempExtendP2 = TempMiddleP - 5 * RotatedEdgeDir;
							for (int IRoom = 0; IRoom < AllRoomIDs.Num(); ++IRoom)
							{
								if (AllRoomIDs[IRoom] != GlobaleEntranceRoomID)
								{
									if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[IRoom]], TempExtendP1))
									{
										FPointPair _CurPair1;
										_CurPair1.RoutinePoint = FVector(TempExtendP1 - 10 * RotatedEdgeDir, OtherHeight);
										_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
										_CurPair1.ActionMarker = 1;
										TempPointPairs.Add(_CurPair1);
										HasCalculatedRoomIDs.AddUnique(GlobaleEntranceRoomID);
										break;
									}

									if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[IRoom]], TempExtendP2))
									{
										FPointPair _CurPair1;
										_CurPair1.RoutinePoint = FVector(TempExtendP2 + 10 * RotatedEdgeDir, OtherHeight);
										_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
										_CurPair1.ActionMarker = 1;
										TempPointPairs.Add(_CurPair1);
										HasCalculatedRoomIDs.AddUnique(GlobaleEntranceRoomID);
										break;
									}
								}
							}
						}

						if (TempPointPairs.Num() > 0)
						{
							FPathLine TempLine;
							TempLine.RoutinePoints = TempPointPairs;
							TempPointPairs.Empty();
							RoomIDMapPathLine.Add(GlobaleEntranceRoomID, TempLine);
						}
					}
				}
			}
			else if ((EntranceRoomName == TEXT("主卧")) || (EntranceRoomName == TEXT("次卧")) || (EntranceRoomName == TEXT("老人房")) || (EntranceRoomName == TEXT("书房")) || (EntranceRoomName == TEXT("多功能房"))
				|| (EntranceRoomName == TEXT("儿童房")) || (EntranceRoomName == TEXT("榻榻米房")))
			{
				TArray<FVector2D> TempRoomCriticalPoints, MaxLocalRegion;
				bool IsSuccess = FPolygonAlg::LocateMaxLocalRegionOfRoom(RoomIDMapBoundary[GlobaleEntranceRoomID], MaxLocalRegion);
				if (IsSuccess)
				{
					FVector2D TempCenterP(0.0, 0.0);
					for (int _CurJ = 0; _CurJ < MaxLocalRegion.Num(); ++_CurJ)
					{
						TempCenterP = TempCenterP + MaxLocalRegion[_CurJ];
					}

					TempCenterP = TempCenterP / MaxLocalRegion.Num();
					FVector2D TempNode1 = 0.5*(GlobaleEntranceDoorCenter + TempCenterP);
					if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[GlobaleEntranceRoomID], TempNode1))
					{
						TempRoomCriticalPoints.AddUnique(TempNode1);
					}
					TempRoomCriticalPoints.AddUnique(0.8*TempCenterP + 0.2*GlobaleEntranceDoorCenter);

					for (int _CurP = 0; _CurP < TempRoomCriticalPoints.Num(); ++_CurP)
					{
						FPointPair _CurPair;
						_CurPair.RoutinePoint = FVector(TempRoomCriticalPoints[_CurP], OtherHeight);
						_CurPair.WatchPoint = FVector(TempCenterP, OtherHeight);
						if (TempRoomCriticalPoints.Num() == 1)
						{
							_CurPair.ActionMarker = 1;
						}
						else
						{
							_CurPair.ActionMarker = 0;
						}
						TempPointPairs.Add(_CurPair);
					}
					if (TempPointPairs.Num() > 0)
					{
						FPathLine TempLine;
						TempLine.RoutinePoints = TempPointPairs;
						TempPointPairs.Empty();
						RoomIDMapPathLine.Add(GlobaleEntranceRoomID, TempLine);
					}
					HasCalculatedRoomIDs.AddUnique(GlobaleEntranceRoomID);
				}
			}

			/////////////////////计算剩余空间//////////////////////
			NumOfIter = 0;
			while (AllRoomIDs.Num() != HasCalculatedRoomIDs.Num())
			{
				NumOfIter++;
				for (int _CurRoom = 0; _CurRoom < AllRoomIDs.Num(); ++_CurRoom)
				{
					if (!HasCalculatedRoomIDs.Contains(AllRoomIDs[_CurRoom]))
					{
						FString TempName = RoomIDMapName[AllRoomIDs[_CurRoom]];
						if ((TempName == TEXT("主卧")) || (TempName == TEXT("次卧")) || (TempName == TEXT("儿童房")) || (TempName == TEXT("老人房")) ||
							(TempName == TEXT("榻榻米房")) || (TempName == TEXT("多功能房")) || (TempName == TEXT("书房"))
							|| (TempName == TEXT("客人房")) || (TempName == TEXT("健身房")))
						{
							TArray<FVector2D> TempRoomCriticalPoints, MaxLocalRegion;
							FVector2D TempWatchNode;

							bool PointInModel = false;
							bool IsSuccess = FPolygonAlg::LocateMaxLocalRegionOfRoom(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], MaxLocalRegion);
							if (IsSuccess)
							{
								FVector2D TempCenterP(0.0, 0.0);
								for (int _CurJ = 0; _CurJ < MaxLocalRegion.Num(); ++_CurJ)
								{
									TempCenterP = TempCenterP + MaxLocalRegion[_CurJ];
								}
								TempCenterP = TempCenterP / MaxLocalRegion.Num();
								TArray<FVector2D> ShrinkPoints;
								for (int IP = 0; IP < MaxLocalRegion.Num(); ++IP)
								{
									ShrinkPoints.Add(ShrinkRatio*MaxLocalRegion[IP] + (1 - ShrinkRatio)*TempCenterP);
								}
								FVector2D Node1 = 0.5*(ShrinkPoints[0] + ShrinkPoints[1]);
								FVector2D Node2 = 0.5*(ShrinkPoints[1] + ShrinkPoints[2]);
								FVector2D Node3 = 0.5*(ShrinkPoints[2] + ShrinkPoints[3]);
								FVector2D Node4 = 0.5*(ShrinkPoints[3] + ShrinkPoints[0]);

								TArray<AFurnitureModelActor*> ModelsOfRoom;
								FindModelsOfRoom(WorldContextObject, RoomIDMapBoundary[AllRoomIDs[_CurRoom]], ModelsOfRoom);
								AFurnitureModelActor* FindFur = nullptr;
								bool FindModel = false;
								for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
								{
									AFurnitureModelActor* TempFur = ModelsOfRoom[_CurM];
									int TempID = 0;
									TempFur->GetModelCategory(TempID);
									if ((TempID == 5009) || (TempID == 5010) || (TempID == 5125))
									{
										FindFur = TempFur;
										FindModel = true;
										break;
									}
								}



								TArray<AHouseCustomActor*> CustomModelsOfRoom;
								FindCustomModelsOfRoom(WorldContextObject, RoomIDMapBoundary[AllRoomIDs[_CurRoom]], CustomModelsOfRoom);


								if (FindModel)
								{
									FBox TempBox = FindFur->GetComponentsBoundingBox(true);
									FVector FMin = TempBox.Min;
									FVector FMax = TempBox.Max;
									FVector2D P1(FMin.X, FMin.Y);
									FVector2D P2(FMax.X, FMin.Y);
									FVector2D P3(FMax.X, FMax.Y);
									FVector2D P4(FMin.X, FMax.Y);
									FVector2D BoxCenter = 0.25*(P1 + P2 + P3 + P4);
									TempWatchNode = BoxCenter;
									float Dis1 = FVector2D::Distance(Node1, BoxCenter);
									float Dis2 = FVector2D::Distance(Node2, BoxCenter);
									float Dis3 = FVector2D::Distance(Node3, BoxCenter);
									float Dis4 = FVector2D::Distance(Node4, BoxCenter);
									FVector2D BaseNode = Node1;
									if ((Dis2 >= Dis1) && (Dis2 >= Dis3) && (Dis2 >= Dis4))
									{
										BaseNode = Node2;
									}
									else if ((Dis3 >= Dis1) && (Dis3 >= Dis2) && (Dis3 >= Dis4))
									{
										BaseNode = Node3;
									}
									else if ((Dis4 >= Dis1) && (Dis4 >= Dis2) && (Dis4 >= Dis3))
									{
										BaseNode = Node4;
									}

									for (int _CurM = 0; _CurM < CustomModelsOfRoom.Num(); ++_CurM)
									{
										FBox TempBox = CustomModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
										FString ModelName = CustomModelsOfRoom[_CurM]->GetName();
										if (!ModelName.Contains(FString("Light")))
										{
											bool IfInModel = TempBox.IsInsideOrOn(FVector(BaseNode, OtherHeight));
											if (IfInModel)
											{
												FVector FMin = TempBox.Min;
												FVector FMax = TempBox.Max;
												bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, RoomIDMapBoundary[AllRoomIDs[_CurRoom]]);
												if (ModelBoxIsUseful)
												{
													PointInModel = true;
													break;
												}
											}
										}
									}

									for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
									{
										FBox TempBox = ModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
										FString ModelName = ModelsOfRoom[_CurM]->GetName();
										if (!ModelName.Contains(FString("Light")))
										{
											bool IfInModel = TempBox.IsInsideOrOn(FVector(BaseNode, OtherHeight));
											if (IfInModel)
											{
												FVector FMin = TempBox.Min;
												FVector FMax = TempBox.Max;
												bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, RoomIDMapBoundary[AllRoomIDs[_CurRoom]]);
												if (ModelBoxIsUseful)
												{
													PointInModel = true;
													break;
												}
											}
										}
									}
									if (!PointInModel)
									{
										TempRoomCriticalPoints.Add(BaseNode);
										TempRoomCriticalPoints.Add(0.8*BoxCenter + 0.2*BaseNode);
									}
								}
							}

							if (TempRoomCriticalPoints.Num() == 0)
							{
								FVector2D LocalCenterNode;
								FPolygonAlg::LocateSuitableCenter(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], LocalCenterNode);
								TempRoomCriticalPoints.AddUnique(LocalCenterNode);
								TempWatchNode = FVector2D(0.0, 0.0);
							}


							for (int _CurP = 0; _CurP < TempRoomCriticalPoints.Num(); ++_CurP)
							{
								FPointPair _CurPair;
								_CurPair.RoutinePoint = FVector(TempRoomCriticalPoints[_CurP], OtherHeight);
								_CurPair.WatchPoint = FVector(TempWatchNode, OtherHeight);
								if (TempRoomCriticalPoints.Num() == 1)
								{
									_CurPair.ActionMarker = 1;
								}
								else
								{
									_CurPair.ActionMarker = 0;
								}
								TempPointPairs.Add(_CurPair);
							}
							if (TempPointPairs.Num() > 0)
							{
								FPathLine TempLine;
								TempLine.RoutinePoints = TempPointPairs;
								TempPointPairs.Empty();
								RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
							}
							HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
						}
						else if ((TempName == TEXT("主卫")) || (TempName == TEXT("客卫")) || (TempName == TEXT("卫生间")))
						{
							TArray<FVector2D> TempToiletCriticalPoints;
							FVector2D TempLocalCenter;
							bool LocateToiletSuccess = LocateCriticalPointsOfToilet(WorldContextObject,
								RoomIDMapBoundary[AllRoomIDs[_CurRoom]],
								AllWallCenters,
								AllRoomIDs[_CurRoom],
								TempToiletCriticalPoints,
								TempLocalCenter);
							if (LocateToiletSuccess)
							{
								for (int _CurP = 0; _CurP < TempToiletCriticalPoints.Num(); ++_CurP)
								{
									FPointPair _CurPair;
									_CurPair.RoutinePoint = FVector(TempToiletCriticalPoints[_CurP], OtherHeight);
									_CurPair.WatchPoint = FVector(TempLocalCenter, OtherHeight);
									if (_CurP == 0)
									{
										_CurPair.ActionMarker = 1;
									}
									else
									{
										_CurPair.ActionMarker = 0;
									}
									TempPointPairs.Add(_CurPair);
								}

								if (TempPointPairs.Num() > 0)
								{
									FPathLine TempLine;
									TempLine.RoutinePoints = TempPointPairs;
									TempPointPairs.Empty();
									RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
								}
								HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
							}
						}
						else if ((TempName == TEXT("生活阳台")) || (TempName == TEXT("休闲阳台")))
						{
							TArray<FVector2D> TempCriticalPoints;
							FVector2D  LocalRegionCenter;
							bool IsGetted = LocateTwoCriticalPointsOfBalcony(WorldContextObject, RoomIDMapBoundary[AllRoomIDs[_CurRoom]], AllRoomIDs[_CurRoom],
								TempCriticalPoints, LocalRegionCenter);
							if (IsGetted)
							{
								for (int _CurP = 0; _CurP < TempCriticalPoints.Num(); ++_CurP)
								{
									FPointPair _CurPair;
									_CurPair.RoutinePoint = FVector(TempCriticalPoints[_CurP], OtherHeight);
									_CurPair.WatchPoint = FVector(LocalRegionCenter, OtherHeight);
									_CurPair.ActionMarker = 0;
									TempPointPairs.Add(_CurPair);
								}

								if (TempPointPairs.Num() > 0)
								{
									FPathLine TempLine;
									TempLine.RoutinePoints = TempPointPairs;
									TempPointPairs.Empty();
									RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
								}
								HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
							}
						}
						else if (TempName == TEXT("厨房"))
						{
							TArray<FVector2D> TempKitchenCriticalPoints;
							FVector2D  KitchenRegionCenter;
							bool IsLocated = LocateCriticalPointsOfKitchen(WorldContextObject,
								RoomIDMapBoundary[AllRoomIDs[_CurRoom]],
								AllRoomIDs[_CurRoom],
								TempKitchenCriticalPoints,
								KitchenRegionCenter);
							if (IsLocated)
							{
								for (int _CurP = 0; _CurP < TempKitchenCriticalPoints.Num(); ++_CurP)
								{
									FPointPair _CurPair;
									_CurPair.RoutinePoint = FVector(TempKitchenCriticalPoints[_CurP], OtherHeight);
									_CurPair.WatchPoint = FVector(KitchenRegionCenter, OtherHeight);
									if (_CurP == 0)
									{
										_CurPair.ActionMarker = 1;
									}
									else
									{
										_CurPair.ActionMarker = 0;
									}
									TempPointPairs.Add(_CurPair);
								}

								if (TempPointPairs.Num() > 0)
								{
									FPathLine TempLine;
									TempLine.RoutinePoints = TempPointPairs;
									TempPointPairs.Empty();
									RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
								}
								HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
							}
						}
						else if ((TempName == TEXT("衣帽间")) || (TempName == TEXT("储藏间")))
						{
							FVector2D TempCenter;
							bool IsLocateCenter = FPolygonAlg::LocateSuitableCenter(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], TempCenter);
							if (IsLocateCenter)
							{
								TArray<FVector> DoorPoints;
								bool GetDoors = GetDoorsOfRegion(WorldContextObject, AllRoomIDs[_CurRoom], DoorPoints);
								if (GetDoors)
								{
									int NumOfDoors = DoorPoints.Num() / 8;
									if (NumOfDoors >= 1)
									{
										FVector2D TempFinalNode;
										for (int _CurDoor = 0; _CurDoor < NumOfDoors; ++_CurDoor)
										{
											FVector2D TempDoorCenter = FVector2D(0.25*(DoorPoints[0 + 8 * _CurDoor] + DoorPoints[1 + 8 * _CurDoor] + DoorPoints[2 + 8 * _CurDoor] + DoorPoints[3 + 8 * _CurDoor]));
											FVector2D TempSide1 = FVector2D(DoorPoints[1 + 8 * _CurDoor] - DoorPoints[0 + 8 * _CurDoor]);
											FVector2D TempSide2 = FVector2D(DoorPoints[2 + 8 * _CurDoor] - DoorPoints[0 + 8 * _CurDoor]);
											float TempLength1 = TempSide1.Size();
											float TempLength2 = TempSide2.Size();
											TempSide1.Normalize();
											TempSide2.Normalize();
											FVector2D TempBaseDir;
											if (TempLength1 > TempLength2)
											{
												TempBaseDir = TempSide2;
											}
											else
											{
												TempBaseDir = TempSide1;
											}

											FVector2D TempNode1 = TempDoorCenter + 25 * TempBaseDir;
											FVector2D TempNode2 = TempDoorCenter - 25 * TempBaseDir;
											if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], TempNode1))
											{
												TempFinalNode = TempNode1;
												break;
											}
											if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], TempNode2))
											{
												TempFinalNode = TempNode2;
												break;
											}
										}

										FPointPair _CurPair1;
										_CurPair1.RoutinePoint = FVector(TempFinalNode, OtherHeight);
										_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
										_CurPair1.ActionMarker = 1;
										TempPointPairs.Add(_CurPair1);


										if (TempPointPairs.Num() > 0)
										{
											FPathLine TempLine;
											TempLine.RoutinePoints = TempPointPairs;
											TempPointPairs.Empty();
											RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
										}

										HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
									}
								}
								else
								{
									int CurrentEdge = 0, NextEdge = 0;
									for (int _CurEdge = 0; _CurEdge < RoomIDMapBoundary[AllRoomIDs[_CurRoom]].Num(); ++_CurEdge)
									{
										if (_CurEdge == RoomIDMapBoundary[AllRoomIDs[_CurRoom]].Num() - 1)
										{
											NextEdge = 0;
										}
										else
										{
											NextEdge = _CurEdge + 1;
										}
										FVector2D TempMiddleP = 0.5*(RoomIDMapBoundary[AllRoomIDs[_CurRoom]][_CurEdge] + RoomIDMapBoundary[AllRoomIDs[_CurRoom]][NextEdge]);
										FVector2D EdgeDir = RoomIDMapBoundary[AllRoomIDs[_CurRoom]][NextEdge] - RoomIDMapBoundary[AllRoomIDs[_CurRoom]][_CurEdge];
										EdgeDir.Normalize();
										FVector2D RotatedEdgeDir = EdgeDir.GetRotated(90);
										FVector2D TempExtendP1 = TempMiddleP + 5 * RotatedEdgeDir;
										FVector2D TempExtendP2 = TempMiddleP - 5 * RotatedEdgeDir;
										for (int IRoom = 0; IRoom < AllRoomIDs.Num(); ++IRoom)
										{
											if (AllRoomIDs[IRoom] != AllRoomIDs[_CurRoom])
											{
												if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[IRoom]], TempExtendP1))
												{
													FPointPair _CurPair1;
													_CurPair1.RoutinePoint = FVector(TempExtendP1 - 10 * RotatedEdgeDir, OtherHeight);
													_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
													_CurPair1.ActionMarker = 1;
													TempPointPairs.Add(_CurPair1);
													HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
													break;
												}

												if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[IRoom]], TempExtendP2))
												{
													FPointPair _CurPair1;
													_CurPair1.RoutinePoint = FVector(TempExtendP2 + 10 * RotatedEdgeDir, OtherHeight);
													_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
													_CurPair1.ActionMarker = 1;
													TempPointPairs.Add(_CurPair1);
													break;
												}
											}
										}
									}

									if (TempPointPairs.Num() > 0)
									{
										FPathLine TempLine;
										TempLine.RoutinePoints = TempPointPairs;
										TempPointPairs.Empty();
										RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
										HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
									}
								}

							}
						}
						else if (TempName == TEXT("客厅"))
						{
							TArray<FVector2D> PathPoints;
							FVector2D LocalWatchPoint;
							bool IsLocatedLiving = LocateCriticalPointsOfSpecialLivingOrDining(WorldContextObject, RoomIDMapBoundary[AllRoomIDs[_CurRoom]], AllRoomIDs[_CurRoom],
								PathPoints, LocalWatchPoint, true);
							if (IsLocatedLiving)
							{
								for (int _CurP = 0; _CurP < PathPoints.Num(); ++_CurP)
								{
									FPointPair _CurPair;
									_CurPair.RoutinePoint = FVector(PathPoints[_CurP], LivingOrDiningHeight);
									_CurPair.WatchPoint = FVector(LocalWatchPoint, LivingOrDiningHeight);
									if (PathPoints.Num() == 1)
									{
										_CurPair.ActionMarker = 1;
									}
									else
									{
										_CurPair.ActionMarker = 0;
									}
									TempPointPairs.Add(_CurPair);
								}
								if (TempPointPairs.Num() > 0)
								{
									FPathLine TempLine;
									TempLine.RoutinePoints = TempPointPairs;
									TempPointPairs.Empty();
									RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
								}
								HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
							}
						}
						else if ((TempName == TEXT("餐厅")))
						{
							TArray<FVector2D> PathPoints;
							FVector2D LocalWatchPoint;
							bool IsLocatedDining = LocateCriticalPointsOfSpecialLivingOrDining(WorldContextObject, RoomIDMapBoundary[AllRoomIDs[_CurRoom]], AllRoomIDs[_CurRoom],
								PathPoints, LocalWatchPoint, false);
							if (IsLocatedDining)
							{
								for (int _CurP = 0; _CurP < PathPoints.Num(); ++_CurP)
								{
									FPointPair _CurPair;
									_CurPair.RoutinePoint = FVector(PathPoints[_CurP], LivingOrDiningHeight);
									_CurPair.WatchPoint = FVector(LocalWatchPoint, LivingOrDiningHeight);
									if (PathPoints.Num() == 1)
									{
										_CurPair.ActionMarker = 1;
									}
									else
									{
										_CurPair.ActionMarker = 0;
									}
									TempPointPairs.Add(_CurPair);
								}
								if (TempPointPairs.Num() > 0)
								{
									FPathLine TempLine;
									TempLine.RoutinePoints = TempPointPairs;
									TempPointPairs.Empty();
									RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
								}
								HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
							}
						}
						else
						{
							FVector2D TempCenter;
							bool IsLocateCenter = FPolygonAlg::LocateSuitableCenter(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], TempCenter);
							if (IsLocateCenter)
							{
								TArray<FVector> DoorPoints;
								bool GetDoors = GetDoorsOfRegion(WorldContextObject, AllRoomIDs[_CurRoom], DoorPoints);
								if (GetDoors)
								{
									int NumOfDoors = DoorPoints.Num() / 8;
									if (NumOfDoors >= 1)
									{
										FVector2D TempDoorCenter = FVector2D(0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]));
										if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], TempDoorCenter))
										{
											FVector2D TempDir = TempCenter - TempDoorCenter;
											TempDir.Normalize();
											FVector2D TempNode1 = TempDoorCenter + 25 * TempDir;
											FVector2D TempNode2 = 0.5*(TempDoorCenter + TempCenter);
											FPointPair _CurPair1;
											_CurPair1.RoutinePoint = FVector(TempNode1, OtherHeight);
											_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
											_CurPair1.ActionMarker = 1;
											TempPointPairs.Add(_CurPair1);
											FPointPair _CurPair2;
											_CurPair2.RoutinePoint = FVector(TempNode2, OtherHeight);
											_CurPair2.WatchPoint = FVector(TempCenter, OtherHeight);
											_CurPair2.ActionMarker = 0;
											TempPointPairs.Add(_CurPair2);

											if (TempPointPairs.Num() > 0)
											{
												FPathLine TempLine;
												TempLine.RoutinePoints = TempPointPairs;
												TempPointPairs.Empty();
												RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
											}

											HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
										}

									}
									else
									{
										FPointPair _CurPair1;
										_CurPair1.RoutinePoint = FVector(TempCenter, OtherHeight);
										_CurPair1.WatchPoint = FVector(0.0, 0.0, OtherHeight);
										_CurPair1.ActionMarker = 1;
										TempPointPairs.Add(_CurPair1);

										if (TempPointPairs.Num() > 0)
										{
											FPathLine TempLine;
											TempLine.RoutinePoints = TempPointPairs;
											TempPointPairs.Empty();
											RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
										}

										HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
									}
								}
							}
						}
					}
				}
				if (NumOfIter >= MaxNumIter)
				{
					return false;
				}
			}
		}
	}
	else if ((IsStartRoom) && (!IsLivingRoom) && (!IsDiningRoom))
	{
		if (RoomIDMapName[GlobaleEntranceRoomID] == TEXT("起居室"))
		{
			////////////获取起居室的门洞数据//////////////////////
			TArray<FVector> LivingRoomDoors;
			bool GetLivingRoomDoor = false;
			if (IsLivingRoom)
			{
				GetLivingRoomDoor = GetDoorsOfRegion(WorldContextObject, LivingRoomID, LivingRoomDoors);
			}
			///////////定位入户门////////////////////////
			FVector2D EntranceDoorCenter;
			FVector2D EntranceDir;
			FVector StartPoint;
			bool FindEntrance = false;

			bool FirstIsLivingRoom = false;
			if (GetLivingRoomDoor)
			{
				int TargetRoomDoor = 0;
				int NumOfLivingRoomDoors = LivingRoomDoors.Num() / 8;
				for (int _CurDoor = 0; _CurDoor < NumOfLivingRoomDoors; ++_CurDoor)
				{
					FVector2D FindDir;
					FVector TempDoorCenter = 0.25*(LivingRoomDoors[8 * _CurDoor + 0] + LivingRoomDoors[8 * _CurDoor + 1] + LivingRoomDoors[8 * _CurDoor + 2] + LivingRoomDoors[8 * _CurDoor + 3]);
					FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter);
					FVector2D DoorDir = FVector2D(LivingRoomDoors[8 * _CurDoor + 1] - LivingRoomDoors[8 * _CurDoor]);
					DoorDir = DoorDir.GetSafeNormal();
					FVector2D DoorDirOfRotated = DoorDir.GetRotated(90);
					FVector2D ExtendP1 = TempDoorCenter2D + 35 * DoorDirOfRotated;
					FVector2D ExtendP2 = TempDoorCenter2D - 35 * DoorDirOfRotated;
					int CountTime = 0;
					for (int _CurRoom = 0; _CurRoom < AllRoomIDs.Num(); ++_CurRoom)
					{

						TArray<FVector2D> TempRegionPs = RoomIDMapBoundary[AllRoomIDs[_CurRoom]];
						bool P1IsInRegion = FPolygonAlg::JudgePointInPolygon(TempRegionPs, ExtendP1);
						bool P2IsInRegion = FPolygonAlg::JudgePointInPolygon(TempRegionPs, ExtendP2);

						if (P1IsInRegion)
						{
							CountTime++;
							FindDir = DoorDirOfRotated;
						}

						if (P2IsInRegion)
						{
							CountTime++;
							FindDir = -DoorDirOfRotated;
						}
					}

					if (CountTime == 1)
					{
						TargetRoomDoor = _CurDoor;
						FindEntrance = true;
						EntranceDoorCenter = TempDoorCenter2D;
						EntranceDir = FindDir;
						break;
					}
				}

				if (FindEntrance)
				{
					FVector2D TempTestP = EntranceDoorCenter + 30 * EntranceDir;
					FVector2D TempTestInterSectP1, TempTestInterSectP2;
					FPolygonAlg::CalculateRayToInterSectP(LivingRoomPs, TempTestP, EntranceDir, TempTestInterSectP1);
					FPolygonAlg::CalculateRayToInterSectP(LivingRoomPs, TempTestP, -EntranceDir, TempTestInterSectP2);
					float LengthOfSide1 = FVector2D::Distance(TempTestP, TempTestInterSectP1);
					float LengthOfSide2 = FVector2D::Distance(TempTestP, TempTestInterSectP2);
					float TotalLengthOfCase1 = LengthOfSide1 + LengthOfSide2;

					FVector2D TempRoV = EntranceDir.GetRotated(90);
					FVector2D TempTestInterSectP3, TempTestInterSectP4;
					FPolygonAlg::CalculateRayToInterSectP(LivingRoomPs, TempTestP, TempRoV, TempTestInterSectP3);
					FPolygonAlg::CalculateRayToInterSectP(LivingRoomPs, TempTestP, -TempRoV, TempTestInterSectP4);
					float LengthOfSide3 = FVector2D::Distance(TempTestP, TempTestInterSectP3);
					float LengthOfSide4 = FVector2D::Distance(TempTestP, TempTestInterSectP4);
					float TotalLengthOfCase2 = LengthOfSide3 + LengthOfSide4;

					if ((TotalLengthOfCase1 > TotalLengthOfCase2) || (abs(TotalLengthOfCase1 - TotalLengthOfCase2) <= 100))
					{
						StartPoint = FVector(EntranceDoorCenter + 50 * EntranceDir, LivingOrDiningHeight);
					}
					else
					{
						//////计算修正后的起始点////////////
						TArray<FVector2D> InterSectPsOfStartLine;
						bool IsDone = FPolygonAlg::CalculateRayInterSectWithPoly(EntranceDoorCenter, EntranceDir, LivingRoomPs, InterSectPsOfStartLine);
						if ((IsDone) && (InterSectPsOfStartLine.Num() == 2))
						{
							StartPoint = FVector(0.5*(InterSectPsOfStartLine[0] + InterSectPsOfStartLine[1]), LivingOrDiningHeight);
						}
						else
						{
							StartPoint = FVector(EntranceDoorCenter + 50 * EntranceDir, LivingOrDiningHeight);
						}

						if (LengthOfSide3 > LengthOfSide4)
						{
							EntranceDir = TempRoV;
						}
						else
						{
							EntranceDir = -TempRoV;
						}
					}
					FirstIsLivingRoom = true;
				}
			}

			TArray<int> HasCalculatedRoomIDs;

			TArray<FPointPair> TempPointPairs;
			bool NeedChangeDir = false;
			if (FirstIsLivingRoom)
			{
				/////////////////////计算起居室局部最大矩形/////////////////////
				TArray<FVector2D> MaxLocalOfLivingRoom;
				bool IsSuccess = FPolygonAlg::LocateMaxLocalRegionOfRoom(LivingRoomPs, MaxLocalOfLivingRoom);
				if (IsSuccess)
				{
					FVector2D CenterP(0.0, 0.0);
					for (int _CurI = 0; _CurI < MaxLocalOfLivingRoom.Num(); ++_CurI)
					{
						CenterP = CenterP + MaxLocalOfLivingRoom[_CurI];
					}
					CenterP = CenterP / MaxLocalOfLivingRoom.Num();
					TArray<FVector2D> CriticalPointsOfLivingRoom;


					if (!FPolygonAlg::JudgePointInPolygon(MaxLocalOfLivingRoom, FVector2D(StartPoint)))
					{
						NeedChangeDir = true;
						TArray<FVector2D> InterSectPs;
						FVector2D TargetInterSectP, MiddleP;
						bool IsInterSected = FPolygonAlg::CalculateRayInterSectWithPoly(FVector2D(StartPoint), EntranceDir, MaxLocalOfLivingRoom, InterSectPs);
						if (IsInterSected)
						{
							float TempMinDis = 0.0f;
							float TempX = 0.0f, TempY = 0.0f;
							for (int _CurI = 0; _CurI < InterSectPs.Num(); ++_CurI)
							{
								float TempDisL = FVector2D::Distance(FVector2D(StartPoint), InterSectPs[_CurI]);
								if ((TempMinDis <= 1.0*10E-5) || (TempMinDis >= TempDisL))
								{
									TempMinDis = TempDisL;
									TargetInterSectP = InterSectPs[_CurI];
								}
								TempX = TempX + InterSectPs[_CurI].X;
								TempY = TempY + InterSectPs[_CurI].Y;
							}
							TempX = TempX / InterSectPs.Num();
							TempY = TempY / InterSectPs.Num();
							MiddleP = FVector2D(TempX, TempY);
						}
						CriticalPointsOfLivingRoom.Add(FVector2D(StartPoint));
						CriticalPointsOfLivingRoom.Add(TargetInterSectP);
						CriticalPointsOfLivingRoom.Add(MiddleP);
					}
					else
					{
						for (int _CurJ = 0; _CurJ < MaxLocalOfLivingRoom.Num(); ++_CurJ)
						{
							CriticalPointsOfLivingRoom.Add(0.25*CenterP + 0.75*MaxLocalOfLivingRoom[_CurJ]);
						}

					}

					for (int _CurP = 0; _CurP < CriticalPointsOfLivingRoom.Num(); ++_CurP)
					{
						FPointPair _CurPair;
						_CurPair.RoutinePoint = FVector(CriticalPointsOfLivingRoom[_CurP], LivingOrDiningHeight);
						_CurPair.WatchPoint = FVector(CenterP, LivingOrDiningHeight);
						if (_CurP == CriticalPointsOfLivingRoom.Num() - 1)
						{
							_CurPair.ActionMarker = 1;
						}
						else
						{
							_CurPair.ActionMarker = 0;
						}

						TempPointPairs.Add(_CurPair);
					}
					if (TempPointPairs.Num() > 0)
					{
						FPathLine TempLine;
						TempLine.RoutinePoints = TempPointPairs;
						TempPointPairs.Empty();
						RoomIDMapPathLine.Add(LivingRoomID, TempLine);
					}
					HasCalculatedRoomIDs.AddUnique(LivingRoomID);
				}
			}
		}
		else
		{
			FString EntranceRoomName = RoomIDMapName[GlobaleEntranceRoomID];
			TArray<int> HasCalculatedRoomIDs;
			TArray<FPointPair> TempPointPairs;
			if (EntranceRoomName == TEXT("厨房"))
			{
				TArray<FVector2D> TempKitchenCriticalPoints;
				FVector2D  KitchenRegionCenter;
				bool IsLocated = LocateCriticalPointsOfKitchen(WorldContextObject,
					RoomIDMapBoundary[GlobaleEntranceRoomID],
					GlobaleEntranceRoomID,
					TempKitchenCriticalPoints,
					KitchenRegionCenter);
				if (IsLocated)
				{
					for (int _CurP = 0; _CurP < TempKitchenCriticalPoints.Num(); ++_CurP)
					{
						FPointPair _CurPair;
						_CurPair.RoutinePoint = FVector(TempKitchenCriticalPoints[_CurP], OtherHeight);
						_CurPair.WatchPoint = FVector(KitchenRegionCenter, OtherHeight);
						if (_CurP == 0)
						{
							_CurPair.ActionMarker = 1;
						}
						else
						{
							_CurPair.ActionMarker = 0;
						}
						TempPointPairs.Add(_CurPair);
					}

					if (TempPointPairs.Num() > 0)
					{
						FPathLine TempLine;
						TempLine.RoutinePoints = TempPointPairs;
						TempPointPairs.Empty();
						RoomIDMapPathLine.Add(GlobaleEntranceRoomID, TempLine);
					}
					HasCalculatedRoomIDs.AddUnique(GlobaleEntranceRoomID);
				}
			}
			else if ((EntranceRoomName == TEXT("主卫")) || (EntranceRoomName == TEXT("客卫")))
			{
				TArray<FVector2D> TempToiletCriticalPoints;
				FVector2D TempLocalCenter;
				bool LocateToiletSuccess = LocateCriticalPointsOfToilet(WorldContextObject,
					RoomIDMapBoundary[GlobaleEntranceRoomID],
					AllWallCenters,
					GlobaleEntranceRoomID,
					TempToiletCriticalPoints,
					TempLocalCenter);
				if (LocateToiletSuccess)
				{
					for (int _CurP = 0; _CurP < TempToiletCriticalPoints.Num(); ++_CurP)
					{
						FPointPair _CurPair;
						_CurPair.RoutinePoint = FVector(TempToiletCriticalPoints[_CurP], OtherHeight);
						_CurPair.WatchPoint = FVector(TempLocalCenter, OtherHeight);
						if (_CurP == 0)
						{
							_CurPair.ActionMarker = 1;
						}
						else
						{
							_CurPair.ActionMarker = 0;
						}
						TempPointPairs.Add(_CurPair);
					}

					if (TempPointPairs.Num() > 0)
					{
						FPathLine TempLine;
						TempLine.RoutinePoints = TempPointPairs;
						TempPointPairs.Empty();
						RoomIDMapPathLine.Add(GlobaleEntranceRoomID, TempLine);
					}
					HasCalculatedRoomIDs.AddUnique(GlobaleEntranceRoomID);
				}
			}
			else if ((EntranceRoomName == TEXT("衣帽间")) || (EntranceRoomName == TEXT("储藏间")))
			{
				FVector2D TempCenter;
				bool IsLocateCenter = FPolygonAlg::LocateSuitableCenter(RoomIDMapBoundary[GlobaleEntranceRoomID], TempCenter);
				if (IsLocateCenter)
				{
					TArray<FVector> DoorPoints;
					bool GetDoors = GetDoorsOfRegion(WorldContextObject, GlobaleEntranceRoomID, DoorPoints);
					if (GetDoors)
					{
						int NumOfDoors = DoorPoints.Num() / 8;
						if (NumOfDoors >= 1)
						{
							FVector2D TempFinalNode;
							for (int _CurDoor = 0; _CurDoor < NumOfDoors; ++_CurDoor)
							{
								FVector2D TempDoorCenter = FVector2D(0.25*(DoorPoints[0 + 8 * _CurDoor] + DoorPoints[1 + 8 * _CurDoor] + DoorPoints[2 + 8 * _CurDoor] + DoorPoints[3 + 8 * _CurDoor]));
								FVector2D TempSide1 = FVector2D(DoorPoints[1 + 8 * _CurDoor] - DoorPoints[0 + 8 * _CurDoor]);
								FVector2D TempSide2 = FVector2D(DoorPoints[2 + 8 * _CurDoor] - DoorPoints[0 + 8 * _CurDoor]);
								float TempLength1 = TempSide1.Size();
								float TempLength2 = TempSide2.Size();
								TempSide1.Normalize();
								TempSide2.Normalize();
								FVector2D TempBaseDir;
								if (TempLength1 > TempLength2)
								{
									TempBaseDir = TempSide2;
								}
								else
								{
									TempBaseDir = TempSide1;
								}

								FVector2D TempNode1 = TempDoorCenter + 25 * TempBaseDir;
								FVector2D TempNode2 = TempDoorCenter - 25 * TempBaseDir;
								if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[GlobaleEntranceRoomID], TempNode1))
								{
									TempFinalNode = TempNode1;
									break;
								}
								if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[GlobaleEntranceRoomID], TempNode2))
								{
									TempFinalNode = TempNode2;
									break;
								}
							}

							FPointPair _CurPair1;
							_CurPair1.RoutinePoint = FVector(TempFinalNode, OtherHeight);
							_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
							_CurPair1.ActionMarker = 1;
							TempPointPairs.Add(_CurPair1);


							if (TempPointPairs.Num() > 0)
							{
								FPathLine TempLine;
								TempLine.RoutinePoints = TempPointPairs;
								TempPointPairs.Empty();
								RoomIDMapPathLine.Add(GlobaleEntranceRoomID, TempLine);
							}

							HasCalculatedRoomIDs.AddUnique(GlobaleEntranceRoomID);
						}
					}
					else
					{
						int CurrentEdge = 0, NextEdge = 0;
						for (int _CurEdge = 0; _CurEdge < RoomIDMapBoundary[GlobaleEntranceRoomID].Num(); ++_CurEdge)
						{
							if (_CurEdge == RoomIDMapBoundary[GlobaleEntranceRoomID].Num() - 1)
							{
								NextEdge = 0;
							}
							else
							{
								NextEdge = _CurEdge + 1;
							}
							FVector2D TempMiddleP = 0.5*(RoomIDMapBoundary[GlobaleEntranceRoomID][_CurEdge] + RoomIDMapBoundary[GlobaleEntranceRoomID][NextEdge]);
							FVector2D EdgeDir = RoomIDMapBoundary[GlobaleEntranceRoomID][NextEdge] - RoomIDMapBoundary[GlobaleEntranceRoomID][_CurEdge];
							EdgeDir.Normalize();
							FVector2D RotatedEdgeDir = EdgeDir.GetRotated(90);
							FVector2D TempExtendP1 = TempMiddleP + 5 * RotatedEdgeDir;
							FVector2D TempExtendP2 = TempMiddleP - 5 * RotatedEdgeDir;
							for (int IRoom = 0; IRoom < AllRoomIDs.Num(); ++IRoom)
							{
								if (AllRoomIDs[IRoom] != GlobaleEntranceRoomID)
								{
									if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[IRoom]], TempExtendP1))
									{
										FPointPair _CurPair1;
										_CurPair1.RoutinePoint = FVector(TempExtendP1 - 10 * RotatedEdgeDir, OtherHeight);
										_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
										_CurPair1.ActionMarker = 1;
										TempPointPairs.Add(_CurPair1);
										HasCalculatedRoomIDs.AddUnique(GlobaleEntranceRoomID);
										break;
									}

									if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[IRoom]], TempExtendP2))
									{
										FPointPair _CurPair1;
										_CurPair1.RoutinePoint = FVector(TempExtendP2 + 10 * RotatedEdgeDir, OtherHeight);
										_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
										_CurPair1.ActionMarker = 1;
										TempPointPairs.Add(_CurPair1);
										HasCalculatedRoomIDs.AddUnique(GlobaleEntranceRoomID);
										break;
									}
								}
							}
						}

						if (TempPointPairs.Num() > 0)
						{
							FPathLine TempLine;
							TempLine.RoutinePoints = TempPointPairs;
							TempPointPairs.Empty();
							RoomIDMapPathLine.Add(GlobaleEntranceRoomID, TempLine);
						}
					}
				}
			}
			else if ((EntranceRoomName == TEXT("主卧")) || (EntranceRoomName == TEXT("次卧")) || (EntranceRoomName == TEXT("老人房")) || (EntranceRoomName == TEXT("书房")) || (EntranceRoomName == TEXT("多功能房"))
				|| (EntranceRoomName == TEXT("儿童房")) || (EntranceRoomName == TEXT("榻榻米房")))
			{
				TArray<FVector2D> TempRoomCriticalPoints, MaxLocalRegion;
				bool IsSuccess = FPolygonAlg::LocateMaxLocalRegionOfRoom(RoomIDMapBoundary[GlobaleEntranceRoomID], MaxLocalRegion);
				if (IsSuccess)
				{
					FVector2D TempCenterP(0.0, 0.0);
					for (int _CurJ = 0; _CurJ < MaxLocalRegion.Num(); ++_CurJ)
					{
						TempCenterP = TempCenterP + MaxLocalRegion[_CurJ];
					}

					TempCenterP = TempCenterP / MaxLocalRegion.Num();
					FVector2D TempNode1 = 0.5*(GlobaleEntranceDoorCenter + TempCenterP);
					if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[GlobaleEntranceRoomID], TempNode1))
					{
						TempRoomCriticalPoints.AddUnique(TempNode1);
					}
					TempRoomCriticalPoints.AddUnique(TempCenterP);

					for (int _CurP = 0; _CurP < TempRoomCriticalPoints.Num(); ++_CurP)
					{
						FPointPair _CurPair;
						_CurPair.RoutinePoint = FVector(TempRoomCriticalPoints[_CurP], OtherHeight);
						_CurPair.WatchPoint = FVector(TempCenterP, OtherHeight);
						if (TempRoomCriticalPoints.Num() == 1)
						{
							_CurPair.ActionMarker = 1;
						}
						else
						{
							_CurPair.ActionMarker = 0;
						}
						TempPointPairs.Add(_CurPair);
					}
					if (TempPointPairs.Num() > 0)
					{
						FPathLine TempLine;
						TempLine.RoutinePoints = TempPointPairs;
						TempPointPairs.Empty();
						RoomIDMapPathLine.Add(GlobaleEntranceRoomID, TempLine);
					}
					HasCalculatedRoomIDs.AddUnique(GlobaleEntranceRoomID);
				}
			}
		}

		/////////////////////计算剩余空间//////////////////////
		int NumOfIter = 0;
		while (AllRoomIDs.Num() != HasCalculatedRoomIDs.Num())
		{
			NumOfIter++;
			for (int _CurRoom = 0; _CurRoom < AllRoomIDs.Num(); ++_CurRoom)
			{
				if (!HasCalculatedRoomIDs.Contains(AllRoomIDs[_CurRoom]))
				{
					FString TempName = RoomIDMapName[AllRoomIDs[_CurRoom]];
					if ((TempName == TEXT("主卧")) || (TempName == TEXT("次卧")) || (TempName == TEXT("儿童房")) || (TempName == TEXT("老人房")) ||
						(TempName == TEXT("榻榻米房")) || (TempName == TEXT("多功能房")) || (TempName == TEXT("书房"))
						|| (TempName == TEXT("客人房")) || (TempName == TEXT("健身房")))
					{
						TArray<FVector2D> TempRoomCriticalPoints, MaxLocalRegion;
						FVector2D TempWatchNode;
						bool PointInModel = false;
						bool IsSuccess = FPolygonAlg::LocateMaxLocalRegionOfRoom(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], MaxLocalRegion);
						if (IsSuccess)
						{
							FVector2D TempCenterP(0.0, 0.0);
							for (int _CurJ = 0; _CurJ < MaxLocalRegion.Num(); ++_CurJ)
							{
								TempCenterP = TempCenterP + MaxLocalRegion[_CurJ];
							}
							TempCenterP = TempCenterP / MaxLocalRegion.Num();
							TArray<FVector2D> ShrinkPoints;
							for (int IP = 0; IP < MaxLocalRegion.Num(); ++IP)
							{
								ShrinkPoints.Add(ShrinkRatio*MaxLocalRegion[IP] + (1 - ShrinkRatio)*TempCenterP);
							}
							FVector2D Node1 = 0.5*(ShrinkPoints[0] + ShrinkPoints[1]);
							FVector2D Node2 = 0.5*(ShrinkPoints[1] + ShrinkPoints[2]);
							FVector2D Node3 = 0.5*(ShrinkPoints[2] + ShrinkPoints[3]);
							FVector2D Node4 = 0.5*(ShrinkPoints[3] + ShrinkPoints[0]);

							TArray<AFurnitureModelActor*> ModelsOfRoom;
							FindModelsOfRoom(WorldContextObject, RoomIDMapBoundary[AllRoomIDs[_CurRoom]], ModelsOfRoom);
							AFurnitureModelActor* FindFur = nullptr;
							bool FindModel = false;
							for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
							{
								AFurnitureModelActor* TempFur = ModelsOfRoom[_CurM];
								int TempID = 0;
								TempFur->GetModelCategory(TempID);
								if ((TempID == 5009) || (TempID == 5010) || (TempID == 5125))
								{
									FindFur = TempFur;
									FindModel = true;
									break;
								}
							}



							TArray<AHouseCustomActor*> CustomModelsOfRoom;
							FindCustomModelsOfRoom(WorldContextObject, RoomIDMapBoundary[AllRoomIDs[_CurRoom]], CustomModelsOfRoom);


							if (FindModel)
							{
								FBox TempBox = FindFur->GetComponentsBoundingBox(true);
								FVector FMin = TempBox.Min;
								FVector FMax = TempBox.Max;
								FVector2D P1(FMin.X, FMin.Y);
								FVector2D P2(FMax.X, FMin.Y);
								FVector2D P3(FMax.X, FMax.Y);
								FVector2D P4(FMin.X, FMax.Y);
								FVector2D BoxCenter = 0.25*(P1 + P2 + P3 + P4);
								TempWatchNode = BoxCenter;
								float Dis1 = FVector2D::Distance(Node1, BoxCenter);
								float Dis2 = FVector2D::Distance(Node2, BoxCenter);
								float Dis3 = FVector2D::Distance(Node3, BoxCenter);
								float Dis4 = FVector2D::Distance(Node4, BoxCenter);
								FVector2D BaseNode = Node1;
								if ((Dis2 >= Dis1) && (Dis2 >= Dis3) && (Dis2 >= Dis4))
								{
									BaseNode = Node2;
								}
								else if ((Dis3 >= Dis1) && (Dis3 >= Dis2) && (Dis3 >= Dis4))
								{
									BaseNode = Node3;
								}
								else if ((Dis4 >= Dis1) && (Dis4 >= Dis2) && (Dis4 >= Dis3))
								{
									BaseNode = Node4;
								}

								for (int _CurM = 0; _CurM < CustomModelsOfRoom.Num(); ++_CurM)
								{
									FBox TempBox = CustomModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
									FString ModelName = CustomModelsOfRoom[_CurM]->GetName();
									if (!ModelName.Contains(FString("Light")))
									{
										bool IfInModel = TempBox.IsInsideOrOn(FVector(BaseNode, OtherHeight));
										if (IfInModel)
										{
											FVector FMin = TempBox.Min;
											FVector FMax = TempBox.Max;
											float TempModelZ = FMax.Z - FMin.Z;
											if (TempModelZ >= HeightBound)
											{
												bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, RoomIDMapBoundary[AllRoomIDs[_CurRoom]]);
												if (ModelBoxIsUseful)
												{
													PointInModel = true;
													break;
												}
											}
										}
									}
								}

								for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
								{
									FBox TempBox = ModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
									FString ModelName = ModelsOfRoom[_CurM]->GetName();
									if (!ModelName.Contains(FString("Light")))
									{
										bool IfInModel = TempBox.IsInsideOrOn(FVector(BaseNode, OtherHeight));
										if (IfInModel)
										{
											FVector FMin = TempBox.Min;
											FVector FMax = TempBox.Max;
											float TempModelZ = FMax.Z - FMin.Z;
											if (TempModelZ >= HeightBound)
											{
												bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, RoomIDMapBoundary[AllRoomIDs[_CurRoom]]);
												if (ModelBoxIsUseful)
												{
													PointInModel = true;
													break;
												}
											}
										}
									}
								}
								if (!PointInModel)
								{
									TempRoomCriticalPoints.Add(BaseNode);
									TempRoomCriticalPoints.Add(0.8*BoxCenter + 0.2*BaseNode);
								}
							}
						}

						if (TempRoomCriticalPoints.Num() == 0)
						{
							FVector2D LocalCenterNode;
							FPolygonAlg::LocateSuitableCenter(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], LocalCenterNode);
							TempRoomCriticalPoints.AddUnique(LocalCenterNode);
							TempWatchNode = FVector2D(0.0, 0.0);
						}


						for (int _CurP = 0; _CurP < TempRoomCriticalPoints.Num(); ++_CurP)
						{
							FPointPair _CurPair;
							_CurPair.RoutinePoint = FVector(TempRoomCriticalPoints[_CurP], OtherHeight);
							_CurPair.WatchPoint = FVector(TempWatchNode, OtherHeight);
							if (TempRoomCriticalPoints.Num() == 1)
							{
								_CurPair.ActionMarker = 1;
							}
							else
							{
								_CurPair.ActionMarker = 0;
							}
							TempPointPairs.Add(_CurPair);
						}
						if (TempPointPairs.Num() > 0)
						{
							FPathLine TempLine;
							TempLine.RoutinePoints = TempPointPairs;
							TempPointPairs.Empty();
							RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
						}
						HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
					}
					else if ((TempName == TEXT("主卫")) || (TempName == TEXT("客卫")) || (TempName == TEXT("卫生间")))
					{
						TArray<FVector2D> TempToiletCriticalPoints;
						FVector2D TempLocalCenter;
						bool LocateToiletSuccess = LocateCriticalPointsOfToilet(WorldContextObject,
							RoomIDMapBoundary[AllRoomIDs[_CurRoom]],
							AllWallCenters,
							AllRoomIDs[_CurRoom],
							TempToiletCriticalPoints,
							TempLocalCenter);
						if (LocateToiletSuccess)
						{
							for (int _CurP = 0; _CurP < TempToiletCriticalPoints.Num(); ++_CurP)
							{
								FPointPair _CurPair;
								_CurPair.RoutinePoint = FVector(TempToiletCriticalPoints[_CurP], OtherHeight);
								_CurPair.WatchPoint = FVector(TempLocalCenter, OtherHeight);
								if (_CurP == 0)
								{
									_CurPair.ActionMarker = 1;
								}
								else
								{
									_CurPair.ActionMarker = 0;
								}
								TempPointPairs.Add(_CurPair);
							}

							if (TempPointPairs.Num() > 0)
							{
								FPathLine TempLine;
								TempLine.RoutinePoints = TempPointPairs;
								TempPointPairs.Empty();
								RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
							}
							HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
						}
					}
					else if ((TempName == TEXT("生活阳台")) || (TempName == TEXT("休闲阳台")))
					{
						TArray<FVector2D> TempCriticalPoints;
						FVector2D  LocalRegionCenter;
						bool IsGetted = LocateTwoCriticalPointsOfBalcony(WorldContextObject, RoomIDMapBoundary[AllRoomIDs[_CurRoom]], AllRoomIDs[_CurRoom],
							TempCriticalPoints, LocalRegionCenter);
						if (IsGetted)
						{
							for (int _CurP = 0; _CurP < TempCriticalPoints.Num(); ++_CurP)
							{
								FPointPair _CurPair;
								_CurPair.RoutinePoint = FVector(TempCriticalPoints[_CurP], OtherHeight);
								_CurPair.WatchPoint = FVector(LocalRegionCenter, OtherHeight);
								_CurPair.ActionMarker = 0;
								TempPointPairs.Add(_CurPair);
							}

							if (TempPointPairs.Num() > 0)
							{
								FPathLine TempLine;
								TempLine.RoutinePoints = TempPointPairs;
								TempPointPairs.Empty();
								RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
							}
							HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
						}
					}
					else if (TempName == TEXT("厨房"))
					{
						TArray<FVector2D> TempKitchenCriticalPoints;
						FVector2D  KitchenRegionCenter;
						bool IsLocated = LocateCriticalPointsOfKitchen(WorldContextObject,
							RoomIDMapBoundary[AllRoomIDs[_CurRoom]],
							AllRoomIDs[_CurRoom],
							TempKitchenCriticalPoints,
							KitchenRegionCenter);
						if (IsLocated)
						{
							for (int _CurP = 0; _CurP < TempKitchenCriticalPoints.Num(); ++_CurP)
							{
								FPointPair _CurPair;
								_CurPair.RoutinePoint = FVector(TempKitchenCriticalPoints[_CurP], OtherHeight);
								_CurPair.WatchPoint = FVector(KitchenRegionCenter, OtherHeight);
								if (_CurP == 0)
								{
									_CurPair.ActionMarker = 1;
								}
								else
								{
									_CurPair.ActionMarker = 0;
								}
								TempPointPairs.Add(_CurPair);
							}

							if (TempPointPairs.Num() > 0)
							{
								FPathLine TempLine;
								TempLine.RoutinePoints = TempPointPairs;
								TempPointPairs.Empty();
								RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
							}
							HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
						}
					}
					else if ((TempName == TEXT("衣帽间")) || (TempName == TEXT("储藏间")))
					{
						FVector2D TempCenter;
						bool IsLocateCenter = FPolygonAlg::LocateSuitableCenter(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], TempCenter);
						if (IsLocateCenter)
						{
							TArray<FVector> DoorPoints;
							bool GetDoors = GetDoorsOfRegion(WorldContextObject, AllRoomIDs[_CurRoom], DoorPoints);
							if (GetDoors)
							{
								int NumOfDoors = DoorPoints.Num() / 8;
								if (NumOfDoors >= 1)
								{
									FVector2D TempFinalNode;
									for (int _CurDoor = 0; _CurDoor < NumOfDoors; ++_CurDoor)
									{
										FVector2D TempDoorCenter = FVector2D(0.25*(DoorPoints[0 + 8 * _CurDoor] + DoorPoints[1 + 8 * _CurDoor] + DoorPoints[2 + 8 * _CurDoor] + DoorPoints[3 + 8 * _CurDoor]));
										FVector2D TempSide1 = FVector2D(DoorPoints[1 + 8 * _CurDoor] - DoorPoints[0 + 8 * _CurDoor]);
										FVector2D TempSide2 = FVector2D(DoorPoints[2 + 8 * _CurDoor] - DoorPoints[0 + 8 * _CurDoor]);
										float TempLength1 = TempSide1.Size();
										float TempLength2 = TempSide2.Size();
										TempSide1.Normalize();
										TempSide2.Normalize();
										FVector2D TempBaseDir;
										if (TempLength1 > TempLength2)
										{
											TempBaseDir = TempSide2;
										}
										else
										{
											TempBaseDir = TempSide1;
										}

										FVector2D TempNode1 = TempDoorCenter + 25 * TempBaseDir;
										FVector2D TempNode2 = TempDoorCenter - 25 * TempBaseDir;
										if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], TempNode1))
										{
											TempFinalNode = TempNode1;
											break;
										}
										if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], TempNode2))
										{
											TempFinalNode = TempNode2;
											break;
										}
									}

									FPointPair _CurPair1;
									_CurPair1.RoutinePoint = FVector(TempFinalNode, OtherHeight);
									_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
									_CurPair1.ActionMarker = 1;
									TempPointPairs.Add(_CurPair1);


									if (TempPointPairs.Num() > 0)
									{
										FPathLine TempLine;
										TempLine.RoutinePoints = TempPointPairs;
										TempPointPairs.Empty();
										RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
									}

									HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
								}
							}
							else
							{
								int CurrentEdge = 0, NextEdge = 0;
								for (int _CurEdge = 0; _CurEdge < RoomIDMapBoundary[AllRoomIDs[_CurRoom]].Num(); ++_CurEdge)
								{
									if (_CurEdge == RoomIDMapBoundary[AllRoomIDs[_CurRoom]].Num() - 1)
									{
										NextEdge = 0;
									}
									else
									{
										NextEdge = _CurEdge + 1;
									}
									FVector2D TempMiddleP = 0.5*(RoomIDMapBoundary[AllRoomIDs[_CurRoom]][_CurEdge] + RoomIDMapBoundary[AllRoomIDs[_CurRoom]][NextEdge]);
									FVector2D EdgeDir = RoomIDMapBoundary[AllRoomIDs[_CurRoom]][NextEdge] - RoomIDMapBoundary[AllRoomIDs[_CurRoom]][_CurEdge];
									EdgeDir.Normalize();
									FVector2D RotatedEdgeDir = EdgeDir.GetRotated(90);
									FVector2D TempExtendP1 = TempMiddleP + 5 * RotatedEdgeDir;
									FVector2D TempExtendP2 = TempMiddleP - 5 * RotatedEdgeDir;
									for (int IRoom = 0; IRoom < AllRoomIDs.Num(); ++IRoom)
									{
										if (AllRoomIDs[IRoom] != AllRoomIDs[_CurRoom])
										{
											if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[IRoom]], TempExtendP1))
											{
												FPointPair _CurPair1;
												_CurPair1.RoutinePoint = FVector(TempExtendP1 - 10 * RotatedEdgeDir, OtherHeight);
												_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
												_CurPair1.ActionMarker = 1;
												TempPointPairs.Add(_CurPair1);
												HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
												break;
											}

											if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[IRoom]], TempExtendP2))
											{
												FPointPair _CurPair1;
												_CurPair1.RoutinePoint = FVector(TempExtendP2 + 10 * RotatedEdgeDir, OtherHeight);
												_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
												_CurPair1.ActionMarker = 1;
												TempPointPairs.Add(_CurPair1);


												HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
												break;
											}
										}
									}
								}

								if (TempPointPairs.Num() > 0)
								{
									FPathLine TempLine;
									TempLine.RoutinePoints = TempPointPairs;
									TempPointPairs.Empty();
									RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
								}
							}

						}
					}
					else if (TempName == TEXT("客厅"))
					{
						TArray<FVector2D> PathPoints;
						FVector2D LocalWatchPoint;
						bool IsLocatedLiving = LocateCriticalPointsOfSpecialLivingOrDining(WorldContextObject, RoomIDMapBoundary[AllRoomIDs[_CurRoom]], AllRoomIDs[_CurRoom],
							PathPoints, LocalWatchPoint, true);
						if (IsLocatedLiving)
						{
							for (int _CurP = 0; _CurP < PathPoints.Num(); ++_CurP)
							{
								FPointPair _CurPair;
								_CurPair.RoutinePoint = FVector(PathPoints[_CurP], LivingOrDiningHeight);
								_CurPair.WatchPoint = FVector(LocalWatchPoint, LivingOrDiningHeight);
								if (PathPoints.Num() == 1)
								{
									_CurPair.ActionMarker = 1;
								}
								else
								{
									_CurPair.ActionMarker = 0;
								}
								TempPointPairs.Add(_CurPair);
							}
							if (TempPointPairs.Num() > 0)
							{
								FPathLine TempLine;
								TempLine.RoutinePoints = TempPointPairs;
								TempPointPairs.Empty();
								RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
							}
							HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
						}
					}
					else
					{
						FVector2D TempCenter;
						bool IsLocateCenter = FPolygonAlg::LocateSuitableCenter(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], TempCenter);
						if (IsLocateCenter)
						{
							TArray<FVector> DoorPoints;
							bool GetDoors = GetDoorsOfRegion(WorldContextObject, AllRoomIDs[_CurRoom], DoorPoints);
							if (GetDoors)
							{
								int NumOfDoors = DoorPoints.Num() / 8;
								if (NumOfDoors >= 1)
								{
									FVector2D TempDoorCenter = FVector2D(0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]));
									if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], TempDoorCenter))
									{
										FVector2D TempDir = TempCenter - TempDoorCenter;
										TempDir.Normalize();
										FVector2D TempNode1 = TempDoorCenter + 25 * TempDir;
										FVector2D TempNode2 = 0.5*(TempDoorCenter + TempCenter);
										FPointPair _CurPair1;
										_CurPair1.RoutinePoint = FVector(TempNode1, OtherHeight);
										_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
										_CurPair1.ActionMarker = 1;
										TempPointPairs.Add(_CurPair1);
										FPointPair _CurPair2;
										_CurPair2.RoutinePoint = FVector(TempNode2, OtherHeight);
										_CurPair2.WatchPoint = FVector(TempCenter, OtherHeight);
										_CurPair2.ActionMarker = 0;
										TempPointPairs.Add(_CurPair2);

										if (TempPointPairs.Num() > 0)
										{
											FPathLine TempLine;
											TempLine.RoutinePoints = TempPointPairs;
											TempPointPairs.Empty();
											RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
										}

										HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
									}

								}
								else
								{
									FPointPair _CurPair1;
									_CurPair1.RoutinePoint = FVector(TempCenter, OtherHeight);
									_CurPair1.WatchPoint = FVector(0.0, 0.0, OtherHeight);
									_CurPair1.ActionMarker = 1;
									TempPointPairs.Add(_CurPair1);

									if (TempPointPairs.Num() > 0)
									{
										FPathLine TempLine;
										TempLine.RoutinePoints = TempPointPairs;
										TempPointPairs.Empty();
										RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
									}

									HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
								}
							}
						}
					}
				}
			}
			if (NumOfIter >= MaxNumIter)
			{
				return false;
			}
		}
	}
	else if ((IsLivingRoom) && (!IsDiningRoom) && (!IsStartRoom))
	{
		if (RoomIDMapName[GlobaleEntranceRoomID] == TEXT("客厅"))
		{
			////////////获取起居室的门洞数据//////////////////////
			TArray<FVector> LivingRoomDoors;
			bool GetLivingRoomDoor = false;
			if (IsLivingRoom)
			{
				GetLivingRoomDoor = GetDoorsOfRegion(WorldContextObject, LivingRoomID, LivingRoomDoors);
			}
			///////////定位入户门////////////////////////
			FVector2D EntranceDoorCenter;
			FVector2D EntranceDir;
			FVector StartPoint;
			bool FindEntrance = false;

			bool FirstIsLivingRoom = false;
			if (GetLivingRoomDoor)
			{
				int TargetRoomDoor = 0;
				int NumOfLivingRoomDoors = LivingRoomDoors.Num() / 8;
				for (int _CurDoor = 0; _CurDoor < NumOfLivingRoomDoors; ++_CurDoor)
				{
					FVector2D FindDir;
					FVector TempDoorCenter = 0.25*(LivingRoomDoors[8 * _CurDoor + 0] + LivingRoomDoors[8 * _CurDoor + 1] + LivingRoomDoors[8 * _CurDoor + 2] + LivingRoomDoors[8 * _CurDoor + 3]);
					FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter);
					FVector2D DoorDir = FVector2D(LivingRoomDoors[8 * _CurDoor + 1] - LivingRoomDoors[8 * _CurDoor]);
					DoorDir = DoorDir.GetSafeNormal();
					FVector2D DoorDirOfRotated = DoorDir.GetRotated(90);
					FVector2D ExtendP1 = TempDoorCenter2D + 35 * DoorDirOfRotated;
					FVector2D ExtendP2 = TempDoorCenter2D - 35 * DoorDirOfRotated;
					int CountTime = 0;
					for (int _CurRoom = 0; _CurRoom < AllRoomIDs.Num(); ++_CurRoom)
					{

						TArray<FVector2D> TempRegionPs = RoomIDMapBoundary[AllRoomIDs[_CurRoom]];
						bool P1IsInRegion = FPolygonAlg::JudgePointInPolygon(TempRegionPs, ExtendP1);
						bool P2IsInRegion = FPolygonAlg::JudgePointInPolygon(TempRegionPs, ExtendP2);

						if (P1IsInRegion)
						{
							CountTime++;
							FindDir = DoorDirOfRotated;
						}

						if (P2IsInRegion)
						{
							CountTime++;
							FindDir = -DoorDirOfRotated;
						}
					}

					if (CountTime == 1)
					{
						TargetRoomDoor = _CurDoor;
						FindEntrance = true;
						EntranceDoorCenter = TempDoorCenter2D;
						EntranceDir = FindDir;
						break;
					}
				}

				if (FindEntrance)
				{
					FVector2D TempTestP = EntranceDoorCenter + 30 * EntranceDir;
					FVector2D TempTestInterSectP1, TempTestInterSectP2;
					FPolygonAlg::CalculateRayToInterSectP(LivingRoomPs, TempTestP, EntranceDir, TempTestInterSectP1);
					FPolygonAlg::CalculateRayToInterSectP(LivingRoomPs, TempTestP, -EntranceDir, TempTestInterSectP2);
					float LengthOfSide1 = FVector2D::Distance(TempTestP, TempTestInterSectP1);
					float LengthOfSide2 = FVector2D::Distance(TempTestP, TempTestInterSectP2);
					float TotalLengthOfCase1 = LengthOfSide1 + LengthOfSide2;

					FVector2D TempRoV = EntranceDir.GetRotated(90);
					FVector2D TempTestInterSectP3, TempTestInterSectP4;
					FPolygonAlg::CalculateRayToInterSectP(LivingRoomPs, TempTestP, TempRoV, TempTestInterSectP3);
					FPolygonAlg::CalculateRayToInterSectP(LivingRoomPs, TempTestP, -TempRoV, TempTestInterSectP4);
					float LengthOfSide3 = FVector2D::Distance(TempTestP, TempTestInterSectP3);
					float LengthOfSide4 = FVector2D::Distance(TempTestP, TempTestInterSectP4);
					float TotalLengthOfCase2 = LengthOfSide3 + LengthOfSide4;

					if ((TotalLengthOfCase1 > TotalLengthOfCase2) || (abs(TotalLengthOfCase1 - TotalLengthOfCase2) <= 100))
					{
						StartPoint = FVector(EntranceDoorCenter + 50 * EntranceDir, LivingOrDiningHeight);
					}
					else
					{
						//////计算修正后的起始点////////////
						TArray<FVector2D> InterSectPsOfStartLine;
						bool IsDone = FPolygonAlg::CalculateRayInterSectWithPoly(EntranceDoorCenter, EntranceDir, LivingRoomPs, InterSectPsOfStartLine);
						if ((IsDone) && (InterSectPsOfStartLine.Num() == 2))
						{
							StartPoint = FVector(0.5*(InterSectPsOfStartLine[0] + InterSectPsOfStartLine[1]), LivingOrDiningHeight);
						}
						else
						{
							StartPoint = FVector(EntranceDoorCenter + 50 * EntranceDir, LivingOrDiningHeight);
						}

						if (LengthOfSide3 > LengthOfSide4)
						{
							EntranceDir = TempRoV;
						}
						else
						{
							EntranceDir = -TempRoV;
						}
					}
					FirstIsLivingRoom = true;
				}
			}

			bool NeedChangeDir = false;
			if (FirstIsLivingRoom)
			{
				/////////////////////计算起居室局部最大矩形/////////////////////
				TArray<FVector2D> MaxLocalOfLivingRoom;
				bool IsSuccess = FPolygonAlg::LocateMaxLocalRegionOfRoom(LivingRoomPs, MaxLocalOfLivingRoom);
				if (IsSuccess)
				{
					FVector2D CenterP(0.0, 0.0);
					for (int _CurI = 0; _CurI < MaxLocalOfLivingRoom.Num(); ++_CurI)
					{
						CenterP = CenterP + MaxLocalOfLivingRoom[_CurI];
					}
					CenterP = CenterP / MaxLocalOfLivingRoom.Num();
					TArray<FVector2D> CriticalPointsOfLivingRoom;


					if (!FPolygonAlg::JudgePointInPolygon(MaxLocalOfLivingRoom, FVector2D(StartPoint)))
					{
						NeedChangeDir = true;
						TArray<FVector2D> InterSectPs;
						FVector2D TargetInterSectP, MiddleP;
						bool IsInterSected = FPolygonAlg::CalculateRayInterSectWithPoly(FVector2D(StartPoint), EntranceDir, MaxLocalOfLivingRoom, InterSectPs);
						if (IsInterSected)
						{
							float TempMinDis = 0.0f;
							float TempX = 0.0f, TempY = 0.0f;
							for (int _CurI = 0; _CurI < InterSectPs.Num(); ++_CurI)
							{
								float TempDisL = FVector2D::Distance(FVector2D(StartPoint), InterSectPs[_CurI]);
								if ((TempMinDis <= 1.0*10E-5) || (TempMinDis >= TempDisL))
								{
									TempMinDis = TempDisL;
									TargetInterSectP = InterSectPs[_CurI];
								}
								TempX = TempX + InterSectPs[_CurI].X;
								TempY = TempY + InterSectPs[_CurI].Y;
							}
							TempX = TempX / InterSectPs.Num();
							TempY = TempY / InterSectPs.Num();
							MiddleP = FVector2D(TempX, TempY);
						}
						CriticalPointsOfLivingRoom.Add(FVector2D(StartPoint));
						CriticalPointsOfLivingRoom.Add(TargetInterSectP);
						CriticalPointsOfLivingRoom.Add(MiddleP);
					}
					else
					{
						for (int _CurJ = 0; _CurJ < MaxLocalOfLivingRoom.Num(); ++_CurJ)
						{
							CriticalPointsOfLivingRoom.Add(0.25*CenterP + 0.75*MaxLocalOfLivingRoom[_CurJ]);
						}

					}

					for (int _CurP = 0; _CurP < CriticalPointsOfLivingRoom.Num(); ++_CurP)
					{
						FPointPair _CurPair;
						_CurPair.RoutinePoint = FVector(CriticalPointsOfLivingRoom[_CurP], LivingOrDiningHeight);
						_CurPair.WatchPoint = FVector(CenterP, LivingOrDiningHeight);
						if (_CurP == CriticalPointsOfLivingRoom.Num() - 1)
						{
							_CurPair.ActionMarker = 1;
						}
						else
						{
							_CurPair.ActionMarker = 0;
						}

						TempPointPairs.Add(_CurPair);
					}
					if (TempPointPairs.Num() > 0)
					{
						FPathLine TempLine;
						TempLine.RoutinePoints = TempPointPairs;
						TempPointPairs.Empty();
						RoomIDMapPathLine.Add(LivingRoomID, TempLine);
					}
					HasCalculatedRoomIDs.AddUnique(LivingRoomID);
				}

			}
		}
		else
		{
			FString EntranceRoomName = RoomIDMapName[GlobaleEntranceRoomID];
			TArray<int> HasCalculatedRoomIDs;
			TArray<FPointPair> TempPointPairs;
			if (EntranceRoomName == TEXT("厨房"))
			{
				TArray<FVector2D> TempKitchenCriticalPoints;
				FVector2D  KitchenRegionCenter;
				bool IsLocated = LocateCriticalPointsOfKitchen(WorldContextObject,
					RoomIDMapBoundary[GlobaleEntranceRoomID],
					GlobaleEntranceRoomID,
					TempKitchenCriticalPoints,
					KitchenRegionCenter);
				if (IsLocated)
				{
					for (int _CurP = 0; _CurP < TempKitchenCriticalPoints.Num(); ++_CurP)
					{
						FPointPair _CurPair;
						_CurPair.RoutinePoint = FVector(TempKitchenCriticalPoints[_CurP], OtherHeight);
						_CurPair.WatchPoint = FVector(KitchenRegionCenter, OtherHeight);
						if (_CurP == 0)
						{
							_CurPair.ActionMarker = 1;
						}
						else
						{
							_CurPair.ActionMarker = 0;
						}
						TempPointPairs.Add(_CurPair);
					}

					if (TempPointPairs.Num() > 0)
					{
						FPathLine TempLine;
						TempLine.RoutinePoints = TempPointPairs;
						TempPointPairs.Empty();
						RoomIDMapPathLine.Add(GlobaleEntranceRoomID, TempLine);
					}
					HasCalculatedRoomIDs.AddUnique(GlobaleEntranceRoomID);
				}
			}
			else if ((EntranceRoomName == TEXT("主卫")) || (EntranceRoomName == TEXT("客卫")))
			{
				TArray<FVector2D> TempToiletCriticalPoints;
				FVector2D TempLocalCenter;
				bool LocateToiletSuccess = LocateCriticalPointsOfToilet(WorldContextObject,
					RoomIDMapBoundary[GlobaleEntranceRoomID],
					AllWallCenters,
					GlobaleEntranceRoomID,
					TempToiletCriticalPoints,
					TempLocalCenter);
				if (LocateToiletSuccess)
				{
					for (int _CurP = 0; _CurP < TempToiletCriticalPoints.Num(); ++_CurP)
					{
						FPointPair _CurPair;
						_CurPair.RoutinePoint = FVector(TempToiletCriticalPoints[_CurP], OtherHeight);
						_CurPair.WatchPoint = FVector(TempLocalCenter, OtherHeight);
						if (_CurP == 0)
						{
							_CurPair.ActionMarker = 1;
						}
						else
						{
							_CurPair.ActionMarker = 0;
						}
						TempPointPairs.Add(_CurPair);
					}

					if (TempPointPairs.Num() > 0)
					{
						FPathLine TempLine;
						TempLine.RoutinePoints = TempPointPairs;
						TempPointPairs.Empty();
						RoomIDMapPathLine.Add(GlobaleEntranceRoomID, TempLine);
					}
					HasCalculatedRoomIDs.AddUnique(GlobaleEntranceRoomID);
				}
			}
			else if ((EntranceRoomName == TEXT("衣帽间")) || (EntranceRoomName == TEXT("储藏间")))
			{
				FVector2D TempCenter;
				bool IsLocateCenter = FPolygonAlg::LocateSuitableCenter(RoomIDMapBoundary[GlobaleEntranceRoomID], TempCenter);
				if (IsLocateCenter)
				{
					TArray<FVector> DoorPoints;
					bool GetDoors = GetDoorsOfRegion(WorldContextObject, GlobaleEntranceRoomID, DoorPoints);
					if (GetDoors)
					{
						int NumOfDoors = DoorPoints.Num() / 8;
						if (NumOfDoors >= 1)
						{
							FVector2D TempFinalNode;
							for (int _CurDoor = 0; _CurDoor < NumOfDoors; ++_CurDoor)
							{
								FVector2D TempDoorCenter = FVector2D(0.25*(DoorPoints[0 + 8 * _CurDoor] + DoorPoints[1 + 8 * _CurDoor] + DoorPoints[2 + 8 * _CurDoor] + DoorPoints[3 + 8 * _CurDoor]));
								FVector2D TempSide1 = FVector2D(DoorPoints[1 + 8 * _CurDoor] - DoorPoints[0 + 8 * _CurDoor]);
								FVector2D TempSide2 = FVector2D(DoorPoints[2 + 8 * _CurDoor] - DoorPoints[0 + 8 * _CurDoor]);
								float TempLength1 = TempSide1.Size();
								float TempLength2 = TempSide2.Size();
								TempSide1.Normalize();
								TempSide2.Normalize();
								FVector2D TempBaseDir;
								if (TempLength1 > TempLength2)
								{
									TempBaseDir = TempSide2;
								}
								else
								{
									TempBaseDir = TempSide1;
								}

								FVector2D TempNode1 = TempDoorCenter + 25 * TempBaseDir;
								FVector2D TempNode2 = TempDoorCenter - 25 * TempBaseDir;
								if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[GlobaleEntranceRoomID], TempNode1))
								{
									TempFinalNode = TempNode1;
									break;
								}
								if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[GlobaleEntranceRoomID], TempNode2))
								{
									TempFinalNode = TempNode2;
									break;
								}
							}

							FPointPair _CurPair1;
							_CurPair1.RoutinePoint = FVector(TempFinalNode, OtherHeight);
							_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
							_CurPair1.ActionMarker = 1;
							TempPointPairs.Add(_CurPair1);


							if (TempPointPairs.Num() > 0)
							{
								FPathLine TempLine;
								TempLine.RoutinePoints = TempPointPairs;
								TempPointPairs.Empty();
								RoomIDMapPathLine.Add(GlobaleEntranceRoomID, TempLine);
							}

							HasCalculatedRoomIDs.AddUnique(GlobaleEntranceRoomID);
						}
					}
					else
					{
						int CurrentEdge = 0, NextEdge = 0;
						for (int _CurEdge = 0; _CurEdge < RoomIDMapBoundary[GlobaleEntranceRoomID].Num(); ++_CurEdge)
						{
							if (_CurEdge == RoomIDMapBoundary[GlobaleEntranceRoomID].Num() - 1)
							{
								NextEdge = 0;
							}
							else
							{
								NextEdge = _CurEdge + 1;
							}
							FVector2D TempMiddleP = 0.5*(RoomIDMapBoundary[GlobaleEntranceRoomID][_CurEdge] + RoomIDMapBoundary[GlobaleEntranceRoomID][NextEdge]);
							FVector2D EdgeDir = RoomIDMapBoundary[GlobaleEntranceRoomID][NextEdge] - RoomIDMapBoundary[GlobaleEntranceRoomID][_CurEdge];
							EdgeDir.Normalize();
							FVector2D RotatedEdgeDir = EdgeDir.GetRotated(90);
							FVector2D TempExtendP1 = TempMiddleP + 5 * RotatedEdgeDir;
							FVector2D TempExtendP2 = TempMiddleP - 5 * RotatedEdgeDir;
							for (int IRoom = 0; IRoom < AllRoomIDs.Num(); ++IRoom)
							{
								if (AllRoomIDs[IRoom] != GlobaleEntranceRoomID)
								{
									if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[IRoom]], TempExtendP1))
									{
										FPointPair _CurPair1;
										_CurPair1.RoutinePoint = FVector(TempExtendP1 - 10 * RotatedEdgeDir, OtherHeight);
										_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
										_CurPair1.ActionMarker = 1;
										TempPointPairs.Add(_CurPair1);
										HasCalculatedRoomIDs.AddUnique(GlobaleEntranceRoomID);
										break;
									}

									if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[IRoom]], TempExtendP2))
									{
										FPointPair _CurPair1;
										_CurPair1.RoutinePoint = FVector(TempExtendP2 + 10 * RotatedEdgeDir, OtherHeight);
										_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
										_CurPair1.ActionMarker = 1;
										TempPointPairs.Add(_CurPair1);
										HasCalculatedRoomIDs.AddUnique(GlobaleEntranceRoomID);
										break;
									}
								}
							}
						}

						if (TempPointPairs.Num() > 0)
						{
							FPathLine TempLine;
							TempLine.RoutinePoints = TempPointPairs;
							TempPointPairs.Empty();
							RoomIDMapPathLine.Add(GlobaleEntranceRoomID, TempLine);
						}
					}
				}
			}
			else if ((EntranceRoomName == TEXT("主卧")) || (EntranceRoomName == TEXT("次卧")) || (EntranceRoomName == TEXT("老人房")) || (EntranceRoomName == TEXT("书房")) || (EntranceRoomName == TEXT("多功能房"))
				|| (EntranceRoomName == TEXT("儿童房")) || (EntranceRoomName == TEXT("榻榻米房")))
			{
				TArray<FVector2D> TempRoomCriticalPoints, MaxLocalRegion;
				bool IsSuccess = FPolygonAlg::LocateMaxLocalRegionOfRoom(RoomIDMapBoundary[GlobaleEntranceRoomID], MaxLocalRegion);
				if (IsSuccess)
				{
					FVector2D TempCenterP(0.0, 0.0);
					for (int _CurJ = 0; _CurJ < MaxLocalRegion.Num(); ++_CurJ)
					{
						TempCenterP = TempCenterP + MaxLocalRegion[_CurJ];
					}

					TempCenterP = TempCenterP / MaxLocalRegion.Num();
					FVector2D TempNode1 = 0.5*(GlobaleEntranceDoorCenter + TempCenterP);
					if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[GlobaleEntranceRoomID], TempNode1))
					{
						TempRoomCriticalPoints.AddUnique(TempNode1);
					}
					TempRoomCriticalPoints.AddUnique(TempCenterP);

					for (int _CurP = 0; _CurP < TempRoomCriticalPoints.Num(); ++_CurP)
					{
						FPointPair _CurPair;
						_CurPair.RoutinePoint = FVector(TempRoomCriticalPoints[_CurP], OtherHeight);
						_CurPair.WatchPoint = FVector(TempCenterP, OtherHeight);
						if (TempRoomCriticalPoints.Num() == 1)
						{
							_CurPair.ActionMarker = 1;
						}
						else
						{
							_CurPair.ActionMarker = 0;
						}
						TempPointPairs.Add(_CurPair);
					}
					if (TempPointPairs.Num() > 0)
					{
						FPathLine TempLine;
						TempLine.RoutinePoints = TempPointPairs;
						TempPointPairs.Empty();
						RoomIDMapPathLine.Add(GlobaleEntranceRoomID, TempLine);
					}
					HasCalculatedRoomIDs.AddUnique(GlobaleEntranceRoomID);
				}
			}
		}

		/////////////////////计算剩余空间//////////////////////
		int NumOfIter = 0;
		while (AllRoomIDs.Num() != HasCalculatedRoomIDs.Num())
		{
			NumOfIter++;
			for (int _CurRoom = 0; _CurRoom < AllRoomIDs.Num(); ++_CurRoom)
			{
				if (!HasCalculatedRoomIDs.Contains(AllRoomIDs[_CurRoom]))
				{
					FString TempName = RoomIDMapName[AllRoomIDs[_CurRoom]];
					if ((TempName == TEXT("主卧")) || (TempName == TEXT("次卧")) || (TempName == TEXT("儿童房")) || (TempName == TEXT("老人房")) ||
						(TempName == TEXT("榻榻米房")) || (TempName == TEXT("多功能房")) || (TempName == TEXT("书房"))
						|| (TempName == TEXT("客人房")) || (TempName == TEXT("健身房")))
					{
						TArray<FVector2D> TempRoomCriticalPoints, MaxLocalRegion;
						FVector2D TempWatchNode;
						bool PointInModel = false;
						bool IsSuccess = FPolygonAlg::LocateMaxLocalRegionOfRoom(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], MaxLocalRegion);
						if (IsSuccess)
						{
							FVector2D TempCenterP(0.0, 0.0);
							for (int _CurJ = 0; _CurJ < MaxLocalRegion.Num(); ++_CurJ)
							{
								TempCenterP = TempCenterP + MaxLocalRegion[_CurJ];
							}
							TempCenterP = TempCenterP / MaxLocalRegion.Num();
							TArray<FVector2D> ShrinkPoints;
							for (int IP = 0; IP < MaxLocalRegion.Num(); ++IP)
							{
								ShrinkPoints.Add(ShrinkRatio*MaxLocalRegion[IP] + (1 - ShrinkRatio)*TempCenterP);
							}
							FVector2D Node1 = 0.5*(ShrinkPoints[0] + ShrinkPoints[1]);
							FVector2D Node2 = 0.5*(ShrinkPoints[1] + ShrinkPoints[2]);
							FVector2D Node3 = 0.5*(ShrinkPoints[2] + ShrinkPoints[3]);
							FVector2D Node4 = 0.5*(ShrinkPoints[3] + ShrinkPoints[0]);

							TArray<AFurnitureModelActor*> ModelsOfRoom;
							FindModelsOfRoom(WorldContextObject, RoomIDMapBoundary[AllRoomIDs[_CurRoom]], ModelsOfRoom);
							AFurnitureModelActor* FindFur = nullptr;
							bool FindModel = false;
							for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
							{
								AFurnitureModelActor* TempFur = ModelsOfRoom[_CurM];
								int TempID = 0;
								TempFur->GetModelCategory(TempID);
								if ((TempID == 5009) || (TempID == 5010) || (TempID == 5125))
								{
									FindFur = TempFur;
									FindModel = true;
									break;
								}
							}



							TArray<AHouseCustomActor*> CustomModelsOfRoom;
							FindCustomModelsOfRoom(WorldContextObject, RoomIDMapBoundary[AllRoomIDs[_CurRoom]], CustomModelsOfRoom);


							if (FindModel)
							{
								FBox TempBox = FindFur->GetComponentsBoundingBox(true);
								FVector FMin = TempBox.Min;
								FVector FMax = TempBox.Max;
								FVector2D P1(FMin.X, FMin.Y);
								FVector2D P2(FMax.X, FMin.Y);
								FVector2D P3(FMax.X, FMax.Y);
								FVector2D P4(FMin.X, FMax.Y);
								FVector2D BoxCenter = 0.25*(P1 + P2 + P3 + P4);
								TempWatchNode = BoxCenter;
								float Dis1 = FVector2D::Distance(Node1, BoxCenter);
								float Dis2 = FVector2D::Distance(Node2, BoxCenter);
								float Dis3 = FVector2D::Distance(Node3, BoxCenter);
								float Dis4 = FVector2D::Distance(Node4, BoxCenter);
								FVector2D BaseNode = Node1;
								if ((Dis2 >= Dis1) && (Dis2 >= Dis3) && (Dis2 >= Dis4))
								{
									BaseNode = Node2;
								}
								else if ((Dis3 >= Dis1) && (Dis3 >= Dis2) && (Dis3 >= Dis4))
								{
									BaseNode = Node3;
								}
								else if ((Dis4 >= Dis1) && (Dis4 >= Dis2) && (Dis4 >= Dis3))
								{
									BaseNode = Node4;
								}

								for (int _CurM = 0; _CurM < CustomModelsOfRoom.Num(); ++_CurM)
								{
									FBox TempBox = CustomModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
									FString ModelName = CustomModelsOfRoom[_CurM]->GetName();
									if (!ModelName.Contains(FString("Light")))
									{
										bool IfInModel = TempBox.IsInsideOrOn(FVector(BaseNode, OtherHeight));
										if (IfInModel)
										{
											FVector FMin = TempBox.Min;
											FVector FMax = TempBox.Max;
											float TempModelZ = FMax.Z - FMin.Z;
											if (TempModelZ >= HeightBound)
											{
												bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, RoomIDMapBoundary[AllRoomIDs[_CurRoom]]);
												if (ModelBoxIsUseful)
												{
													PointInModel = true;
													break;
												}
											}
										}
									}
								}

								for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
								{
									FBox TempBox = ModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
									FString ModelName = ModelsOfRoom[_CurM]->GetName();
									if (!ModelName.Contains(FString("Light")))
									{
										bool IfInModel = TempBox.IsInsideOrOn(FVector(BaseNode, OtherHeight));
										if (IfInModel)
										{
											FVector FMin = TempBox.Min;
											FVector FMax = TempBox.Max;
											float TempModelZ = FMax.Z - FMin.Z;
											if (TempModelZ >= HeightBound)
											{
												bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, RoomIDMapBoundary[AllRoomIDs[_CurRoom]]);
												if (ModelBoxIsUseful)
												{
													PointInModel = true;
													break;
												}
											}
										}
									}
								}
								if (!PointInModel)
								{
									TempRoomCriticalPoints.Add(BaseNode);
									TempRoomCriticalPoints.Add(0.8*BoxCenter + 0.2*BaseNode);
								}
							}
						}

						if (TempRoomCriticalPoints.Num() == 0)
						{
							FVector2D LocalCenterNode;
							FPolygonAlg::LocateSuitableCenter(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], LocalCenterNode);
							TempRoomCriticalPoints.AddUnique(LocalCenterNode);
							TempWatchNode = FVector2D(0.0, 0.0);
						}


						for (int _CurP = 0; _CurP < TempRoomCriticalPoints.Num(); ++_CurP)
						{
							FPointPair _CurPair;
							_CurPair.RoutinePoint = FVector(TempRoomCriticalPoints[_CurP], OtherHeight);
							_CurPair.WatchPoint = FVector(TempWatchNode, OtherHeight);
							if (TempRoomCriticalPoints.Num() == 1)
							{
								_CurPair.ActionMarker = 1;
							}
							else
							{
								_CurPair.ActionMarker = 0;
							}
							TempPointPairs.Add(_CurPair);
						}
						if (TempPointPairs.Num() > 0)
						{
							FPathLine TempLine;
							TempLine.RoutinePoints = TempPointPairs;
							TempPointPairs.Empty();
							RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
						}
						HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
					}
					else if ((TempName == TEXT("主卫")) || (TempName == TEXT("客卫")) || (TempName == TEXT("卫生间")))
					{
						TArray<FVector2D> TempToiletCriticalPoints;
						FVector2D TempLocalCenter;
						bool LocateToiletSuccess = LocateCriticalPointsOfToilet(WorldContextObject,
							RoomIDMapBoundary[AllRoomIDs[_CurRoom]],
							AllWallCenters,
							AllRoomIDs[_CurRoom],
							TempToiletCriticalPoints,
							TempLocalCenter);
						if (LocateToiletSuccess)
						{
							for (int _CurP = 0; _CurP < TempToiletCriticalPoints.Num(); ++_CurP)
							{
								FPointPair _CurPair;
								_CurPair.RoutinePoint = FVector(TempToiletCriticalPoints[_CurP], OtherHeight);
								_CurPair.WatchPoint = FVector(TempLocalCenter, OtherHeight);
								if (_CurP == 0)
								{
									_CurPair.ActionMarker = 1;
								}
								else
								{
									_CurPair.ActionMarker = 0;
								}
								TempPointPairs.Add(_CurPair);
							}

							if (TempPointPairs.Num() > 0)
							{
								FPathLine TempLine;
								TempLine.RoutinePoints = TempPointPairs;
								TempPointPairs.Empty();
								RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
							}
							HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
						}
					}
					else if ((TempName == TEXT("生活阳台")) || (TempName == TEXT("休闲阳台")))
					{
						TArray<FVector2D> TempCriticalPoints;
						FVector2D  LocalRegionCenter;
						bool IsGetted = LocateTwoCriticalPointsOfBalcony(WorldContextObject, RoomIDMapBoundary[AllRoomIDs[_CurRoom]], AllRoomIDs[_CurRoom],
							TempCriticalPoints, LocalRegionCenter);
						if (IsGetted)
						{
							for (int _CurP = 0; _CurP < TempCriticalPoints.Num(); ++_CurP)
							{
								FPointPair _CurPair;
								_CurPair.RoutinePoint = FVector(TempCriticalPoints[_CurP], OtherHeight);
								_CurPair.WatchPoint = FVector(LocalRegionCenter, OtherHeight);
								_CurPair.ActionMarker = 0;
								TempPointPairs.Add(_CurPair);
							}

							if (TempPointPairs.Num() > 0)
							{
								FPathLine TempLine;
								TempLine.RoutinePoints = TempPointPairs;
								TempPointPairs.Empty();
								RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
							}
							HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
						}
					}
					else if (TempName == TEXT("厨房"))
					{
						TArray<FVector2D> TempKitchenCriticalPoints;
						FVector2D  KitchenRegionCenter;
						bool IsLocated = LocateCriticalPointsOfKitchen(WorldContextObject,
							RoomIDMapBoundary[AllRoomIDs[_CurRoom]],
							AllRoomIDs[_CurRoom],
							TempKitchenCriticalPoints,
							KitchenRegionCenter);
						if (IsLocated)
						{
							for (int _CurP = 0; _CurP < TempKitchenCriticalPoints.Num(); ++_CurP)
							{
								FPointPair _CurPair;
								_CurPair.RoutinePoint = FVector(TempKitchenCriticalPoints[_CurP], OtherHeight);
								_CurPair.WatchPoint = FVector(KitchenRegionCenter, OtherHeight);
								if (_CurP == 0)
								{
									_CurPair.ActionMarker = 1;
								}
								else
								{
									_CurPair.ActionMarker = 0;
								}
								TempPointPairs.Add(_CurPair);
							}

							if (TempPointPairs.Num() > 0)
							{
								FPathLine TempLine;
								TempLine.RoutinePoints = TempPointPairs;
								TempPointPairs.Empty();
								RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
							}
							HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
						}
					}
					else if ((TempName == TEXT("衣帽间")) || (TempName == TEXT("储藏间")))
					{
						FVector2D TempCenter;
						bool IsLocateCenter = FPolygonAlg::LocateSuitableCenter(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], TempCenter);
						if (IsLocateCenter)
						{
							TArray<FVector> DoorPoints;
							bool GetDoors = GetDoorsOfRegion(WorldContextObject, AllRoomIDs[_CurRoom], DoorPoints);
							if (GetDoors)
							{
								int NumOfDoors = DoorPoints.Num() / 8;
								if (NumOfDoors >= 1)
								{
									FVector2D TempFinalNode;
									for (int _CurDoor = 0; _CurDoor < NumOfDoors; ++_CurDoor)
									{
										FVector2D TempDoorCenter = FVector2D(0.25*(DoorPoints[0 + 8 * _CurDoor] + DoorPoints[1 + 8 * _CurDoor] + DoorPoints[2 + 8 * _CurDoor] + DoorPoints[3 + 8 * _CurDoor]));
										FVector2D TempSide1 = FVector2D(DoorPoints[1 + 8 * _CurDoor] - DoorPoints[0 + 8 * _CurDoor]);
										FVector2D TempSide2 = FVector2D(DoorPoints[2 + 8 * _CurDoor] - DoorPoints[0 + 8 * _CurDoor]);
										float TempLength1 = TempSide1.Size();
										float TempLength2 = TempSide2.Size();
										TempSide1.Normalize();
										TempSide2.Normalize();
										FVector2D TempBaseDir;
										if (TempLength1 > TempLength2)
										{
											TempBaseDir = TempSide2;
										}
										else
										{
											TempBaseDir = TempSide1;
										}

										FVector2D TempNode1 = TempDoorCenter + 25 * TempBaseDir;
										FVector2D TempNode2 = TempDoorCenter - 25 * TempBaseDir;
										if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], TempNode1))
										{
											TempFinalNode = TempNode1;
											break;
										}
										if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], TempNode2))
										{
											TempFinalNode = TempNode2;
											break;
										}
									}

									FPointPair _CurPair1;
									_CurPair1.RoutinePoint = FVector(TempFinalNode, OtherHeight);
									_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
									_CurPair1.ActionMarker = 1;
									TempPointPairs.Add(_CurPair1);


									if (TempPointPairs.Num() > 0)
									{
										FPathLine TempLine;
										TempLine.RoutinePoints = TempPointPairs;
										TempPointPairs.Empty();
										RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
									}

									HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
								}
							}
							else
							{
								int CurrentEdge = 0, NextEdge = 0;
								for (int _CurEdge = 0; _CurEdge < RoomIDMapBoundary[AllRoomIDs[_CurRoom]].Num(); ++_CurEdge)
								{
									if (_CurEdge == RoomIDMapBoundary[AllRoomIDs[_CurRoom]].Num() - 1)
									{
										NextEdge = 0;
									}
									else
									{
										NextEdge = _CurEdge + 1;
									}
									FVector2D TempMiddleP = 0.5*(RoomIDMapBoundary[AllRoomIDs[_CurRoom]][_CurEdge] + RoomIDMapBoundary[AllRoomIDs[_CurRoom]][NextEdge]);
									FVector2D EdgeDir = RoomIDMapBoundary[AllRoomIDs[_CurRoom]][NextEdge] - RoomIDMapBoundary[AllRoomIDs[_CurRoom]][_CurEdge];
									EdgeDir.Normalize();
									FVector2D RotatedEdgeDir = EdgeDir.GetRotated(90);
									FVector2D TempExtendP1 = TempMiddleP + 5 * RotatedEdgeDir;
									FVector2D TempExtendP2 = TempMiddleP - 5 * RotatedEdgeDir;
									for (int IRoom = 0; IRoom < AllRoomIDs.Num(); ++IRoom)
									{
										if (AllRoomIDs[IRoom] != AllRoomIDs[_CurRoom])
										{
											if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[IRoom]], TempExtendP1))
											{
												FPointPair _CurPair1;
												_CurPair1.RoutinePoint = FVector(TempExtendP1 - 10 * RotatedEdgeDir, OtherHeight);
												_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
												_CurPair1.ActionMarker = 1;
												TempPointPairs.Add(_CurPair1);
												HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
												break;
											}

											if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[IRoom]], TempExtendP2))
											{
												FPointPair _CurPair1;
												_CurPair1.RoutinePoint = FVector(TempExtendP2 + 10 * RotatedEdgeDir, OtherHeight);
												_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
												_CurPair1.ActionMarker = 1;
												TempPointPairs.Add(_CurPair1);


												HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
												break;
											}
										}
									}
								}

								if (TempPointPairs.Num() > 0)
								{
									FPathLine TempLine;
									TempLine.RoutinePoints = TempPointPairs;
									TempPointPairs.Empty();
									RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
								}
							}

						}
					}
					else if (TempName == TEXT("客厅"))
					{
						TArray<FVector2D> PathPoints;
						FVector2D LocalWatchPoint;
						bool IsLocatedLiving = LocateCriticalPointsOfSpecialLivingOrDining(WorldContextObject, RoomIDMapBoundary[AllRoomIDs[_CurRoom]], AllRoomIDs[_CurRoom],
							PathPoints, LocalWatchPoint, true);
						if (IsLocatedLiving)
						{
							for (int _CurP = 0; _CurP < PathPoints.Num(); ++_CurP)
							{
								FPointPair _CurPair;
								_CurPair.RoutinePoint = FVector(PathPoints[_CurP], LivingOrDiningHeight);
								_CurPair.WatchPoint = FVector(LocalWatchPoint, LivingOrDiningHeight);
								if (PathPoints.Num() == 1)
								{
									_CurPair.ActionMarker = 1;
								}
								else
								{
									_CurPair.ActionMarker = 0;
								}
								TempPointPairs.Add(_CurPair);
							}
							if (TempPointPairs.Num() > 0)
							{
								FPathLine TempLine;
								TempLine.RoutinePoints = TempPointPairs;
								TempPointPairs.Empty();
								RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
							}
							HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
						}
					}
					else
					{
						FVector2D TempCenter;
						bool IsLocateCenter = FPolygonAlg::LocateSuitableCenter(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], TempCenter);
						if (IsLocateCenter)
						{
							TArray<FVector> DoorPoints;
							bool GetDoors = GetDoorsOfRegion(WorldContextObject, AllRoomIDs[_CurRoom], DoorPoints);
							if (GetDoors)
							{
								int NumOfDoors = DoorPoints.Num() / 8;
								if (NumOfDoors >= 1)
								{
									FVector2D TempDoorCenter = FVector2D(0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]));
									if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], TempDoorCenter))
									{
										FVector2D TempDir = TempCenter - TempDoorCenter;
										TempDir.Normalize();
										FVector2D TempNode1 = TempDoorCenter + 25 * TempDir;
										FVector2D TempNode2 = 0.5*(TempDoorCenter + TempCenter);
										FPointPair _CurPair1;
										_CurPair1.RoutinePoint = FVector(TempNode1, OtherHeight);
										_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
										_CurPair1.ActionMarker = 1;
										TempPointPairs.Add(_CurPair1);
										FPointPair _CurPair2;
										_CurPair2.RoutinePoint = FVector(TempNode2, OtherHeight);
										_CurPair2.WatchPoint = FVector(TempCenter, OtherHeight);
										_CurPair2.ActionMarker = 0;
										TempPointPairs.Add(_CurPair2);

										if (TempPointPairs.Num() > 0)
										{
											FPathLine TempLine;
											TempLine.RoutinePoints = TempPointPairs;
											TempPointPairs.Empty();
											RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
										}

										HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
									}

								}
								else
								{
									FPointPair _CurPair1;
									_CurPair1.RoutinePoint = FVector(TempCenter, OtherHeight);
									_CurPair1.WatchPoint = FVector(0.0, 0.0, OtherHeight);
									_CurPair1.ActionMarker = 1;
									TempPointPairs.Add(_CurPair1);

									if (TempPointPairs.Num() > 0)
									{
										FPathLine TempLine;
										TempLine.RoutinePoints = TempPointPairs;
										TempPointPairs.Empty();
										RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
									}

									HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
								}
							}
						}
					}
				}
			}
			if (NumOfIter >= MaxNumIter)
			{
				return false;
			}
		}
	}
	else if ((IsDiningRoom) && (!IsLivingRoom) && (!IsStartRoom))
	{

		if (RoomIDMapName[GlobaleEntranceRoomID] == TEXT("餐厅"))
		{
			////////////获取起居室的门洞数据//////////////////////
			TArray<FVector> DiningRoomDoors;
			bool GetDiningRoomDoor = false;
			if (IsDiningRoom)
			{
				GetDiningRoomDoor = GetDoorsOfRegion(WorldContextObject, DiningRoomID, DiningRoomDoors);
			}
			///////////定位入户门////////////////////////
			FVector2D EntranceDoorCenter;
			FVector2D EntranceDir;
			FVector StartPoint;
			bool FindEntrance = false;

			bool FirstIsDiningRoom = false;
			if (GetDiningRoomDoor)
			{
				int TargetRoomDoor = 0;
				int NumOfDiningRoomDoors = DiningRoomDoors.Num() / 8;
				for (int _CurDoor = 0; _CurDoor < NumOfDiningRoomDoors; ++_CurDoor)
				{
					FVector2D FindDir;
					FVector TempDoorCenter = 0.25*(DiningRoomDoors[8 * _CurDoor + 0] + DiningRoomDoors[8 * _CurDoor + 1] + DiningRoomDoors[8 * _CurDoor + 2] + DiningRoomDoors[8 * _CurDoor + 3]);
					FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter);
					FVector2D DoorDir = FVector2D(DiningRoomDoors[8 * _CurDoor + 1] - DiningRoomDoors[8 * _CurDoor]);
					DoorDir = DoorDir.GetSafeNormal();
					FVector2D DoorDirOfRotated = DoorDir.GetRotated(90);
					FVector2D ExtendP1 = TempDoorCenter2D + 35 * DoorDirOfRotated;
					FVector2D ExtendP2 = TempDoorCenter2D - 35 * DoorDirOfRotated;
					int CountTime = 0;
					for (int _CurRoom = 0; _CurRoom < AllRoomIDs.Num(); ++_CurRoom)
					{

						TArray<FVector2D> TempRegionPs = RoomIDMapBoundary[AllRoomIDs[_CurRoom]];
						bool P1IsInRegion = FPolygonAlg::JudgePointInPolygon(TempRegionPs, ExtendP1);
						bool P2IsInRegion = FPolygonAlg::JudgePointInPolygon(TempRegionPs, ExtendP2);

						if (P1IsInRegion)
						{
							CountTime++;
							FindDir = DoorDirOfRotated;
						}

						if (P2IsInRegion)
						{
							CountTime++;
							FindDir = -DoorDirOfRotated;
						}
					}

					if (CountTime == 1)
					{
						TargetRoomDoor = _CurDoor;
						FindEntrance = true;
						EntranceDoorCenter = TempDoorCenter2D;
						EntranceDir = FindDir;
						break;
					}
				}

				if (FindEntrance)
				{
					FVector2D TempTestP = EntranceDoorCenter + 30 * EntranceDir;
					FVector2D TempTestInterSectP1, TempTestInterSectP2;
					FPolygonAlg::CalculateRayToInterSectP(DiningRoomPs, TempTestP, EntranceDir, TempTestInterSectP1);
					FPolygonAlg::CalculateRayToInterSectP(DiningRoomPs, TempTestP, -EntranceDir, TempTestInterSectP2);
					float LengthOfSide1 = FVector2D::Distance(TempTestP, TempTestInterSectP1);
					float LengthOfSide2 = FVector2D::Distance(TempTestP, TempTestInterSectP2);
					float TotalLengthOfCase1 = LengthOfSide1 + LengthOfSide2;

					FVector2D TempRoV = EntranceDir.GetRotated(90);
					FVector2D TempTestInterSectP3, TempTestInterSectP4;
					FPolygonAlg::CalculateRayToInterSectP(DiningRoomPs, TempTestP, TempRoV, TempTestInterSectP3);
					FPolygonAlg::CalculateRayToInterSectP(DiningRoomPs, TempTestP, -TempRoV, TempTestInterSectP4);
					float LengthOfSide3 = FVector2D::Distance(TempTestP, TempTestInterSectP3);
					float LengthOfSide4 = FVector2D::Distance(TempTestP, TempTestInterSectP4);
					float TotalLengthOfCase2 = LengthOfSide3 + LengthOfSide4;

					if ((TotalLengthOfCase1 > TotalLengthOfCase2) || (abs(TotalLengthOfCase1 - TotalLengthOfCase2) <= 100))
					{
						StartPoint = FVector(EntranceDoorCenter + 50 * EntranceDir, LivingOrDiningHeight);
					}
					else
					{
						//////计算修正后的起始点////////////
						TArray<FVector2D> InterSectPsOfStartLine;
						bool IsDone = FPolygonAlg::CalculateRayInterSectWithPoly(EntranceDoorCenter, EntranceDir, DiningRoomPs, InterSectPsOfStartLine);
						if ((IsDone) && (InterSectPsOfStartLine.Num() == 2))
						{
							StartPoint = FVector(0.5*(InterSectPsOfStartLine[0] + InterSectPsOfStartLine[1]), LivingOrDiningHeight);
						}
						else
						{
							StartPoint = FVector(EntranceDoorCenter + 50 * EntranceDir, LivingOrDiningHeight);
						}

						if (LengthOfSide3 > LengthOfSide4)
						{
							EntranceDir = TempRoV;
						}
						else
						{
							EntranceDir = -TempRoV;
						}
					}
					FirstIsDiningRoom = true;
				}
			}

			bool NeedChangeDir = false;
			if (FirstIsDiningRoom)
			{
				/////////////////////计算起居室局部最大矩形/////////////////////
				TArray<FVector2D> MaxLocalOfDiningRoom;
				bool IsSuccess = FPolygonAlg::LocateMaxLocalRegionOfRoom(DiningRoomPs, MaxLocalOfDiningRoom);
				if (IsSuccess)
				{
					FVector2D CenterP(0.0, 0.0);
					for (int _CurI = 0; _CurI < MaxLocalOfDiningRoom.Num(); ++_CurI)
					{
						CenterP = CenterP + MaxLocalOfDiningRoom[_CurI];
					}
					CenterP = CenterP / MaxLocalOfDiningRoom.Num();
					TArray<FVector2D> CriticalPointsOfDiningRoom;


					if (!FPolygonAlg::JudgePointInPolygon(MaxLocalOfDiningRoom, FVector2D(StartPoint)))
					{
						NeedChangeDir = true;
						TArray<FVector2D> InterSectPs;
						FVector2D TargetInterSectP, MiddleP;
						bool IsInterSected = FPolygonAlg::CalculateRayInterSectWithPoly(FVector2D(StartPoint), EntranceDir, MaxLocalOfDiningRoom, InterSectPs);
						if (IsInterSected)
						{
							float TempMinDis = 0.0f;
							float TempX = 0.0f, TempY = 0.0f;
							for (int _CurI = 0; _CurI < InterSectPs.Num(); ++_CurI)
							{
								float TempDisL = FVector2D::Distance(FVector2D(StartPoint), InterSectPs[_CurI]);
								if ((TempMinDis <= 1.0*10E-5) || (TempMinDis >= TempDisL))
								{
									TempMinDis = TempDisL;
									TargetInterSectP = InterSectPs[_CurI];
								}
								TempX = TempX + InterSectPs[_CurI].X;
								TempY = TempY + InterSectPs[_CurI].Y;
							}
							TempX = TempX / InterSectPs.Num();
							TempY = TempY / InterSectPs.Num();
							MiddleP = FVector2D(TempX, TempY);
						}
						CriticalPointsOfDiningRoom.Add(FVector2D(StartPoint));
						CriticalPointsOfDiningRoom.Add(TargetInterSectP);
						CriticalPointsOfDiningRoom.Add(MiddleP);
					}
					else
					{
						for (int _CurJ = 0; _CurJ < MaxLocalOfDiningRoom.Num(); ++_CurJ)
						{
							CriticalPointsOfDiningRoom.Add(0.25*CenterP + 0.75*MaxLocalOfDiningRoom[_CurJ]);
						}

					}

					for (int _CurP = 0; _CurP < CriticalPointsOfDiningRoom.Num(); ++_CurP)
					{
						FPointPair _CurPair;
						_CurPair.RoutinePoint = FVector(CriticalPointsOfDiningRoom[_CurP], LivingOrDiningHeight);
						_CurPair.WatchPoint = FVector(CenterP, LivingOrDiningHeight);
						if (_CurP == CriticalPointsOfDiningRoom.Num() - 1)
						{
							_CurPair.ActionMarker = 1;
						}
						else
						{
							_CurPair.ActionMarker = 0;
						}

						TempPointPairs.Add(_CurPair);
					}
					if (TempPointPairs.Num() > 0)
					{
						FPathLine TempLine;
						TempLine.RoutinePoints = TempPointPairs;
						TempPointPairs.Empty();
						RoomIDMapPathLine.Add(DiningRoomID, TempLine);
					}
					HasCalculatedRoomIDs.AddUnique(DiningRoomID);
				}

				/////////////////////计算剩余空间//////////////////////
				while (AllRoomIDs.Num() != HasCalculatedRoomIDs.Num())
				{
					for (int _CurRoom = 0; _CurRoom < AllRoomIDs.Num(); ++_CurRoom)
					{
						if (!HasCalculatedRoomIDs.Contains(AllRoomIDs[_CurRoom]))
						{
							FString TempName = RoomIDMapName[AllRoomIDs[_CurRoom]];
							if ((TempName == TEXT("主卧")) || (TempName == TEXT("次卧")) || (TempName == TEXT("儿童房")) || (TempName == TEXT("老人房")) ||
								(TempName == TEXT("榻榻米房")) || (TempName == TEXT("多功能房")) || (TempName == TEXT("书房"))
								|| (TempName == TEXT("客人房")) || (TempName == TEXT("健身房")))
							{
								TArray<FVector2D> TempRoomCriticalPoints, MaxLocalRegion;
								FVector2D TempWatchNode;
								bool PointInModel = false;
								bool IsSuccess = FPolygonAlg::LocateMaxLocalRegionOfRoom(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], MaxLocalRegion);
								if (IsSuccess)
								{
									FVector2D TempCenterP(0.0, 0.0);
									for (int _CurJ = 0; _CurJ < MaxLocalRegion.Num(); ++_CurJ)
									{
										TempCenterP = TempCenterP + MaxLocalRegion[_CurJ];
									}
									TempCenterP = TempCenterP / MaxLocalRegion.Num();
									TArray<FVector2D> ShrinkPoints;
									for (int IP = 0; IP < MaxLocalRegion.Num(); ++IP)
									{
										ShrinkPoints.Add(ShrinkRatio*MaxLocalRegion[IP] + (1 - ShrinkRatio)*TempCenterP);
									}
									FVector2D Node1 = 0.5*(ShrinkPoints[0] + ShrinkPoints[1]);
									FVector2D Node2 = 0.5*(ShrinkPoints[1] + ShrinkPoints[2]);
									FVector2D Node3 = 0.5*(ShrinkPoints[2] + ShrinkPoints[3]);
									FVector2D Node4 = 0.5*(ShrinkPoints[3] + ShrinkPoints[0]);

									TArray<AFurnitureModelActor*> ModelsOfRoom;
									FindModelsOfRoom(WorldContextObject, RoomIDMapBoundary[AllRoomIDs[_CurRoom]], ModelsOfRoom);
									AFurnitureModelActor* FindFur = nullptr;
									bool FindModel = false;
									for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
									{
										AFurnitureModelActor* TempFur = ModelsOfRoom[_CurM];
										int TempID = 0;
										TempFur->GetModelCategory(TempID);
										if ((TempID == 5009) || (TempID == 5010) || (TempID == 5125))
										{
											FindFur = TempFur;
											FindModel = true;
											break;
										}
									}



									TArray<AHouseCustomActor*> CustomModelsOfRoom;
									FindCustomModelsOfRoom(WorldContextObject, RoomIDMapBoundary[AllRoomIDs[_CurRoom]], CustomModelsOfRoom);


									if (FindModel)
									{
										FBox TempBox = FindFur->GetComponentsBoundingBox(true);
										FVector FMin = TempBox.Min;
										FVector FMax = TempBox.Max;
										FVector2D P1(FMin.X, FMin.Y);
										FVector2D P2(FMax.X, FMin.Y);
										FVector2D P3(FMax.X, FMax.Y);
										FVector2D P4(FMin.X, FMax.Y);
										FVector2D BoxCenter = 0.25*(P1 + P2 + P3 + P4);
										TempWatchNode = BoxCenter;
										float Dis1 = FVector2D::Distance(Node1, BoxCenter);
										float Dis2 = FVector2D::Distance(Node2, BoxCenter);
										float Dis3 = FVector2D::Distance(Node3, BoxCenter);
										float Dis4 = FVector2D::Distance(Node4, BoxCenter);
										FVector2D BaseNode = Node1;
										if ((Dis2 >= Dis1) && (Dis2 >= Dis3) && (Dis2 >= Dis4))
										{
											BaseNode = Node2;
										}
										else if ((Dis3 >= Dis1) && (Dis3 >= Dis2) && (Dis3 >= Dis4))
										{
											BaseNode = Node3;
										}
										else if ((Dis4 >= Dis1) && (Dis4 >= Dis2) && (Dis4 >= Dis3))
										{
											BaseNode = Node4;
										}

										for (int _CurM = 0; _CurM < CustomModelsOfRoom.Num(); ++_CurM)
										{
											FBox TempBox = CustomModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
											FString ModelName = CustomModelsOfRoom[_CurM]->GetName();
											if (!ModelName.Contains(FString("Light")))
											{
												bool IfInModel = TempBox.IsInsideOrOn(FVector(BaseNode, OtherHeight));
												if (IfInModel)
												{
													FVector FMin = TempBox.Min;
													FVector FMax = TempBox.Max;
													bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, RoomIDMapBoundary[AllRoomIDs[_CurRoom]]);
													if (ModelBoxIsUseful)
													{
														PointInModel = true;
														break;
													}
												}
											}
										}

										for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
										{
											FBox TempBox = ModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
											FString ModelName = ModelsOfRoom[_CurM]->GetName();
											if (!ModelName.Contains(FString("Light")))
											{
												bool IfInModel = TempBox.IsInsideOrOn(FVector(BaseNode, OtherHeight));
												if (IfInModel)
												{
													FVector FMin = TempBox.Min;
													FVector FMax = TempBox.Max;
													bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, RoomIDMapBoundary[AllRoomIDs[_CurRoom]]);
													if (ModelBoxIsUseful)
													{
														PointInModel = true;
														break;
													}
												}
											}
										}
										if (!PointInModel)
										{
											TempRoomCriticalPoints.Add(BaseNode);
											TempRoomCriticalPoints.Add(0.8*BoxCenter + 0.2*BaseNode);
										}
									}
								}

								if (TempRoomCriticalPoints.Num() == 0)
								{
									FVector2D LocalCenterNode;
									FPolygonAlg::LocateSuitableCenter(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], LocalCenterNode);
									TempRoomCriticalPoints.AddUnique(LocalCenterNode);
									TempWatchNode = FVector2D(0.0, 0.0);
								}


								for (int _CurP = 0; _CurP < TempRoomCriticalPoints.Num(); ++_CurP)
								{
									FPointPair _CurPair;
									_CurPair.RoutinePoint = FVector(TempRoomCriticalPoints[_CurP], OtherHeight);
									_CurPair.WatchPoint = FVector(TempWatchNode, OtherHeight);
									if (TempRoomCriticalPoints.Num() == 1)
									{
										_CurPair.ActionMarker = 1;
									}
									else
									{
										_CurPair.ActionMarker = 0;
									}
									TempPointPairs.Add(_CurPair);
								}
								if (TempPointPairs.Num() > 0)
								{
									FPathLine TempLine;
									TempLine.RoutinePoints = TempPointPairs;
									TempPointPairs.Empty();
									RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
								}
								HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
							}
							else if ((TempName == TEXT("主卫")) || (TempName == TEXT("客卫")) || (TempName == TEXT("卫生间")))
							{
								TArray<FVector2D> TempToiletCriticalPoints;
								FVector2D TempLocalCenter;
								bool LocateToiletSuccess = LocateCriticalPointsOfToilet(WorldContextObject,
									RoomIDMapBoundary[AllRoomIDs[_CurRoom]],
									AllWallCenters,
									AllRoomIDs[_CurRoom],
									TempToiletCriticalPoints,
									TempLocalCenter);
								if (LocateToiletSuccess)
								{
									for (int _CurP = 0; _CurP < TempToiletCriticalPoints.Num(); ++_CurP)
									{
										FPointPair _CurPair;
										_CurPair.RoutinePoint = FVector(TempToiletCriticalPoints[_CurP], OtherHeight);
										_CurPair.WatchPoint = FVector(TempLocalCenter, OtherHeight);
										if (_CurP == 0)
										{
											_CurPair.ActionMarker = 1;
										}
										else
										{
											_CurPair.ActionMarker = 0;
										}
										TempPointPairs.Add(_CurPair);
									}

									if (TempPointPairs.Num() > 0)
									{
										FPathLine TempLine;
										TempLine.RoutinePoints = TempPointPairs;
										TempPointPairs.Empty();
										RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
									}
									HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
								}
							}
							else if ((TempName == TEXT("生活阳台")) || (TempName == TEXT("休闲阳台")))
							{
								TArray<FVector2D> TempCriticalPoints;
								FVector2D  LocalRegionCenter;
								bool IsGetted = LocateTwoCriticalPointsOfBalcony(WorldContextObject, RoomIDMapBoundary[AllRoomIDs[_CurRoom]], AllRoomIDs[_CurRoom],
									TempCriticalPoints, LocalRegionCenter);

								if (IsGetted)
								{
									for (int _CurP = 0; _CurP < TempCriticalPoints.Num(); ++_CurP)
									{
										FPointPair _CurPair;
										_CurPair.RoutinePoint = FVector(TempCriticalPoints[_CurP], OtherHeight);
										_CurPair.WatchPoint = FVector(LocalRegionCenter, OtherHeight);
										_CurPair.ActionMarker = 0;
										TempPointPairs.Add(_CurPair);
									}

									if (TempPointPairs.Num() > 0)
									{
										FPathLine TempLine;
										TempLine.RoutinePoints = TempPointPairs;
										TempPointPairs.Empty();
										RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
									}
									HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
								}
							}
							else if (TempName == TEXT("厨房"))
							{
								TArray<FVector2D> TempKitchenCriticalPoints;
								FVector2D  KitchenRegionCenter;
								bool IsLocated = LocateCriticalPointsOfKitchen(WorldContextObject,
									RoomIDMapBoundary[AllRoomIDs[_CurRoom]],
									AllRoomIDs[_CurRoom],
									TempKitchenCriticalPoints,
									KitchenRegionCenter);
								if (IsLocated)
								{
									for (int _CurP = 0; _CurP < TempKitchenCriticalPoints.Num(); ++_CurP)
									{
										FPointPair _CurPair;
										_CurPair.RoutinePoint = FVector(TempKitchenCriticalPoints[_CurP], OtherHeight);
										_CurPair.WatchPoint = FVector(KitchenRegionCenter, OtherHeight);
										if (_CurP == 0)
										{
											_CurPair.ActionMarker = 1;
										}
										else
										{
											_CurPair.ActionMarker = 0;
										}
										TempPointPairs.Add(_CurPair);
									}

									if (TempPointPairs.Num() > 0)
									{
										FPathLine TempLine;
										TempLine.RoutinePoints = TempPointPairs;
										TempPointPairs.Empty();
										RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
									}
									HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
								}
							}
							else if ((TempName == TEXT("衣帽间")) || (TempName == TEXT("储藏间")))
							{
								FVector2D TempCenter;
								bool IsLocateCenter = FPolygonAlg::LocateSuitableCenter(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], TempCenter);
								if (IsLocateCenter)
								{
									TArray<FVector> DoorPoints;
									bool GetDoors = GetDoorsOfRegion(WorldContextObject, AllRoomIDs[_CurRoom], DoorPoints);
									if (GetDoors)
									{
										int NumOfDoors = DoorPoints.Num() / 8;
										if (NumOfDoors >= 1)
										{
											FVector2D TempFinalNode;
											for (int _CurDoor = 0; _CurDoor < NumOfDoors; ++_CurDoor)
											{
												FVector2D TempDoorCenter = FVector2D(0.25*(DoorPoints[0 + 8 * _CurDoor] + DoorPoints[1 + 8 * _CurDoor] + DoorPoints[2 + 8 * _CurDoor] + DoorPoints[3 + 8 * _CurDoor]));
												FVector2D TempSide1 = FVector2D(DoorPoints[1 + 8 * _CurDoor] - DoorPoints[0 + 8 * _CurDoor]);
												FVector2D TempSide2 = FVector2D(DoorPoints[2 + 8 * _CurDoor] - DoorPoints[0 + 8 * _CurDoor]);
												float TempLength1 = TempSide1.Size();
												float TempLength2 = TempSide2.Size();
												TempSide1.Normalize();
												TempSide2.Normalize();
												FVector2D TempBaseDir;
												if (TempLength1 > TempLength2)
												{
													TempBaseDir = TempSide2;
												}
												else
												{
													TempBaseDir = TempSide1;
												}

												FVector2D TempNode1 = TempDoorCenter + 25 * TempBaseDir;
												FVector2D TempNode2 = TempDoorCenter - 25 * TempBaseDir;
												if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], TempNode1))
												{
													TempFinalNode = TempNode1;
													break;
												}
												if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], TempNode2))
												{
													TempFinalNode = TempNode2;
													break;
												}
											}

											FPointPair _CurPair1;
											_CurPair1.RoutinePoint = FVector(TempFinalNode, OtherHeight);
											_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
											_CurPair1.ActionMarker = 1;
											TempPointPairs.Add(_CurPair1);


											if (TempPointPairs.Num() > 0)
											{
												FPathLine TempLine;
												TempLine.RoutinePoints = TempPointPairs;
												TempPointPairs.Empty();
												RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
											}

											HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
										}
									}
									else
									{
										int CurrentEdge = 0, NextEdge = 0;
										for (int _CurEdge = 0; _CurEdge < RoomIDMapBoundary[AllRoomIDs[_CurRoom]].Num(); ++_CurEdge)
										{
											if (_CurEdge == RoomIDMapBoundary[AllRoomIDs[_CurRoom]].Num() - 1)
											{
												NextEdge = 0;
											}
											else
											{
												NextEdge = _CurEdge + 1;
											}
											FVector2D TempMiddleP = 0.5*(RoomIDMapBoundary[AllRoomIDs[_CurRoom]][_CurEdge] + RoomIDMapBoundary[AllRoomIDs[_CurRoom]][NextEdge]);
											FVector2D EdgeDir = RoomIDMapBoundary[AllRoomIDs[_CurRoom]][NextEdge] - RoomIDMapBoundary[AllRoomIDs[_CurRoom]][_CurEdge];
											EdgeDir.Normalize();
											FVector2D RotatedEdgeDir = EdgeDir.GetRotated(90);
											FVector2D TempExtendP1 = TempMiddleP + 5 * RotatedEdgeDir;
											FVector2D TempExtendP2 = TempMiddleP - 5 * RotatedEdgeDir;
											for (int IRoom = 0; IRoom < AllRoomIDs.Num(); ++IRoom)
											{
												if (AllRoomIDs[IRoom] != AllRoomIDs[_CurRoom])
												{
													if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[IRoom]], TempExtendP1))
													{
														FPointPair _CurPair1;
														_CurPair1.RoutinePoint = FVector(TempExtendP1 - 10 * RotatedEdgeDir, OtherHeight);
														_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
														_CurPair1.ActionMarker = 1;
														TempPointPairs.Add(_CurPair1);
														HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
														break;
													}

													if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[IRoom]], TempExtendP2))
													{
														FPointPair _CurPair1;
														_CurPair1.RoutinePoint = FVector(TempExtendP2 + 10 * RotatedEdgeDir, OtherHeight);
														_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
														_CurPair1.ActionMarker = 1;
														TempPointPairs.Add(_CurPair1);


														HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
														break;
													}
												}
											}
										}

										if (TempPointPairs.Num() > 0)
										{
											FPathLine TempLine;
											TempLine.RoutinePoints = TempPointPairs;
											TempPointPairs.Empty();
											RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
										}
									}

								}
							}
							else
							{
								FVector2D TempCenter;
								bool IsLocateCenter = FPolygonAlg::LocateSuitableCenter(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], TempCenter);
								if (IsLocateCenter)
								{
									TArray<FVector> DoorPoints;
									bool GetDoors = GetDoorsOfRegion(WorldContextObject, AllRoomIDs[_CurRoom], DoorPoints);
									if (GetDoors)
									{
										int NumOfDoors = DoorPoints.Num() / 8;
										if (NumOfDoors >= 1)
										{
											FVector2D TempDoorCenter = FVector2D(0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]));
											FVector2D TempDir = TempCenter - TempDoorCenter;
											FVector2D TempNode1 = TempDoorCenter + 0.25*TempDir;
											FVector2D TempNode2 = 0.5*(TempDoorCenter + TempCenter);
											FPointPair _CurPair1;
											_CurPair1.RoutinePoint = FVector(TempNode1, OtherHeight);
											_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
											_CurPair1.ActionMarker = 1;
											TempPointPairs.Add(_CurPair1);
											FPointPair _CurPair2;
											_CurPair2.RoutinePoint = FVector(TempNode2, OtherHeight);
											_CurPair2.WatchPoint = FVector(TempCenter, OtherHeight);
											_CurPair2.ActionMarker = 0;
											TempPointPairs.Add(_CurPair2);

											if (TempPointPairs.Num() > 0)
											{
												FPathLine TempLine;
												TempLine.RoutinePoints = TempPointPairs;
												TempPointPairs.Empty();
												RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
											}

											HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
										}
										else
										{
											FPointPair _CurPair1;
											_CurPair1.RoutinePoint = FVector(TempCenter, OtherHeight);
											_CurPair1.WatchPoint = FVector(0.0, 0.0, OtherHeight);
											_CurPair1.ActionMarker = 1;
											TempPointPairs.Add(_CurPair1);

											if (TempPointPairs.Num() > 0)
											{
												FPathLine TempLine;
												TempLine.RoutinePoints = TempPointPairs;
												TempPointPairs.Empty();
												RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
											}

											HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
										}
									}
								}
							}
						}
					}
				}
				////////////////////////修正///////////////////////////////
				if (NeedChangeDir)
				{
					for (int _CurLine = 0; _CurLine < AllPathLines.Num(); ++_CurLine)
					{
						if (_CurLine == 0)
						{
							TArray<FPointPair> TempPointPairArr = AllPathLines[_CurLine].RoutinePoints;
							if (TempPointPairArr.Num() > 1)
							{
								AllPathLines[_CurLine].RoutinePoints[0].WatchPoint = TempPointPairArr[1].RoutinePoint;
							}
							break;
						}
					}
				}
			}
		}
		else
		{
			FString EntranceRoomName = RoomIDMapName[GlobaleEntranceRoomID];
			TArray<int> HasCalculatedRoomIDs;
			TArray<FPointPair> TempPointPairs;
			if (EntranceRoomName == TEXT("厨房"))
			{
				TArray<FVector2D> TempKitchenCriticalPoints;
				FVector2D  KitchenRegionCenter;
				bool IsLocated = LocateCriticalPointsOfKitchen(WorldContextObject,
					RoomIDMapBoundary[GlobaleEntranceRoomID],
					GlobaleEntranceRoomID,
					TempKitchenCriticalPoints,
					KitchenRegionCenter);
				if (IsLocated)
				{
					for (int _CurP = 0; _CurP < TempKitchenCriticalPoints.Num(); ++_CurP)
					{
						FPointPair _CurPair;
						_CurPair.RoutinePoint = FVector(TempKitchenCriticalPoints[_CurP], OtherHeight);
						_CurPair.WatchPoint = FVector(KitchenRegionCenter, OtherHeight);
						if (_CurP == 0)
						{
							_CurPair.ActionMarker = 1;
						}
						else
						{
							_CurPair.ActionMarker = 0;
						}
						TempPointPairs.Add(_CurPair);
					}

					if (TempPointPairs.Num() > 0)
					{
						FPathLine TempLine;
						TempLine.RoutinePoints = TempPointPairs;
						TempPointPairs.Empty();
						RoomIDMapPathLine.Add(GlobaleEntranceRoomID, TempLine);
					}
					HasCalculatedRoomIDs.AddUnique(GlobaleEntranceRoomID);
				}
			}
			else if ((EntranceRoomName == TEXT("主卫")) || (EntranceRoomName == TEXT("客卫")))
			{
				TArray<FVector2D> TempToiletCriticalPoints;
				FVector2D TempLocalCenter;
				bool LocateToiletSuccess = LocateCriticalPointsOfToilet(WorldContextObject,
					RoomIDMapBoundary[GlobaleEntranceRoomID],
					AllWallCenters,
					GlobaleEntranceRoomID,
					TempToiletCriticalPoints,
					TempLocalCenter);
				if (LocateToiletSuccess)
				{
					for (int _CurP = 0; _CurP < TempToiletCriticalPoints.Num(); ++_CurP)
					{
						FPointPair _CurPair;
						_CurPair.RoutinePoint = FVector(TempToiletCriticalPoints[_CurP], OtherHeight);
						_CurPair.WatchPoint = FVector(TempLocalCenter, OtherHeight);
						if (_CurP == 0)
						{
							_CurPair.ActionMarker = 1;
						}
						else
						{
							_CurPair.ActionMarker = 0;
						}
						TempPointPairs.Add(_CurPair);
					}

					if (TempPointPairs.Num() > 0)
					{
						FPathLine TempLine;
						TempLine.RoutinePoints = TempPointPairs;
						TempPointPairs.Empty();
						RoomIDMapPathLine.Add(GlobaleEntranceRoomID, TempLine);
					}
					HasCalculatedRoomIDs.AddUnique(GlobaleEntranceRoomID);
				}
			}
			else if ((EntranceRoomName == TEXT("衣帽间")) || (EntranceRoomName == TEXT("储藏间")))
			{
				FVector2D TempCenter;
				bool IsLocateCenter = FPolygonAlg::LocateSuitableCenter(RoomIDMapBoundary[GlobaleEntranceRoomID], TempCenter);
				if (IsLocateCenter)
				{
					TArray<FVector> DoorPoints;
					bool GetDoors = GetDoorsOfRegion(WorldContextObject, GlobaleEntranceRoomID, DoorPoints);
					if (GetDoors)
					{
						int NumOfDoors = DoorPoints.Num() / 8;
						if (NumOfDoors >= 1)
						{
							FVector2D TempFinalNode;
							for (int _CurDoor = 0; _CurDoor < NumOfDoors; ++_CurDoor)
							{
								FVector2D TempDoorCenter = FVector2D(0.25*(DoorPoints[0 + 8 * _CurDoor] + DoorPoints[1 + 8 * _CurDoor] + DoorPoints[2 + 8 * _CurDoor] + DoorPoints[3 + 8 * _CurDoor]));
								FVector2D TempSide1 = FVector2D(DoorPoints[1 + 8 * _CurDoor] - DoorPoints[0 + 8 * _CurDoor]);
								FVector2D TempSide2 = FVector2D(DoorPoints[2 + 8 * _CurDoor] - DoorPoints[0 + 8 * _CurDoor]);
								float TempLength1 = TempSide1.Size();
								float TempLength2 = TempSide2.Size();
								TempSide1.Normalize();
								TempSide2.Normalize();
								FVector2D TempBaseDir;
								if (TempLength1 > TempLength2)
								{
									TempBaseDir = TempSide2;
								}
								else
								{
									TempBaseDir = TempSide1;
								}

								FVector2D TempNode1 = TempDoorCenter + 25 * TempBaseDir;
								FVector2D TempNode2 = TempDoorCenter - 25 * TempBaseDir;
								if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[GlobaleEntranceRoomID], TempNode1))
								{
									TempFinalNode = TempNode1;
									break;
								}
								if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[GlobaleEntranceRoomID], TempNode2))
								{
									TempFinalNode = TempNode2;
									break;
								}
							}

							FPointPair _CurPair1;
							_CurPair1.RoutinePoint = FVector(TempFinalNode, OtherHeight);
							_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
							_CurPair1.ActionMarker = 1;
							TempPointPairs.Add(_CurPair1);


							if (TempPointPairs.Num() > 0)
							{
								FPathLine TempLine;
								TempLine.RoutinePoints = TempPointPairs;
								TempPointPairs.Empty();
								RoomIDMapPathLine.Add(GlobaleEntranceRoomID, TempLine);
							}

							HasCalculatedRoomIDs.AddUnique(GlobaleEntranceRoomID);
						}
					}
					else
					{
						int CurrentEdge = 0, NextEdge = 0;
						for (int _CurEdge = 0; _CurEdge < RoomIDMapBoundary[GlobaleEntranceRoomID].Num(); ++_CurEdge)
						{
							if (_CurEdge == RoomIDMapBoundary[GlobaleEntranceRoomID].Num() - 1)
							{
								NextEdge = 0;
							}
							else
							{
								NextEdge = _CurEdge + 1;
							}
							FVector2D TempMiddleP = 0.5*(RoomIDMapBoundary[GlobaleEntranceRoomID][_CurEdge] + RoomIDMapBoundary[GlobaleEntranceRoomID][NextEdge]);
							FVector2D EdgeDir = RoomIDMapBoundary[GlobaleEntranceRoomID][NextEdge] - RoomIDMapBoundary[GlobaleEntranceRoomID][_CurEdge];
							EdgeDir.Normalize();
							FVector2D RotatedEdgeDir = EdgeDir.GetRotated(90);
							FVector2D TempExtendP1 = TempMiddleP + 5 * RotatedEdgeDir;
							FVector2D TempExtendP2 = TempMiddleP - 5 * RotatedEdgeDir;
							for (int IRoom = 0; IRoom < AllRoomIDs.Num(); ++IRoom)
							{
								if (AllRoomIDs[IRoom] != GlobaleEntranceRoomID)
								{
									if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[IRoom]], TempExtendP1))
									{
										FPointPair _CurPair1;
										_CurPair1.RoutinePoint = FVector(TempExtendP1 - 10 * RotatedEdgeDir, OtherHeight);
										_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
										_CurPair1.ActionMarker = 1;
										TempPointPairs.Add(_CurPair1);
										HasCalculatedRoomIDs.AddUnique(GlobaleEntranceRoomID);
										break;
									}

									if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[IRoom]], TempExtendP2))
									{
										FPointPair _CurPair1;
										_CurPair1.RoutinePoint = FVector(TempExtendP2 + 10 * RotatedEdgeDir, OtherHeight);
										_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
										_CurPair1.ActionMarker = 1;
										TempPointPairs.Add(_CurPair1);
										HasCalculatedRoomIDs.AddUnique(GlobaleEntranceRoomID);
										break;
									}
								}
							}
						}

						if (TempPointPairs.Num() > 0)
						{
							FPathLine TempLine;
							TempLine.RoutinePoints = TempPointPairs;
							TempPointPairs.Empty();
							RoomIDMapPathLine.Add(GlobaleEntranceRoomID, TempLine);
						}
					}
				}
			}
			else if ((EntranceRoomName == TEXT("主卧")) || (EntranceRoomName == TEXT("次卧")) || (EntranceRoomName == TEXT("老人房")) || (EntranceRoomName == TEXT("书房")) || (EntranceRoomName == TEXT("多功能房"))
				|| (EntranceRoomName == TEXT("儿童房")) || (EntranceRoomName == TEXT("榻榻米房")))
			{
				TArray<FVector2D> TempRoomCriticalPoints, MaxLocalRegion;
				bool IsSuccess = FPolygonAlg::LocateMaxLocalRegionOfRoom(RoomIDMapBoundary[GlobaleEntranceRoomID], MaxLocalRegion);
				if (IsSuccess)
				{
					FVector2D TempCenterP(0.0, 0.0);
					for (int _CurJ = 0; _CurJ < MaxLocalRegion.Num(); ++_CurJ)
					{
						TempCenterP = TempCenterP + MaxLocalRegion[_CurJ];
					}

					TempCenterP = TempCenterP / MaxLocalRegion.Num();
					FVector2D TempNode1 = 0.5*(GlobaleEntranceDoorCenter + TempCenterP);
					if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[GlobaleEntranceRoomID], TempNode1))
					{
						TempRoomCriticalPoints.AddUnique(TempNode1);
					}
					TempRoomCriticalPoints.AddUnique(TempCenterP);

					for (int _CurP = 0; _CurP < TempRoomCriticalPoints.Num(); ++_CurP)
					{
						FPointPair _CurPair;
						_CurPair.RoutinePoint = FVector(TempRoomCriticalPoints[_CurP], OtherHeight);
						_CurPair.WatchPoint = FVector(TempCenterP, OtherHeight);
						if (TempRoomCriticalPoints.Num() == 1)
						{
							_CurPair.ActionMarker = 1;
						}
						else
						{
							_CurPair.ActionMarker = 0;
						}
						TempPointPairs.Add(_CurPair);
					}
					if (TempPointPairs.Num() > 0)
					{
						FPathLine TempLine;
						TempLine.RoutinePoints = TempPointPairs;
						TempPointPairs.Empty();
						RoomIDMapPathLine.Add(GlobaleEntranceRoomID, TempLine);
					}
					HasCalculatedRoomIDs.AddUnique(GlobaleEntranceRoomID);
				}
			}

		}
		/////////////////////计算剩余空间//////////////////////
		int NumOfIter = 0;
		while (AllRoomIDs.Num() != HasCalculatedRoomIDs.Num())
		{
			NumOfIter++;
			for (int _CurRoom = 0; _CurRoom < AllRoomIDs.Num(); ++_CurRoom)
			{
				if (!HasCalculatedRoomIDs.Contains(AllRoomIDs[_CurRoom]))
				{
					FString TempName = RoomIDMapName[AllRoomIDs[_CurRoom]];
					if ((TempName == TEXT("主卧")) || (TempName == TEXT("次卧")) || (TempName == TEXT("儿童房")) || (TempName == TEXT("老人房")) ||
						(TempName == TEXT("榻榻米房")) || (TempName == TEXT("多功能房")) || (TempName == TEXT("书房"))
						|| (TempName == TEXT("客人房")) || (TempName == TEXT("健身房")))
					{
						TArray<FVector2D> TempRoomCriticalPoints, MaxLocalRegion;
						FVector2D TempWatchNode;
						bool PointInModel = false;
						bool IsSuccess = FPolygonAlg::LocateMaxLocalRegionOfRoom(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], MaxLocalRegion);
						if (IsSuccess)
						{
							FVector2D TempCenterP(0.0, 0.0);
							for (int _CurJ = 0; _CurJ < MaxLocalRegion.Num(); ++_CurJ)
							{
								TempCenterP = TempCenterP + MaxLocalRegion[_CurJ];
							}
							TempCenterP = TempCenterP / MaxLocalRegion.Num();
							TArray<FVector2D> ShrinkPoints;
							for (int IP = 0; IP < MaxLocalRegion.Num(); ++IP)
							{
								ShrinkPoints.Add(ShrinkRatio*MaxLocalRegion[IP] + (1 - ShrinkRatio)*TempCenterP);
							}
							FVector2D Node1 = 0.5*(ShrinkPoints[0] + ShrinkPoints[1]);
							FVector2D Node2 = 0.5*(ShrinkPoints[1] + ShrinkPoints[2]);
							FVector2D Node3 = 0.5*(ShrinkPoints[2] + ShrinkPoints[3]);
							FVector2D Node4 = 0.5*(ShrinkPoints[3] + ShrinkPoints[0]);

							TArray<AFurnitureModelActor*> ModelsOfRoom;
							FindModelsOfRoom(WorldContextObject, RoomIDMapBoundary[AllRoomIDs[_CurRoom]], ModelsOfRoom);
							AFurnitureModelActor* FindFur = nullptr;
							bool FindModel = false;
							for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
							{
								AFurnitureModelActor* TempFur = ModelsOfRoom[_CurM];
								int TempID = 0;
								TempFur->GetModelCategory(TempID);
								if ((TempID == 5009) || (TempID == 5010) || (TempID == 5125))
								{
									FindFur = TempFur;
									FindModel = true;
									break;
								}
							}



							TArray<AHouseCustomActor*> CustomModelsOfRoom;
							FindCustomModelsOfRoom(WorldContextObject, RoomIDMapBoundary[AllRoomIDs[_CurRoom]], CustomModelsOfRoom);


							if (FindModel)
							{
								FBox TempBox = FindFur->GetComponentsBoundingBox(true);
								FVector FMin = TempBox.Min;
								FVector FMax = TempBox.Max;
								FVector2D P1(FMin.X, FMin.Y);
								FVector2D P2(FMax.X, FMin.Y);
								FVector2D P3(FMax.X, FMax.Y);
								FVector2D P4(FMin.X, FMax.Y);
								FVector2D BoxCenter = 0.25*(P1 + P2 + P3 + P4);
								TempWatchNode = BoxCenter;
								float Dis1 = FVector2D::Distance(Node1, BoxCenter);
								float Dis2 = FVector2D::Distance(Node2, BoxCenter);
								float Dis3 = FVector2D::Distance(Node3, BoxCenter);
								float Dis4 = FVector2D::Distance(Node4, BoxCenter);
								FVector2D BaseNode = Node1;
								if ((Dis2 >= Dis1) && (Dis2 >= Dis3) && (Dis2 >= Dis4))
								{
									BaseNode = Node2;
								}
								else if ((Dis3 >= Dis1) && (Dis3 >= Dis2) && (Dis3 >= Dis4))
								{
									BaseNode = Node3;
								}
								else if ((Dis4 >= Dis1) && (Dis4 >= Dis2) && (Dis4 >= Dis3))
								{
									BaseNode = Node4;
								}

								for (int _CurM = 0; _CurM < CustomModelsOfRoom.Num(); ++_CurM)
								{
									FBox TempBox = CustomModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
									FString ModelName = CustomModelsOfRoom[_CurM]->GetName();
									if (!ModelName.Contains(FString("Light")))
									{
										bool IfInModel = TempBox.IsInsideOrOn(FVector(BaseNode, OtherHeight));
										if (IfInModel)
										{
											FVector FMin = TempBox.Min;
											FVector FMax = TempBox.Max;
											float TempModelZ = FMax.Z - FMin.Z;
											if (TempModelZ >= HeightBound)
											{
												bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, RoomIDMapBoundary[AllRoomIDs[_CurRoom]]);
												if (ModelBoxIsUseful)
												{
													PointInModel = true;
													break;
												}
											}
										}
									}
								}

								for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
								{
									FBox TempBox = ModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
									FString ModelName = ModelsOfRoom[_CurM]->GetName();
									if (!ModelName.Contains(FString("Light")))
									{
										bool IfInModel = TempBox.IsInsideOrOn(FVector(BaseNode, OtherHeight));
										if (IfInModel)
										{
											FVector FMin = TempBox.Min;
											FVector FMax = TempBox.Max;
											float TempModelZ = FMax.Z - FMin.Z;
											if (TempModelZ >= HeightBound)
											{
												bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, RoomIDMapBoundary[AllRoomIDs[_CurRoom]]);
												if (ModelBoxIsUseful)
												{
													PointInModel = true;
													break;
												}
											}
										}
									}
								}
								if (!PointInModel)
								{
									TempRoomCriticalPoints.Add(BaseNode);
									TempRoomCriticalPoints.Add(0.8*BoxCenter + 0.2*BaseNode);
								}
							}
						}

						if (TempRoomCriticalPoints.Num() == 0)
						{
							FVector2D LocalCenterNode;
							FPolygonAlg::LocateSuitableCenter(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], LocalCenterNode);
							TempRoomCriticalPoints.AddUnique(LocalCenterNode);
							TempWatchNode = FVector2D(0.0, 0.0);
						}


						for (int _CurP = 0; _CurP < TempRoomCriticalPoints.Num(); ++_CurP)
						{
							FPointPair _CurPair;
							_CurPair.RoutinePoint = FVector(TempRoomCriticalPoints[_CurP], OtherHeight);
							_CurPair.WatchPoint = FVector(TempWatchNode, OtherHeight);
							if (TempRoomCriticalPoints.Num() == 1)
							{
								_CurPair.ActionMarker = 1;
							}
							else
							{
								_CurPair.ActionMarker = 0;
							}
							TempPointPairs.Add(_CurPair);
						}
						if (TempPointPairs.Num() > 0)
						{
							FPathLine TempLine;
							TempLine.RoutinePoints = TempPointPairs;
							TempPointPairs.Empty();
							RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
						}
						HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
					}
					else if ((TempName == TEXT("主卫")) || (TempName == TEXT("客卫")) || (TempName == TEXT("卫生间")))
					{
						TArray<FVector2D> TempToiletCriticalPoints;
						FVector2D TempLocalCenter;
						bool LocateToiletSuccess = LocateCriticalPointsOfToilet(WorldContextObject,
							RoomIDMapBoundary[AllRoomIDs[_CurRoom]],
							AllWallCenters,
							AllRoomIDs[_CurRoom],
							TempToiletCriticalPoints,
							TempLocalCenter);
						if (LocateToiletSuccess)
						{
							for (int _CurP = 0; _CurP < TempToiletCriticalPoints.Num(); ++_CurP)
							{
								FPointPair _CurPair;
								_CurPair.RoutinePoint = FVector(TempToiletCriticalPoints[_CurP], OtherHeight);
								_CurPair.WatchPoint = FVector(TempLocalCenter, OtherHeight);
								if (_CurP == 0)
								{
									_CurPair.ActionMarker = 1;
								}
								else
								{
									_CurPair.ActionMarker = 0;
								}
								TempPointPairs.Add(_CurPair);
							}

							if (TempPointPairs.Num() > 0)
							{
								FPathLine TempLine;
								TempLine.RoutinePoints = TempPointPairs;
								TempPointPairs.Empty();
								RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
							}
							HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
						}
					}
					else if ((TempName == TEXT("生活阳台")) || (TempName == TEXT("休闲阳台")))
					{
						TArray<FVector2D> TempCriticalPoints;
						FVector2D  LocalRegionCenter;
						bool IsGetted = LocateTwoCriticalPointsOfBalcony(WorldContextObject, RoomIDMapBoundary[AllRoomIDs[_CurRoom]], AllRoomIDs[_CurRoom],
							TempCriticalPoints, LocalRegionCenter);
						if (IsGetted)
						{
							for (int _CurP = 0; _CurP < TempCriticalPoints.Num(); ++_CurP)
							{
								FPointPair _CurPair;
								_CurPair.RoutinePoint = FVector(TempCriticalPoints[_CurP], OtherHeight);
								_CurPair.WatchPoint = FVector(LocalRegionCenter, OtherHeight);
								_CurPair.ActionMarker = 0;
								TempPointPairs.Add(_CurPair);
							}

							if (TempPointPairs.Num() > 0)
							{
								FPathLine TempLine;
								TempLine.RoutinePoints = TempPointPairs;
								TempPointPairs.Empty();
								RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
							}
							HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
						}
					}
					else if (TempName == TEXT("厨房"))
					{
						TArray<FVector2D> TempKitchenCriticalPoints;
						FVector2D  KitchenRegionCenter;
						bool IsLocated = LocateCriticalPointsOfKitchen(WorldContextObject,
							RoomIDMapBoundary[AllRoomIDs[_CurRoom]],
							AllRoomIDs[_CurRoom],
							TempKitchenCriticalPoints,
							KitchenRegionCenter);
						if (IsLocated)
						{
							for (int _CurP = 0; _CurP < TempKitchenCriticalPoints.Num(); ++_CurP)
							{
								FPointPair _CurPair;
								_CurPair.RoutinePoint = FVector(TempKitchenCriticalPoints[_CurP], OtherHeight);
								_CurPair.WatchPoint = FVector(KitchenRegionCenter, OtherHeight);
								if (_CurP == 0)
								{
									_CurPair.ActionMarker = 1;
								}
								else
								{
									_CurPair.ActionMarker = 0;
								}
								TempPointPairs.Add(_CurPair);
							}

							if (TempPointPairs.Num() > 0)
							{
								FPathLine TempLine;
								TempLine.RoutinePoints = TempPointPairs;
								TempPointPairs.Empty();
								RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
							}
							HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
						}
					}
					else if ((TempName == TEXT("衣帽间")) || (TempName == TEXT("储藏间")))
					{
						FVector2D TempCenter;
						bool IsLocateCenter = FPolygonAlg::LocateSuitableCenter(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], TempCenter);
						if (IsLocateCenter)
						{
							TArray<FVector> DoorPoints;
							bool GetDoors = GetDoorsOfRegion(WorldContextObject, AllRoomIDs[_CurRoom], DoorPoints);
							if (GetDoors)
							{
								int NumOfDoors = DoorPoints.Num() / 8;
								if (NumOfDoors >= 1)
								{
									FVector2D TempFinalNode;
									for (int _CurDoor = 0; _CurDoor < NumOfDoors; ++_CurDoor)
									{
										FVector2D TempDoorCenter = FVector2D(0.25*(DoorPoints[0 + 8 * _CurDoor] + DoorPoints[1 + 8 * _CurDoor] + DoorPoints[2 + 8 * _CurDoor] + DoorPoints[3 + 8 * _CurDoor]));
										FVector2D TempSide1 = FVector2D(DoorPoints[1 + 8 * _CurDoor] - DoorPoints[0 + 8 * _CurDoor]);
										FVector2D TempSide2 = FVector2D(DoorPoints[2 + 8 * _CurDoor] - DoorPoints[0 + 8 * _CurDoor]);
										float TempLength1 = TempSide1.Size();
										float TempLength2 = TempSide2.Size();
										TempSide1.Normalize();
										TempSide2.Normalize();
										FVector2D TempBaseDir;
										if (TempLength1 > TempLength2)
										{
											TempBaseDir = TempSide2;
										}
										else
										{
											TempBaseDir = TempSide1;
										}

										FVector2D TempNode1 = TempDoorCenter + 25 * TempBaseDir;
										FVector2D TempNode2 = TempDoorCenter - 25 * TempBaseDir;
										if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], TempNode1))
										{
											TempFinalNode = TempNode1;
											break;
										}
										if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], TempNode2))
										{
											TempFinalNode = TempNode2;
											break;
										}
									}

									FPointPair _CurPair1;
									_CurPair1.RoutinePoint = FVector(TempFinalNode, OtherHeight);
									_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
									_CurPair1.ActionMarker = 1;
									TempPointPairs.Add(_CurPair1);


									if (TempPointPairs.Num() > 0)
									{
										FPathLine TempLine;
										TempLine.RoutinePoints = TempPointPairs;
										TempPointPairs.Empty();
										RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
									}

									HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
								}
							}
							else
							{
								int CurrentEdge = 0, NextEdge = 0;
								for (int _CurEdge = 0; _CurEdge < RoomIDMapBoundary[AllRoomIDs[_CurRoom]].Num(); ++_CurEdge)
								{
									if (_CurEdge == RoomIDMapBoundary[AllRoomIDs[_CurRoom]].Num() - 1)
									{
										NextEdge = 0;
									}
									else
									{
										NextEdge = _CurEdge + 1;
									}
									FVector2D TempMiddleP = 0.5*(RoomIDMapBoundary[AllRoomIDs[_CurRoom]][_CurEdge] + RoomIDMapBoundary[AllRoomIDs[_CurRoom]][NextEdge]);
									FVector2D EdgeDir = RoomIDMapBoundary[AllRoomIDs[_CurRoom]][NextEdge] - RoomIDMapBoundary[AllRoomIDs[_CurRoom]][_CurEdge];
									EdgeDir.Normalize();
									FVector2D RotatedEdgeDir = EdgeDir.GetRotated(90);
									FVector2D TempExtendP1 = TempMiddleP + 5 * RotatedEdgeDir;
									FVector2D TempExtendP2 = TempMiddleP - 5 * RotatedEdgeDir;
									for (int IRoom = 0; IRoom < AllRoomIDs.Num(); ++IRoom)
									{
										if (AllRoomIDs[IRoom] != AllRoomIDs[_CurRoom])
										{
											if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[IRoom]], TempExtendP1))
											{
												FPointPair _CurPair1;
												_CurPair1.RoutinePoint = FVector(TempExtendP1 - 10 * RotatedEdgeDir, OtherHeight);
												_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
												_CurPair1.ActionMarker = 1;
												TempPointPairs.Add(_CurPair1);
												HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
												break;
											}

											if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[IRoom]], TempExtendP2))
											{
												FPointPair _CurPair1;
												_CurPair1.RoutinePoint = FVector(TempExtendP2 + 10 * RotatedEdgeDir, OtherHeight);
												_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
												_CurPair1.ActionMarker = 1;
												TempPointPairs.Add(_CurPair1);


												HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
												break;
											}
										}
									}
								}

								if (TempPointPairs.Num() > 0)
								{
									FPathLine TempLine;
									TempLine.RoutinePoints = TempPointPairs;
									TempPointPairs.Empty();
									RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
								}
							}

						}
					}
					else if (TempName == TEXT("客厅"))
					{
						TArray<FVector2D> PathPoints;
						FVector2D LocalWatchPoint;
						bool IsLocatedLiving = LocateCriticalPointsOfSpecialLivingOrDining(WorldContextObject, RoomIDMapBoundary[AllRoomIDs[_CurRoom]], AllRoomIDs[_CurRoom],
							PathPoints, LocalWatchPoint, true);
						if (IsLocatedLiving)
						{
							for (int _CurP = 0; _CurP < PathPoints.Num(); ++_CurP)
							{
								FPointPair _CurPair;
								_CurPair.RoutinePoint = FVector(PathPoints[_CurP], LivingOrDiningHeight);
								_CurPair.WatchPoint = FVector(LocalWatchPoint, LivingOrDiningHeight);
								if (PathPoints.Num() == 1)
								{
									_CurPair.ActionMarker = 1;
								}
								else
								{
									_CurPair.ActionMarker = 0;
								}
								TempPointPairs.Add(_CurPair);
							}
							if (TempPointPairs.Num() > 0)
							{
								FPathLine TempLine;
								TempLine.RoutinePoints = TempPointPairs;
								TempPointPairs.Empty();
								RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
							}
							HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
						}
					}
					else
					{
						FVector2D TempCenter;
						bool IsLocateCenter = FPolygonAlg::LocateSuitableCenter(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], TempCenter);
						if (IsLocateCenter)
						{
							TArray<FVector> DoorPoints;
							bool GetDoors = GetDoorsOfRegion(WorldContextObject, AllRoomIDs[_CurRoom], DoorPoints);
							if (GetDoors)
							{
								int NumOfDoors = DoorPoints.Num() / 8;
								if (NumOfDoors >= 1)
								{
									FVector2D TempDoorCenter = FVector2D(0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]));
									if (FPolygonAlg::JudgePointInPolygon(RoomIDMapBoundary[AllRoomIDs[_CurRoom]], TempDoorCenter))
									{
										FVector2D TempDir = TempCenter - TempDoorCenter;
										TempDir.Normalize();
										FVector2D TempNode1 = TempDoorCenter + 25 * TempDir;
										FVector2D TempNode2 = 0.5*(TempDoorCenter + TempCenter);
										FPointPair _CurPair1;
										_CurPair1.RoutinePoint = FVector(TempNode1, OtherHeight);
										_CurPair1.WatchPoint = FVector(TempCenter, OtherHeight);
										_CurPair1.ActionMarker = 1;
										TempPointPairs.Add(_CurPair1);
										FPointPair _CurPair2;
										_CurPair2.RoutinePoint = FVector(TempNode2, OtherHeight);
										_CurPair2.WatchPoint = FVector(TempCenter, OtherHeight);
										_CurPair2.ActionMarker = 0;
										TempPointPairs.Add(_CurPair2);

										if (TempPointPairs.Num() > 0)
										{
											FPathLine TempLine;
											TempLine.RoutinePoints = TempPointPairs;
											TempPointPairs.Empty();
											RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
										}

										HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
									}

								}
								else
								{
									FPointPair _CurPair1;
									_CurPair1.RoutinePoint = FVector(TempCenter, OtherHeight);
									_CurPair1.WatchPoint = FVector(0.0, 0.0, OtherHeight);
									_CurPair1.ActionMarker = 1;
									TempPointPairs.Add(_CurPair1);

									if (TempPointPairs.Num() > 0)
									{
										FPathLine TempLine;
										TempLine.RoutinePoints = TempPointPairs;
										TempPointPairs.Empty();
										RoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], TempLine);
									}

									HasCalculatedRoomIDs.AddUnique(AllRoomIDs[_CurRoom]);
								}
							}
						}
					}
				}
			}
			if (NumOfIter >= MaxNumIter)
			{
				return false;
			}
		}
	}
	/////////////////////重新排序路线//////////////////////
	TMap<int, FPathLine> LocalRoomIDMapPathLine;
	TArray<int> HasCollectedRooms;
	bool FilterFirstRoom = false;
	FPathLine ResultLine;
	if (RoomIDMapPathLine.Contains(GlobaleEntranceRoomID))
	{
		FPathLine StartLine = RoomIDMapPathLine[GlobaleEntranceRoomID];
		if (RoomIDMapName.Contains(GlobaleEntranceRoomID))
		{
			FString FirstRoomName = RoomIDMapName[GlobaleEntranceRoomID];
			if ((FirstRoomName.Contains(TEXT("客厅"))) || (FirstRoomName.Contains(TEXT("餐厅"))))
			{
				FilterFirstRoom = FilterLivingOrDiningPathPoints(WorldContextObject, StartLine, ResultLine, RoomIDMapBoundary[GlobaleEntranceRoomID]);
			}
			else
			{
				FilterFirstRoom = FilterRoomPathPoints(WorldContextObject, StartLine, ResultLine, RoomIDMapBoundary[GlobaleEntranceRoomID]);
			}
		}

		if (FilterFirstRoom)
		{
			LocalRoomIDMapPathLine.Add(GlobaleEntranceRoomID, ResultLine);
		}
		else
		{
			LocalRoomIDMapPathLine.Add(GlobaleEntranceRoomID, StartLine);
		}

		HasCollectedRooms.AddUnique(GlobaleEntranceRoomID);
	}

	TArray<FString> AllNames;
	AllNames.Add(TEXT("客厅"));
	AllNames.Add(TEXT("餐厅"));
	AllNames.Add(TEXT("主卧"));
	AllNames.Add(TEXT("次卧"));
	AllNames.Add(TEXT("儿童房"));
	AllNames.Add(TEXT("老人房"));
	AllNames.Add(TEXT("书房"));
	AllNames.Add(TEXT("榻榻米房"));
	AllNames.Add(TEXT("衣帽间"));
	AllNames.Add(TEXT("储藏间"));
	AllNames.Add(TEXT("起居室"));
	AllNames.Add(TEXT("多功能房"));
	AllNames.Add(TEXT("厨房"));
	AllNames.Add(TEXT("生活阳台"));
	AllNames.Add(TEXT("休闲阳台"));
	AllNames.Add(TEXT("主卫"));
	AllNames.Add(TEXT("客卫"));

	NumOfIter = 0;
	while (LocalRoomIDMapPathLine.Num() != AllRoomIDs.Num())
	{
		NumOfIter++;
		for (int _CurName = 0; _CurName < AllNames.Num(); ++_CurName)
		{
			FString CurrentName = AllNames[_CurName];
			for (int _CurRoom = 0; _CurRoom < AllRoomIDs.Num(); ++_CurRoom)
			{
				if (!HasCollectedRooms.Contains(AllRoomIDs[_CurRoom]))
				{
					if (RoomIDMapName.Contains(AllRoomIDs[_CurRoom]))
					{
						FString CurrentRoomNameStr = RoomIDMapName[AllRoomIDs[_CurRoom]];
						if (CurrentRoomNameStr.Contains(CurrentName))
						{
							bool FilterOtherRoom = false;
							FPathLine MapLine = RoomIDMapPathLine[AllRoomIDs[_CurRoom]];

							if ((CurrentRoomNameStr.Contains(TEXT("客厅"))) || (CurrentRoomNameStr.Contains(TEXT("餐厅"))))
							{
								FilterOtherRoom = FilterLivingOrDiningPathPoints(WorldContextObject, MapLine, ResultLine, RoomIDMapBoundary[AllRoomIDs[_CurRoom]]);
							}
							else
							{
								FilterOtherRoom = FilterRoomPathPoints(WorldContextObject, MapLine, ResultLine, RoomIDMapBoundary[AllRoomIDs[_CurRoom]]);
							}
							if (FilterOtherRoom)
							{
								LocalRoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], ResultLine);
							}
							else
							{
								LocalRoomIDMapPathLine.Add(AllRoomIDs[_CurRoom], MapLine);
							}

							HasCollectedRooms.AddUnique(AllRoomIDs[_CurRoom]);
						}
					}
				}
			}
		}
		if (NumOfIter >= MaxNumIter)
		{
			return false;
		}
	}


	///////////////////////过滤没必要的计算空间/////////////////////////////////
	for (auto TempMapLine : LocalRoomIDMapPathLine)
	{
		int TempID = TempMapLine.Key;
		if (InPutRoomIDs.Contains(TempID))
		{
			FPathLine TempPathLine = TempMapLine.Value;
			AllPathLines.Add(TempPathLine);
		}
	}

	if (AllPathLines.Num() == 0)
	{
		return false;
	}

	return true;
}



bool UWriteMeshObj_FunctionLibrary::FilterRoomPathPoints(UObject* WorldContextObject, const FPathLine WalkingLine, FPathLine& ResultLine, const TArray<FVector2D> RoomPs)
{
	if (RoomPs.Num() == 0)
	{
		return false;
	}
	////////////获取区域内模型数据/////////////////////
	TArray<AFurnitureModelActor*> ModelsOfRoom;
	FindModelsOfRoom(WorldContextObject, RoomPs, ModelsOfRoom);

	TArray<AHouseCustomActor*> CustomModelsOfRoom;
	FindCustomModelsOfRoom(WorldContextObject, RoomPs, CustomModelsOfRoom);

	TArray<FPointPair> RoutinePoints = WalkingLine.RoutinePoints;
	TArray<FVector2D> Points;
	int _NextP = 0;
	const float DisBound1 = 200;
	const int DivideNums1 = 20;
	const float DisBound2 = 100;
	const int DivideNums2 = 10;
	const float DisBound3 = 50;
	const int DividedNums3 = 5;
	const float HeightBound = 180;
	TArray<FVector2D> DividedPoints;
	float Ratio = 1.0;
	float PathHeight = 130.0f;
	TArray<int> RemoveIndexs;
	FVector WatchPoint;
	FVector2D RoomCenter;
	for (int _CurI = 0; _CurI < RoutinePoints.Num() - 1; ++_CurI)
	{
		_NextP = _CurI + 1;
		FVector2D StartP = FVector2D(RoutinePoints[_CurI].RoutinePoint);
		FVector2D EndP = FVector2D(RoutinePoints[_NextP].RoutinePoint);
		float PointZ = RoutinePoints[_CurI].RoutinePoint.Z;
		PathHeight = PointZ;
		bool StartIsFalse = false;
		bool EndIsFalse = false;
		bool SegPointIsFalse = false;
		DividedPoints.Empty();
		////////////////////判断起点是否在区域内部/////////////////////
		bool StartIsInRegion = FPolygonAlg::JudgePointOnOrInPolygon(RoomPs, StartP);
		if (!StartIsInRegion)
		{
			StartIsFalse = true;
		}
		////////////////////判断起点是否在模型内部////////////////////
		if (!StartIsFalse)
		{
			for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
			{
				FBox TempBox = ModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
				FString ModelName = ModelsOfRoom[_CurM]->GetName();
				if ((!ModelName.Contains(FString("Light"))) && (!ModelName.Contains(FString("Door"))))
				{
					bool IfInModel = TempBox.IsInsideOrOn(FVector(StartP, PointZ));
					if (IfInModel)
					{
						FVector FMin = TempBox.Min;
						FVector FMax = TempBox.Max;
						float ModelH = FMax.Z - FMin.Z;
						if (ModelH >= HeightBound)
						{
							bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, RoomPs);
							if (ModelBoxIsUseful)
							{
								StartIsFalse = true;
								break;
							}
						}
					}
				}
			}

			if (!StartIsFalse)
			{
				for (int _CurM = 0; _CurM < CustomModelsOfRoom.Num(); ++_CurM)
				{
					FBox TempBox = CustomModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
					FString ModelName = CustomModelsOfRoom[_CurM]->GetName();
					if ((!ModelName.Contains(FString("Light"))) && (!ModelName.Contains(FString("Door"))))
					{
						bool IfInModel = TempBox.IsInsideOrOn(FVector(StartP, PointZ));
						if (IfInModel)
						{
							FVector FMin = TempBox.Min;
							FVector FMax = TempBox.Max;
							float ModelH = FMax.Z - FMin.Z;
							if (ModelH >= HeightBound)
							{
								bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, RoomPs);
								if (ModelBoxIsUseful)
								{
									StartIsFalse = true;
									break;
								}
							}
						}
					}
				}
			}
		}
		////////////////////判断终点是否在区域内部/////////////////////
		bool EndIsInRegion = FPolygonAlg::JudgePointOnOrInPolygon(RoomPs, EndP);
		if (!EndIsInRegion)
		{
			EndIsFalse = true;
		}
		////////////////////判断终点是否在模型内部////////////////////
		if (!EndIsFalse)
		{
			for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
			{
				FBox TempBox = ModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
				FString ModelName = ModelsOfRoom[_CurM]->GetName();
				if ((!ModelName.Contains(FString("Light"))) && (!ModelName.Contains(FString("Door"))))
				{
					bool IfInModel = TempBox.IsInsideOrOn(FVector(EndP, PointZ));
					if (IfInModel)
					{
						FVector FMin = TempBox.Min;
						FVector FMax = TempBox.Max;
						float ModelH = FMax.Z - FMin.Z;
						if (ModelH >= HeightBound)
						{
							bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, RoomPs);
							if (ModelBoxIsUseful)
							{
								EndIsFalse = true;
								break;
							}
						}
					}
				}
			}

			if (!EndIsFalse)
			{
				for (int _CurM = 0; _CurM < CustomModelsOfRoom.Num(); ++_CurM)
				{
					FBox TempBox = CustomModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
					FString ModelName = CustomModelsOfRoom[_CurM]->GetName();
					if ((!ModelName.Contains(FString("Light"))) && (!ModelName.Contains(FString("Door"))))
					{
						bool IfInModel = TempBox.IsInsideOrOn(FVector(EndP, PointZ));
						if (IfInModel)
						{
							FVector FMin = TempBox.Min;
							FVector FMax = TempBox.Max;
							float ModelH = FMax.Z - FMin.Z;
							if (ModelH >= HeightBound)
							{
								bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, RoomPs);
								if (ModelBoxIsUseful)
								{
									EndIsFalse = true;
									break;
								}
							}
						}
					}
				}
			}
		}
		//////////////////////////////////////////////////////////////
		if (StartIsFalse)
		{
			RemoveIndexs.AddUnique(_CurI);
		}
		if (EndIsFalse)
		{
			RemoveIndexs.AddUnique(_NextP);
		}

		if ((!StartIsFalse) && (!EndIsFalse))
		{
			float SegDis = FVector2D::Distance(StartP, EndP);
			if (DisBound1 <= SegDis)
			{
				for (int _CurSeg = 0; _CurSeg < 2 * DivideNums1 - 1; ++_CurSeg)
				{
					Ratio = (_CurSeg + 1)*1.0 / (2.0 * DivideNums1);
					DividedPoints.AddUnique((1 - Ratio)*StartP + Ratio * EndP);
				}
			}
			else if ((DisBound1 > SegDis) && (DisBound2 < SegDis))
			{
				for (int _CurSeg = 0; _CurSeg < DivideNums1 - 1; ++_CurSeg)
				{
					Ratio = (_CurSeg + 1)*1.0 / (1.0*DivideNums1);
					DividedPoints.AddUnique((1 - Ratio)*StartP + Ratio * EndP);
				}
			}
			else if ((DisBound2 >= SegDis) && (DisBound3 <= SegDis))
			{
				for (int _CurSeg = 0; _CurSeg < DivideNums2 - 1; ++_CurSeg)
				{
					Ratio = (_CurSeg + 1)*1.0 / (1.0*DivideNums2);
					DividedPoints.AddUnique((1 - Ratio)*StartP + Ratio * EndP);
				}
			}
			else if (DisBound3 > SegDis)
			{
				for (int _CurSeg = 0; _CurSeg < DividedNums3 - 1; ++_CurSeg)
				{
					Ratio = (_CurSeg + 1)*1.0 / (1.0*DividedNums3);
					DividedPoints.AddUnique((1 - Ratio)*StartP + Ratio * EndP);
				}
			}
		}
		///////////判断分割点是否在区域内部//////////////////////
		for (auto TempPoint : DividedPoints)
		{
			if (!FPolygonAlg::JudgePointInPolygon(RoomPs, TempPoint))
			{
				SegPointIsFalse = true;
				break;
			}
		}
		if (!SegPointIsFalse)
		{
			////////////////////判断分割点是否在模型内部////////////////////
			for (auto TempPoint : DividedPoints)
			{
				for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
				{
					FBox TempBox = ModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
					FString ModelName = ModelsOfRoom[_CurM]->GetName();
					if ((!ModelName.Contains(FString("Light"))) && (!ModelName.Contains(FString("Door"))))
					{
						bool IfInModel = TempBox.IsInsideOrOn(FVector(TempPoint, PointZ));
						if (IfInModel)
						{
							FVector FMin = TempBox.Min;
							FVector FMax = TempBox.Max;
							float ModelH = FMax.Z - FMin.Z;
							if (ModelH >= HeightBound)
							{
								bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, RoomPs);
								if (ModelBoxIsUseful)
								{
									SegPointIsFalse = true;
									break;
								}
							}
						}
					}
				}

				if (!SegPointIsFalse)
				{
					for (int _CurM = 0; _CurM < CustomModelsOfRoom.Num(); ++_CurM)
					{
						FBox TempBox = CustomModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
						FString ModelName = CustomModelsOfRoom[_CurM]->GetName();
						if ((!ModelName.Contains(FString("Light"))) && (!ModelName.Contains(FString("Door"))))
						{
							bool IfInModel = TempBox.IsInsideOrOn(FVector(TempPoint, PointZ));
							if (IfInModel)
							{
								FVector FMin = TempBox.Min;
								FVector FMax = TempBox.Max;
								float ModelH = FMax.Z - FMin.Z;
								if (ModelH >= HeightBound)
								{
									bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, RoomPs);
									if (ModelBoxIsUseful)
									{
										SegPointIsFalse = true;
										break;
									}
								}
							}
						}
					}
				}
			}

		}

		if (SegPointIsFalse)
		{
			RemoveIndexs.AddUnique(_NextP);
		}

	}
	TArray<FVector2D> PostRoomPs;

	TArray<FVector> UpdateRoomPathPs;
	if (RemoveIndexs.Num() > 0)
	{
		bool PostProcess = FPolygonAlg::MergeCollinearPoints(RoomPs, PostRoomPs);
		if (PostProcess)
		{
			if (PostRoomPs.Num() == 4)
			{
				if (RoutinePoints.Num() > 0)
				{
					if (!RemoveIndexs.Contains(0))
					{
						UpdateRoomPathPs.AddUnique(RoutinePoints[0].RoutinePoint);
						FVector2D LocalCenter = 0.25*(PostRoomPs[0] + PostRoomPs[1] + PostRoomPs[2] + PostRoomPs[3]);
						UpdateRoomPathPs.AddUnique(FVector(0.5*(LocalCenter + FVector2D(UpdateRoomPathPs.Last())), PathHeight));
						WatchPoint = FVector(LocalCenter, PathHeight);
					}

				}

			}
			else
			{
				FPolygonAlg::LocateSuitableCenter(PostRoomPs, RoomCenter);
				UpdateRoomPathPs.AddUnique(FVector(RoomCenter, PathHeight));
				WatchPoint = FVector(0.0, 0.0, 0.0);
			}
		}
	}
	if (UpdateRoomPathPs.Num() != 0)
	{
		TArray<FPointPair> TempPointPairs;
		for (int _CurP = 0; _CurP < UpdateRoomPathPs.Num(); ++_CurP)
		{
			FPointPair TempPair;
			TempPair.RoutinePoint = UpdateRoomPathPs[_CurP];
			TempPair.WatchPoint = WatchPoint;
			if (UpdateRoomPathPs.Num() == 1)
			{
				TempPair.ActionMarker = 1;
			}
			else
			{
				TempPair.ActionMarker = 0;
			}
			TempPointPairs.Add(TempPair);
		}
		ResultLine.RoutinePoints = TempPointPairs;
	}
	else
	{
		ResultLine = WalkingLine;
	}
	return true;
}

bool UWriteMeshObj_FunctionLibrary::FilterLivingOrDiningPathPoints(UObject* WorldContextObject, const FPathLine WalkingLine, FPathLine& ResultLine, const TArray<FVector2D> RoomPs)
{
	if (RoomPs.Num() == 0)
	{
		return false;
	}
	////////////获取区域内模型数据/////////////////////
	TArray<AFurnitureModelActor*> ModelsOfRoom;
	FindModelsOfRoom(WorldContextObject, RoomPs, ModelsOfRoom);

	TArray<AHouseCustomActor*> CustomModelsOfRoom;
	FindCustomModelsOfRoom(WorldContextObject, RoomPs, CustomModelsOfRoom);

	TArray<FPointPair> RoutinePoints = WalkingLine.RoutinePoints;
	TArray<FVector2D> Points;
	int _NextP = 0;
	const float DisBound1 = 200;
	const int DivideNums1 = 20;
	const float DisBound2 = 100;
	const int DivideNums2 = 10;
	const float DisBound3 = 50;
	const int DividedNums3 = 5;
	const float HeightBound = 180;

	const float ErrorDisBound = 20.0f;
	float MinDis = 0.0f;
	TArray<FVector2D> DividedPoints;
	float Ratio = 1.0;
	float PathHeight = 130.0f;
	TArray<int> RemoveIndexs;
	FVector WatchPoint;
	FVector2D RoomCenter;
	for (int _CurI = 0; _CurI < RoutinePoints.Num() - 1; ++_CurI)
	{
		_NextP = _CurI + 1;
		FVector2D StartP = FVector2D(RoutinePoints[_CurI].RoutinePoint);
		FVector2D EndP = FVector2D(RoutinePoints[_NextP].RoutinePoint);
		float PointZ = RoutinePoints[_CurI].RoutinePoint.Z;
		PathHeight = PointZ;
		bool StartIsFalse = false;
		bool EndIsFalse = false;
		bool SegPointIsFalse = false;
		DividedPoints.Empty();
		////////////////////判断起点是否在区域附近/////////////////////
		bool StartIsInRegion = FPolygonAlg::JudgePointInPolygon(RoomPs, StartP);
		if (!StartIsInRegion)
		{
			int _NextCurP = 0;
			for (int _CurP = 0; _CurP < RoomPs.Num(); ++_CurP)
			{
				if (_CurP == RoomPs.Num() - 1)
				{
					_NextCurP = 0;
				}
				else
				{
					_NextCurP = _CurP + 1;
				}
				float PointToSegDis = FMath::PointDistToSegment(FVector(StartP, 0.0), FVector(RoomPs[_CurP], 0.0), FVector(RoomPs[_NextCurP], 0.0));
				if ((MinDis <= 0.001f) || (MinDis >= PointToSegDis))
				{
					MinDis = PointToSegDis;
				}

			}
		}

		if (MinDis >= ErrorDisBound)
		{
			StartIsFalse = true;
			break;
		}
		////////////////////判断起点是否在模型内部////////////////////
		if (!StartIsFalse)
		{
			for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
			{
				FBox TempBox = ModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
				FString ModelName = ModelsOfRoom[_CurM]->GetName();
				if (!ModelName.Contains(FString("Light")))
				{
					bool IfInModel = TempBox.IsInsideOrOn(FVector(StartP, PointZ));
					if (IfInModel)
					{
						FVector FMin = TempBox.Min;
						FVector FMax = TempBox.Max;
						float ModelH = FMax.Z - FMin.Z;
						if (ModelH >= HeightBound)
						{
							bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, RoomPs);
							if (ModelBoxIsUseful)
							{
								StartIsFalse = true;
								break;
							}
						}
					}
				}
			}

			if (!StartIsFalse)
			{
				for (int _CurM = 0; _CurM < CustomModelsOfRoom.Num(); ++_CurM)
				{
					FBox TempBox = CustomModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
					FString ModelName = CustomModelsOfRoom[_CurM]->GetName();
					if (!ModelName.Contains(FString("Light")))
					{
						bool IfInModel = TempBox.IsInsideOrOn(FVector(StartP, PointZ));
						if (IfInModel)
						{
							FVector FMin = TempBox.Min;
							FVector FMax = TempBox.Max;
							float ModelH = FMax.Z - FMin.Z;
							if (ModelH >= HeightBound)
							{
								bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, RoomPs);
								if (ModelBoxIsUseful)
								{
									StartIsFalse = true;
									break;
								}
							}
						}
					}
				}
			}
		}
		///////////////////判断终点是否在区域附近//////////////////////////////////
		bool EndIsInRegion = FPolygonAlg::JudgePointInPolygon(RoomPs, EndP);
		MinDis = 0.0f;
		if (!EndIsInRegion)
		{
			int _NextCurP = 0;
			for (int _CurP = 0; _CurP < RoomPs.Num(); ++_CurP)
			{
				if (_CurP == RoomPs.Num() - 1)
				{
					_NextCurP = 0;
				}
				else
				{
					_NextCurP = _CurP + 1;
				}
				float PointToSegDis = FMath::PointDistToSegment(FVector(EndP, 0.0), FVector(RoomPs[_CurP], 0.0), FVector(RoomPs[_NextCurP], 0.0));
				if ((MinDis <= 0.001f) || (MinDis >= PointToSegDis))
				{
					MinDis = PointToSegDis;
				}

			}
		}

		if (MinDis >= ErrorDisBound)
		{
			EndIsFalse = true;
			break;
		}
		////////////////////判断终点是否在模型内部////////////////////
		if (!EndIsFalse)
		{
			for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
			{
				FBox TempBox = ModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
				FString ModelName = ModelsOfRoom[_CurM]->GetName();
				if (!ModelName.Contains(FString("Light")))
				{
					bool IfInModel = TempBox.IsInsideOrOn(FVector(EndP, PointZ));
					if (IfInModel)
					{
						FVector FMin = TempBox.Min;
						FVector FMax = TempBox.Max;
						float ModelH = FMax.Z - FMin.Z;
						if (ModelH >= HeightBound)
						{
							bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, RoomPs);
							if (ModelBoxIsUseful)
							{
								EndIsFalse = true;
								break;
							}
						}
					}
				}
			}

			if (!EndIsFalse)
			{
				for (int _CurM = 0; _CurM < CustomModelsOfRoom.Num(); ++_CurM)
				{
					FBox TempBox = CustomModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
					FString ModelName = CustomModelsOfRoom[_CurM]->GetName();
					if (!ModelName.Contains(FString("Light")))
					{
						bool IfInModel = TempBox.IsInsideOrOn(FVector(EndP, PointZ));
						if (IfInModel)
						{
							FVector FMin = TempBox.Min;
							FVector FMax = TempBox.Max;
							float ModelH = FMax.Z - FMin.Z;
							if (ModelH >= HeightBound)
							{
								bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, RoomPs);
								if (ModelBoxIsUseful)
								{
									EndIsFalse = true;
									break;
								}
							}
						}
					}
				}
			}
		}
		//////////////////////////////////////////////////////////////
		if (StartIsFalse)
		{
			RemoveIndexs.AddUnique(_CurI);
		}
		if (EndIsFalse)
		{
			RemoveIndexs.AddUnique(_NextP);
		}

		if ((!StartIsFalse) && (!EndIsFalse))
		{
			float SegDis = FVector2D::Distance(StartP, EndP);
			if (DisBound1 <= SegDis)
			{
				for (int _CurSeg = 0; _CurSeg < 2 * DivideNums1 - 1; ++_CurSeg)
				{
					Ratio = (_CurSeg + 1)*1.0 / (2.0 * DivideNums1);
					DividedPoints.AddUnique((1 - Ratio)*StartP + Ratio * EndP);
				}
			}
			else if ((DisBound1 > SegDis) && (DisBound2 < SegDis))
			{
				for (int _CurSeg = 0; _CurSeg < DivideNums1 - 1; ++_CurSeg)
				{
					Ratio = (_CurSeg + 1)*1.0 / (1.0*DivideNums1);
					DividedPoints.AddUnique((1 - Ratio)*StartP + Ratio * EndP);
				}
			}
			else if ((DisBound2 >= SegDis) && (DisBound3 <= SegDis))
			{
				for (int _CurSeg = 0; _CurSeg < DivideNums2 - 1; ++_CurSeg)
				{
					Ratio = (_CurSeg + 1)*1.0 / (1.0*DivideNums2);
					DividedPoints.AddUnique((1 - Ratio)*StartP + Ratio * EndP);
				}
			}
			else if (DisBound3 > SegDis)
			{
				for (int _CurSeg = 0; _CurSeg < DividedNums3 - 1; ++_CurSeg)
				{
					Ratio = (_CurSeg + 1)*1.0 / (1.0*DividedNums3);
					DividedPoints.AddUnique((1 - Ratio)*StartP + Ratio * EndP);
				}
			}
		}
		///////////判断分割点是否在区域内部或者边界一定范围内部//////////////////////
		for (auto TempPoint : DividedPoints)
		{
			if (!FPolygonAlg::JudgePointInPolygon(RoomPs, TempPoint))
			{
				int _NextCurP = 0;
				MinDis = 0.0;
				for (int _CurP = 0; _CurP < RoomPs.Num(); ++_CurP)
				{
					if (_CurP == RoomPs.Num() - 1)
					{
						_NextCurP = 0;
					}
					else
					{
						_NextCurP = _CurP + 1;
					}
					float PointToSegDis = FMath::PointDistToSegment(FVector(EndP, 0.0), FVector(RoomPs[_CurP], 0.0), FVector(RoomPs[_NextCurP], 0.0));
					if ((MinDis <= 0.001f) || (MinDis >= PointToSegDis))
					{
						MinDis = PointToSegDis;
					}
				}
				if (MinDis >= ErrorDisBound)
				{
					SegPointIsFalse = true;
					break;
				}
			}
		}
		if (!SegPointIsFalse)
		{
			////////////////////判断分割点是否在模型内部////////////////////
			for (auto TempPoint : DividedPoints)
			{
				for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
				{
					FBox TempBox = ModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
					FString ModelName = ModelsOfRoom[_CurM]->GetName();
					if (!ModelName.Contains(FString("Light")))
					{
						bool IfInModel = TempBox.IsInsideOrOn(FVector(TempPoint, PointZ));
						if (IfInModel)
						{
							FVector FMin = TempBox.Min;
							FVector FMax = TempBox.Max;
							float ModelH = FMax.Z - FMin.Z;
							if (ModelH >= HeightBound)
							{
								bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, RoomPs);
								if (ModelBoxIsUseful)
								{
									SegPointIsFalse = true;
									break;
								}
							}
						}
					}
				}

				if (!SegPointIsFalse)
				{
					for (int _CurM = 0; _CurM < CustomModelsOfRoom.Num(); ++_CurM)
					{
						FBox TempBox = CustomModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
						FString ModelName = CustomModelsOfRoom[_CurM]->GetName();
						if (!ModelName.Contains(FString("Light")))
						{
							bool IfInModel = TempBox.IsInsideOrOn(FVector(TempPoint, PointZ));
							if (IfInModel)
							{
								FVector FMin = TempBox.Min;
								FVector FMax = TempBox.Max;
								float ModelH = FMax.Z - FMin.Z;
								if (ModelH >= HeightBound)
								{
									bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, RoomPs);
									if (ModelBoxIsUseful)
									{
										SegPointIsFalse = true;
										break;
									}
								}
							}
						}
					}
				}
			}

		}

		if (SegPointIsFalse)
		{
			RemoveIndexs.AddUnique(_NextP);
		}

	}
	TArray<FVector2D> PostRoomPs;

	TArray<FVector> UpdateRoomPathPs;
	if (RemoveIndexs.Num() > 0)
	{
		bool PostProcess = FPolygonAlg::MergeCollinearPoints(RoomPs, PostRoomPs);
		if (PostProcess)
		{
			if (PostRoomPs.Num() == 4)
			{
				if (RoutinePoints.Num() > 0)
				{
					if (!RemoveIndexs.Contains(0))
					{
						UpdateRoomPathPs.AddUnique(RoutinePoints[0].RoutinePoint);
						FVector2D LocalCenter = 0.25*(PostRoomPs[0] + PostRoomPs[1] + PostRoomPs[2] + PostRoomPs[3]);
						UpdateRoomPathPs.AddUnique(FVector(0.5*(LocalCenter + FVector2D(UpdateRoomPathPs.Last())), PathHeight));
						WatchPoint = FVector(LocalCenter, PathHeight);
					}

				}

			}
			else
			{
				FPolygonAlg::LocateSuitableCenter(PostRoomPs, RoomCenter);
				UpdateRoomPathPs.AddUnique(FVector(RoomCenter, PathHeight));
				WatchPoint = FVector(0.0, 0.0, 0.0);
			}
		}
	}
	if (UpdateRoomPathPs.Num() != 0)
	{
		TArray<FPointPair> TempPointPairs;
		for (int _CurP = 0; _CurP < UpdateRoomPathPs.Num(); ++_CurP)
		{
			FPointPair TempPair;
			TempPair.RoutinePoint = UpdateRoomPathPs[_CurP];
			TempPair.WatchPoint = WatchPoint;
			if (UpdateRoomPathPs.Num() == 1)
			{
				TempPair.ActionMarker = 1;
			}
			else
			{
				TempPair.ActionMarker = 0;
			}
			TempPointPairs.Add(TempPair);
		}
		ResultLine.RoutinePoints = TempPointPairs;
	}
	else
	{
		ResultLine = WalkingLine;
	}
	return true;
}

bool UWriteMeshObj_FunctionLibrary::LocateEntranceRoomID(UObject* WorldContextObject, UVaRestJsonObject* InJson, TArray<FRoomGroup>& RoomGroups, int &EntranceRoomID, FVector2D& EntranceDoorCenter, FVector2D& EntranceDir)
{
	bool IsSeperated = SeperateRoomsIntoGroups(WorldContextObject, InJson, RoomGroups);
	if (IsSeperated)
	{
		//////////获取资源数据////////////////////
		int SolutionID = 0;
		SolutionID = InJson->GetNumberField("solutionId");
		TArray<UVaRestJsonObject*> RoomJsonObj = InJson->GetObjectArrayField("roomList");
		TArray<UVaRestJsonObject*> NewRoomJsonObj;
		TArray<FRegionPsOfMovieProject> RoomIDMapRegions;
		TMap<int, TArray<FVector2D>> RoomIDMapBoundary;
		TMap<int, FString> RoomIDMapName;
		TArray<int> AllRoomIDs;
		TMap<int, FString> RoomIDMapUseageName;

		for (int RoomIndex = 0; RoomIndex < RoomJsonObj.Num(); RoomIndex++)
		{
			TArray<UVaRestJsonObject*> EachRoomRegion = RoomJsonObj[RoomIndex]->GetObjectArrayField("areas");
			TArray<FVector2D> TempRegionPs;
			int RoomId = RoomJsonObj[RoomIndex]->GetIntegerField("roomId");
			AllRoomIDs.Add(RoomId);
			for (int NumIndex = 0; NumIndex < EachRoomRegion.Num(); NumIndex++)
			{
				UVaRestJsonObject* TempXY = NewObject<UVaRestJsonObject>();
				float TempX = EachRoomRegion[NumIndex]->GetNumberField("x");
				float TempY = EachRoomRegion[NumIndex]->GetNumberField("y");
				TempRegionPs.Add(FVector2D(TempX, TempY));
			}
			FString RoomName = RoomJsonObj[RoomIndex]->GetStringField("roomName");
			FRegionPsOfMovieProject  TempRegionPsOfMovie;
			TempRegionPsOfMovie.RoomID = RoomId;
			TempRegionPsOfMovie.RegionPs = TempRegionPs;
			RoomIDMapRegions.Add(TempRegionPsOfMovie);
			RoomIDMapBoundary.Add(RoomId, TempRegionPs);
			RoomIDMapName.Add(RoomId, RoomName);
			FString RoomUsageName = RoomJsonObj[RoomIndex]->GetStringField("roomUsageName");
			RoomIDMapUseageName.Add(RoomId, RoomUsageName);
		}

		int TargetDoor = 0;
		bool FindEntrance = false;
		const float ExtendLength = 35.0f;
		if (RoomGroups.Num() == 1)
		{
			///////////定位入户门所属的RoomID/////////////////
			TArray<int> TempRooms = RoomGroups[0].RoomIDs;
			for (int _CurRoom = 0; _CurRoom < TempRooms.Num(); ++_CurRoom)
			{
				TArray<FVector> TempRoomDoors;
				bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRooms[_CurRoom], TempRoomDoors);
				if (GetDoorSuccess)
				{
					int NumOfDoors = TempRoomDoors.Num() / 8;
					for (int _CurDoor = 0; _CurDoor < NumOfDoors; ++_CurDoor)
					{
						FVector2D FindDir;
						FVector TempDoorCenter = 0.25*(TempRoomDoors[8 * _CurDoor + 0] + TempRoomDoors[8 * _CurDoor + 1] + TempRoomDoors[8 * _CurDoor + 2] + TempRoomDoors[8 * _CurDoor + 3]);
						FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter);
						FVector2D DoorDir = FVector2D(TempRoomDoors[8 * _CurDoor + 1] - TempRoomDoors[8 * _CurDoor]);
						DoorDir = DoorDir.GetSafeNormal();
						FVector2D DoorDirOfRotated = DoorDir.GetRotated(90);
						FVector2D ExtendP1 = TempDoorCenter2D + ExtendLength * DoorDirOfRotated;
						FVector2D ExtendP2 = TempDoorCenter2D - ExtendLength * DoorDirOfRotated;
						int CountTime = 0;
						for (int _CurRoom = 0; _CurRoom < AllRoomIDs.Num(); ++_CurRoom)
						{

							TArray<FVector2D> TempRegionPs = RoomIDMapBoundary[AllRoomIDs[_CurRoom]];
							bool P1IsInRegion = FPolygonAlg::JudgePointInPolygon(TempRegionPs, ExtendP1);
							bool P2IsInRegion = FPolygonAlg::JudgePointInPolygon(TempRegionPs, ExtendP2);

							if (P1IsInRegion)
							{
								CountTime++;
								FindDir = DoorDirOfRotated;
							}

							if (P2IsInRegion)
							{
								CountTime++;
								FindDir = -DoorDirOfRotated;
							}
						}

						if (CountTime == 1)
						{
							TargetDoor = _CurDoor;
							FindEntrance = true;
							EntranceDoorCenter = TempDoorCenter2D;
							EntranceDir = FindDir;
							EntranceRoomID = TempRooms[_CurRoom];
							break;
						}
					}
				}
			}
		}
		else if (RoomGroups.Num() >= 2)
		{
			int TempCountRoomIDNum = RoomGroups[0].RoomIDs.Num();
			int TargetRoomGroup = 0;
			for (int _CurGroup = 1; _CurGroup < RoomGroups.Num(); ++_CurGroup)
			{
				TArray<int> LocalRooms = RoomGroups[_CurGroup].RoomIDs;
				if (LocalRooms.Num() > TempCountRoomIDNum)
				{
					TempCountRoomIDNum = LocalRooms.Num();
					TargetRoomGroup = _CurGroup;
				}
			}
			///////////定位入户门所属的RoomID/////////////////
			TArray<int> TempRooms = RoomGroups[TargetRoomGroup].RoomIDs;
			for (int _CurRoom = 0; _CurRoom < TempRooms.Num(); ++_CurRoom)
			{
				TArray<FVector> TempRoomDoors;
				bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, TempRooms[_CurRoom], TempRoomDoors);
				if (GetDoorSuccess)
				{
					int NumOfDoors = TempRoomDoors.Num() / 8;
					for (int _CurDoor = 0; _CurDoor < NumOfDoors; ++_CurDoor)
					{
						FVector2D FindDir;
						FVector TempDoorCenter = 0.25*(TempRoomDoors[8 * _CurDoor + 0] + TempRoomDoors[8 * _CurDoor + 1] + TempRoomDoors[8 * _CurDoor + 2] + TempRoomDoors[8 * _CurDoor + 3]);
						FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter);
						FVector2D DoorDir = FVector2D(TempRoomDoors[8 * _CurDoor + 1] - TempRoomDoors[8 * _CurDoor]);
						DoorDir = DoorDir.GetSafeNormal();
						FVector2D DoorDirOfRotated = DoorDir.GetRotated(90);
						FVector2D ExtendP1 = TempDoorCenter2D + ExtendLength * DoorDirOfRotated;
						FVector2D ExtendP2 = TempDoorCenter2D - ExtendLength * DoorDirOfRotated;
						int CountTime = 0;
						for (int _CurRoom = 0; _CurRoom < AllRoomIDs.Num(); ++_CurRoom)
						{

							TArray<FVector2D> TempRegionPs = RoomIDMapBoundary[AllRoomIDs[_CurRoom]];
							bool P1IsInRegion = FPolygonAlg::JudgePointInPolygon(TempRegionPs, ExtendP1);
							bool P2IsInRegion = FPolygonAlg::JudgePointInPolygon(TempRegionPs, ExtendP2);

							if (P1IsInRegion)
							{
								CountTime++;
								FindDir = DoorDirOfRotated;
							}

							if (P2IsInRegion)
							{
								CountTime++;
								FindDir = -DoorDirOfRotated;
							}
						}

						if (CountTime == 1)
						{
							TargetDoor = _CurDoor;
							FindEntrance = true;
							EntranceDoorCenter = TempDoorCenter2D;
							EntranceDir = FindDir;
							EntranceRoomID = TempRooms[_CurRoom];
							break;
						}
					}
				}
			}
		}
		else
		{
			return false;
		}
	}
	else
	{
		return false;
	}
	return true;
}

bool UWriteMeshObj_FunctionLibrary::GetWindowsOfRegion(UObject* WorldContextObject, const int32 RoomID, TArray<FVector>&WindowPoints)
{
	TArray<ALineWallActor *> WallsOfRegion;
	bool IsSuccess = GetWallsOfRoom(WorldContextObject, RoomID, WallsOfRegion);
	if (!IsSuccess)
	{
		return false;
	}


	TArray<AWall_Boolean_Base*> DoorOrGroundWindowOnWall;
	for (ALineWallActor* WallActor : WallsOfRegion)
	{
		UDRProjData* projectDataManager = UDRProjData::GetProjectDataManager(WallActor);
		if (projectDataManager == nullptr) {
			continue;
		}

		UDRSolidWallAdapter* solidWallAdapter = Cast<UDRSolidWallAdapter>(projectDataManager->GetAdapter(WallActor->ObjectId));
		if (solidWallAdapter == nullptr) {
			continue;
		}

		TArray<AWall_Boolean_Base*> TempBoolean = WallActor->GetOpeningsOnWall();
		FVector2D PStartPos(solidWallAdapter->GetWallPositionData().LeftStartPos.X, solidWallAdapter->GetWallPositionData().LeftStartPos.Y);
		FVector2D PEndPos(solidWallAdapter->GetWallPositionData().LeftEndPos.X, solidWallAdapter->GetWallPositionData().LeftEndPos.Y);
		FVector2D WallVec = PEndPos - PStartPos;
		WallVec.Normalize();
		FVector2D OutVec = WallVec.GetRotated(90);

		FVector2D wallLeftStart(solidWallAdapter->GetWallPositionData().LeftStartPos.X, solidWallAdapter->GetWallPositionData().LeftStartPos.Y);
		FVector2D wallRightStart(solidWallAdapter->GetWallPositionData().RightStartPos.X, solidWallAdapter->GetWallPositionData().RightStartPos.Y);
		FVector2D wallLeftEnd(solidWallAdapter->GetWallPositionData().LeftEndPos.X, solidWallAdapter->GetWallPositionData().LeftEndPos.Y);
		FVector2D wallRightEnd(solidWallAdapter->GetWallPositionData().RightEndPos.X, solidWallAdapter->GetWallPositionData().RightEndPos.Y);

		FVector2D WallStandCenter = 0.25*(wallLeftStart + wallRightStart + wallLeftEnd + wallRightEnd);

		for (int32 I = 0; I < TempBoolean.Num(); I++)
		{
			FOpeningSimpleAttr FOpenAttr = TempBoolean[I]->GetOpeningSimpleAttr();
			if ((FOpenAttr.Type == EOpeningType::Window) || (FOpenAttr.Type == EOpeningType::BayWindow)
				|| (FOpenAttr.Type == EOpeningType::FrenchWindow))
			{
				FVector2D TempLocation = FOpenAttr.Location;
				float WindowHeight = FOpenAttr.Height;
				float TempLeftWidth = FOpenAttr.LeftWidth;
				float TempRightWidth = FOpenAttr.RightWidth;
				float TempWallLeftThick = 0.f;
				float TempWallRighThick = 0.f;
				if (WallActor->WallComp3d)
				{
					TempWallLeftThick = WallActor->WallComp3d->Data->GetFloat(TEXT("ThickLeft"));
					TempWallRighThick = WallActor->WallComp3d->Data->GetFloat(TEXT("ThickRight"));
				}

				FVector2D PStartLeft = TempLocation - TempLeftWidth * WallVec + OutVec * TempWallLeftThick;
				FVector2D PEndLeft = TempLocation + TempRightWidth * WallVec + OutVec * TempWallLeftThick;
				FVector2D PStartRight = TempLocation - TempLeftWidth * WallVec - OutVec * TempWallRighThick;
				FVector2D PEndRight = TempLocation + TempRightWidth * WallVec - OutVec * TempWallRighThick;

				FVector2D TempCenter = 0.25*(PStartLeft + PStartRight + PEndLeft + PEndRight);
				FVector2D WindowCenterToWallStartPos = WallStandCenter - TempCenter;
				float VecCross = FVector2D::DotProduct(WindowCenterToWallStartPos, OutVec);
				PStartLeft = PStartLeft + VecCross * OutVec;
				PEndLeft = PEndLeft + VecCross * OutVec;
				PStartRight = PStartRight + VecCross * OutVec;
				PEndRight = PEndRight + VecCross * OutVec;

				FVector PStartLeft_Up = FVector(PStartLeft, WindowHeight);
				FVector PEndLeft_Up = FVector(PEndLeft, WindowHeight);
				FVector PStartRight_Up = FVector(PStartRight, WindowHeight);
				FVector PEndRight_Up = FVector(PEndRight, WindowHeight);
				WindowPoints.Add(FVector(PStartLeft, 0.0));
				WindowPoints.Add(FVector(PEndLeft, 0.0));
				WindowPoints.Add(FVector(PStartRight, 0.0));
				WindowPoints.Add(FVector(PEndRight, 0.0));

				WindowPoints.Add(PStartLeft_Up);
				WindowPoints.Add(PEndLeft_Up);
				WindowPoints.Add(PStartRight_Up);
				WindowPoints.Add(PEndRight_Up);
			}
		}
	}

	if (WindowPoints.Num() == 0)
	{
		return false;
	}
	return true;
}




bool UWriteMeshObj_FunctionLibrary::LocateCriticalPointsOfLivingOrDining(UObject* WorldContextObject,
	const TArray<FVector2D> RoomPs,
	const int IDOfRoom,
	TArray<FVector2D> OppoSiteRoomPs,
	const TArray<int> HouseRoomIds,
	const TArray<FRegionPsOfMovieProject> RoomIdMapRegionPs,
	TArray<FVector2D>& CriticalPoints,
	TMap<int, FVector2D>& ChildRoomIDMapDoorCenter,
	TArray<int>& ChildRoomIDs,
	FVector2D& CenterPoint,
	bool IsLiving)
{
	if ((RoomPs.Num() == 0) || (HouseRoomIds.Num() == 0) || (RoomIdMapRegionPs.Num() == 0))
	{
		return false;
	}
	//////////////////////////////计算局部最大区域/////////////////////////
	TArray<FVector2D> MaxLocalRegion;
	TMap<int, FVector2D> ChildRoomMapInDir;

	bool IsSuccess = FPolygonAlg::LocateMaxLocalRegionOfLivingOrDiningRoom(RoomPs, IDOfRoom, OppoSiteRoomPs, MaxLocalRegion);
	if (IsSuccess)
	{
		/////////////////////////////////////判断最大局部区域的前两个点是否贴着墙体////////////////////////////////////////
		TArray<FVector2D> WallPoints;
		bool GetWallSuccess = GetWallPointsOfRoom(WorldContextObject, IDOfRoom, WallPoints);
		bool IsUnNormal = false;
		if (GetWallSuccess)
		{
			int NumOfWalls = WallPoints.Num() / 4;
			for (int _CurWall = 0; _CurWall < NumOfWalls; ++_CurWall)
			{
				FVector TestPoint = FVector(0.5*(MaxLocalRegion[0] + MaxLocalRegion[1]), 0.0);
				float Dis1PointToSeg = FMath::PointDistToSegment(TestPoint, FVector(WallPoints[4 * _CurWall], 0), FVector(WallPoints[4 * _CurWall + 1], 0));
				float Dis2PointToSeg = FMath::PointDistToSegment(TestPoint, FVector(WallPoints[4 * _CurWall + 2], 0), FVector(WallPoints[4 * _CurWall + 3], 0));
				if ((Dis1PointToSeg <= 3.0f) || (Dis2PointToSeg <= 3.0f))
				{
					IsUnNormal = true;
					break;
				}
			}
		}
		//////////////////////////////修正第一条线段，使其为客餐厅相邻的线段/////////////////////////
		int CountTimes = 0;
		if (IsUnNormal)
		{
			int NextCurP = 0;
			TArray<FVector2D> ReorderMaxLocs;
			for (int _CurP = 0; _CurP < MaxLocalRegion.Num(); ++_CurP)
			{
				if (_CurP == MaxLocalRegion.Num() - 1)
				{
					NextCurP = 0;
				}
				else
				{
					NextCurP = _CurP + 1;
				}
				FVector2D TempDir = MaxLocalRegion[NextCurP] - MaxLocalRegion[_CurP];
				TempDir.Normalize();
				FVector2D TempRoV = TempDir.GetRotated(90);
				FVector2D TempCenter = 0.5*(MaxLocalRegion[_CurP] + MaxLocalRegion[NextCurP]);
				FVector2D TempTestNode1 = TempCenter + 30 * TempRoV;
				FVector2D TempTestNode2 = TempCenter - 30 * TempRoV;
				bool Node1IsAtRegion1 = FPolygonAlg::JudgePointInPolygon(RoomPs, TempTestNode1);
				bool Node2IsAtRegion2 = FPolygonAlg::JudgePointInPolygon(OppoSiteRoomPs, TempTestNode2);
				bool Node1IsAtRegion2 = FPolygonAlg::JudgePointInPolygon(OppoSiteRoomPs, TempTestNode1);
				bool Node2IsAtRegion1 = FPolygonAlg::JudgePointInPolygon(RoomPs, TempTestNode2);
				if (((Node1IsAtRegion1) && (Node2IsAtRegion2)) || ((Node1IsAtRegion2) && (Node2IsAtRegion1)))
				{
					CountTimes++;
				}
				if (CountTimes == 1)
				{
					if (_CurP == 1)
					{
						ReorderMaxLocs.Add(MaxLocalRegion[1]);
						ReorderMaxLocs.Add(MaxLocalRegion[2]);
						ReorderMaxLocs.Add(MaxLocalRegion[3]);
						ReorderMaxLocs.Add(MaxLocalRegion[0]);
					}
					else if (_CurP == 2)
					{
						ReorderMaxLocs.Add(MaxLocalRegion[2]);
						ReorderMaxLocs.Add(MaxLocalRegion[3]);
						ReorderMaxLocs.Add(MaxLocalRegion[0]);
						ReorderMaxLocs.Add(MaxLocalRegion[1]);
					}
					else if (_CurP == 3)
					{
						ReorderMaxLocs.Add(MaxLocalRegion[3]);
						ReorderMaxLocs.Add(MaxLocalRegion[0]);
						ReorderMaxLocs.Add(MaxLocalRegion[1]);
						ReorderMaxLocs.Add(MaxLocalRegion[2]);
					}
					else if (_CurP == 0)
					{
						FVector2D TempCenter = 0.25*(MaxLocalRegion[0] + MaxLocalRegion[1] + MaxLocalRegion[2] + MaxLocalRegion[3]);
						const float ShrinkAge = 0.8;
						for (int _IP = 0; _IP < MaxLocalRegion.Num(); ++_IP)
						{
							ReorderMaxLocs.Add(ShrinkAge*MaxLocalRegion[_IP] + (1 - ShrinkAge)*TempCenter);
						}
					}
					MaxLocalRegion.Empty();
					MaxLocalRegion = ReorderMaxLocs;
					break;
				}
			}
		}

		//////////////////////////////////////////////////////////////////////////////////////////////
		TArray<FVector> DoorPoints;
		bool GetDoors = GetDoorsOfRegion(WorldContextObject, IDOfRoom, DoorPoints);
		if (GetDoors)
		{
			int NumOfDoors = DoorPoints.Num() / 8;
			for (int _CurDoor = 0; _CurDoor < NumOfDoors; ++_CurDoor)
			{
				FVector TempDoorCenter3D = 0.25*(DoorPoints[8 * _CurDoor] + DoorPoints[8 * _CurDoor + 1] + DoorPoints[8 * _CurDoor + 2] + DoorPoints[8 * _CurDoor + 3]);
				FVector Side1 = DoorPoints[8 * _CurDoor + 1] - DoorPoints[8 * _CurDoor];
				FVector Side2 = DoorPoints[8 * _CurDoor + 2] - DoorPoints[8 * _CurDoor];
				FVector BaseDir;
				FVector2D BaseDir2D;
				float LengthOfSide1 = Side1.Size();
				float LengthOfSide2 = Side2.Size();
				if (LengthOfSide1 > LengthOfSide2)
				{
					BaseDir = Side1.GetSafeNormal();
				}
				else
				{
					BaseDir = Side2.GetSafeNormal();
				}
				BaseDir2D = FVector2D(BaseDir);
				FVector2D BaseRotatedDir = BaseDir2D.GetRotated(90);
				FVector2D TempDoorCenter = FVector2D(TempDoorCenter3D);
				FVector2D ExtendP1 = TempDoorCenter + 30 * BaseRotatedDir;
				FVector2D ExtendP2 = TempDoorCenter - 30 * BaseRotatedDir;
				if (FPolygonAlg::JudgePointInPolygon(MaxLocalRegion, ExtendP1))
				{
					for (int _CurRoom = 0; _CurRoom < HouseRoomIds.Num(); ++_CurRoom)
					{
						int TempRoomID = HouseRoomIds[_CurRoom];
						if (TempRoomID != IDOfRoom)
						{
							for (int _CurI = 0; _CurI < RoomIdMapRegionPs.Num(); ++_CurI)
							{
								if (RoomIdMapRegionPs[_CurI].RoomID == TempRoomID)
								{
									TArray<FVector2D> CloseRoomPs = RoomIdMapRegionPs[_CurI].RegionPs;
									if (FPolygonAlg::JudgePointInPolygon(CloseRoomPs, ExtendP2))
									{
										ChildRoomIDs.AddUnique(TempRoomID);
										ChildRoomIDMapDoorCenter.Add(TempRoomID, TempDoorCenter);
										ChildRoomMapInDir.Add(TempRoomID, BaseRotatedDir);
									}
								}
							}
						}
					}
				}

				if (FPolygonAlg::JudgePointInPolygon(MaxLocalRegion, ExtendP2))
				{
					for (int _CurRoom = 0; _CurRoom < HouseRoomIds.Num(); ++_CurRoom)
					{
						int TempRoomID = HouseRoomIds[_CurRoom];
						if (TempRoomID != IDOfRoom)
						{
							for (int _CurI = 0; _CurI < RoomIdMapRegionPs.Num(); ++_CurI)
							{
								if (RoomIdMapRegionPs[_CurI].RoomID == TempRoomID)
								{
									TArray<FVector2D> CloseRoomPs = RoomIdMapRegionPs[_CurI].RegionPs;
									if (FPolygonAlg::JudgePointInPolygon(CloseRoomPs, ExtendP1))
									{
										ChildRoomIDs.AddUnique(TempRoomID);
										ChildRoomIDMapDoorCenter.Add(TempRoomID, TempDoorCenter);
										ChildRoomMapInDir.Add(TempRoomID, -BaseRotatedDir);
									}
								}
							}
						}
					}
				}
			}
		}
		if (ChildRoomIDs.Num() > 0)
		{
			///////////////////////////确定是否有沙发/////////////////
			bool BControlWay = false;
			if (IsLiving)
			{
				TArray<AFurnitureModelActor*> LocalModelsOfRoom;
				FindModelsOfRoom(WorldContextObject, RoomPs, LocalModelsOfRoom);
				bool FindMarkerModel = false;
				AFurnitureModelActor* FindFur = nullptr;
				if (LocalModelsOfRoom.Num() > 0)
				{
					for (int _CurM = 0; _CurM < LocalModelsOfRoom.Num(); ++_CurM)
					{
						AFurnitureModelActor* TempFur = LocalModelsOfRoom[_CurM];
						int TempID = 0;
						TempFur->GetModelCategory(TempID);
						if ((TempID >= 5001) && (TempID <= 5005))
						{
							FindFur = TempFur;
							FindMarkerModel = true;
							break;
						}
					}
				}

				if (FindMarkerModel)
				{
					FBox LocalBox = FindFur->GetComponentsBoundingBox(true);
					FVector LocalModelCenter = LocalBox.GetCenter();
					bool IsMarkerInLocalMax = FPolygonAlg::JudgePointInPolygon(MaxLocalRegion, FVector2D(LocalModelCenter));
					if (IsMarkerInLocalMax)
					{
						BControlWay = true;
					}
				}
			}

			if ((BControlWay) && (IsLiving))
			{
				/////////计算局部最大矩形每条边上的匹配的门洞中心//////////////////////////
				TMap<int, TArray<FVector2D>> SegMapCriticalPs;
				TMap<int, TArray<int>> SegMapChildRoomIDs;
				//////第二条边///////////////
				TArray<FVector2D> SecondSegCriticalPs;
				TArray<int> SecondSegChildRoomIDs;
				for (int _CurP = 0; _CurP < ChildRoomIDs.Num(); ++_CurP)
				{
					float TempDis = FMath::PointDistToSegment(FVector(ChildRoomIDMapDoorCenter[ChildRoomIDs[_CurP]], 0), FVector(MaxLocalRegion[1], 0), FVector(MaxLocalRegion[2], 0));
					if (TempDis <= 20)
					{
						FVector2D TempCriticalP = ChildRoomIDMapDoorCenter[ChildRoomIDs[_CurP]] + 80 * ChildRoomMapInDir[ChildRoomIDs[_CurP]];
						SecondSegCriticalPs.Add(TempCriticalP);
						SecondSegChildRoomIDs.AddUnique(ChildRoomIDs[_CurP]);
					}
				}

				if (SecondSegCriticalPs.Num() > 0)
				{
					SegMapCriticalPs.Add(2, SecondSegCriticalPs);
					SegMapChildRoomIDs.Add(2, SecondSegChildRoomIDs);
				}
				////////第三条边//////////////////////////
				TArray<FVector2D> ThirdSegCriticalPs;
				TArray<int> ThirdSegChildRoomIDs;
				for (int _CurP = 0; _CurP < ChildRoomIDs.Num(); ++_CurP)
				{
					float TempDis = FMath::PointDistToSegment(FVector(ChildRoomIDMapDoorCenter[ChildRoomIDs[_CurP]], 0), FVector(MaxLocalRegion[2], 0), FVector(MaxLocalRegion[3], 0));
					if (TempDis <= 20)
					{
						FVector2D TempCriticalP = ChildRoomIDMapDoorCenter[ChildRoomIDs[_CurP]] + 80 * ChildRoomMapInDir[ChildRoomIDs[_CurP]];
						ThirdSegCriticalPs.Add(TempCriticalP);
						ThirdSegChildRoomIDs.AddUnique(ChildRoomIDs[_CurP]);
					}
				}

				if (ThirdSegCriticalPs.Num() > 0)
				{
					SegMapCriticalPs.Add(3, ThirdSegCriticalPs);
					SegMapChildRoomIDs.Add(3, ThirdSegChildRoomIDs);
				}
				/////////////第四条边//////////////////////////////
				TArray<FVector2D> FourthSegCriticalPs;
				TArray<int> FourthSegChildRoomIDs;
				for (int _CurP = 0; _CurP < ChildRoomIDs.Num(); ++_CurP)
				{
					float TempDis = FMath::PointDistToSegment(FVector(ChildRoomIDMapDoorCenter[ChildRoomIDs[_CurP]], 0), FVector(MaxLocalRegion[3], 0), FVector(MaxLocalRegion[0], 0));
					if (TempDis <= 20)
					{
						FVector2D TempCriticalP = ChildRoomIDMapDoorCenter[ChildRoomIDs[_CurP]] + 80 * ChildRoomMapInDir[ChildRoomIDs[_CurP]];
						FourthSegCriticalPs.Add(TempCriticalP);
						FourthSegChildRoomIDs.AddUnique(ChildRoomIDs[_CurP]);
					}
				}

				if (FourthSegCriticalPs.Num() > 0)
				{
					SegMapCriticalPs.Add(4, FourthSegCriticalPs);
					SegMapChildRoomIDs.Add(4, FourthSegChildRoomIDs);
				}

				//////////////////////////////////添加局部区域关键路径点/////////////////////////////////////
				FVector2D FirstCriticalP = 0.5*(MaxLocalRegion[0] + MaxLocalRegion[1]);
				if ((IsUnNormal) && (CountTimes == 0))
				{
					FVector2D InDir = MaxLocalRegion[3] - MaxLocalRegion[0];
					InDir.Normalize();
					FirstCriticalP = FirstCriticalP + 80 * InDir;
				}

				CriticalPoints.Add(FirstCriticalP);

				TArray<FVector2D> TempSecondPointArr;
				bool IsSecond = false;
				if (SegMapCriticalPs.Contains(2))
				{
					TArray<FVector2D> SecondGroup = SegMapCriticalPs[2];
					TArray<int> SecondIDs = SegMapChildRoomIDs[2];
					if (SecondGroup.Num() > 0)
					{
						FVector2D TempMapDir = ChildRoomMapInDir[SecondIDs[0]];
						FVector2D TempCriticalP = SecondGroup[0];
						FVector TempCloestP1 = FMath::ClosestPointOnInfiniteLine(FVector(MaxLocalRegion[0], 0), FVector(MaxLocalRegion[1], 0), FVector(TempCriticalP, 0));

						FVector2D UpdatePoint1 = FVector2D(TempCloestP1);
						TempSecondPointArr.Add(UpdatePoint1);
						TempSecondPointArr.Add(TempCriticalP);
						IsSecond = true;
					}
				}



				TArray<FVector2D> TempFourthPointArr;
				bool IsFourth = false;
				if (SegMapCriticalPs.Contains(4))
				{
					TArray<FVector2D> FourthGroup = SegMapCriticalPs[4];
					TArray<int> FourthIDs = SegMapChildRoomIDs[4];
					if (FourthGroup.Num() > 0)
					{
						FVector2D TempMapDir = ChildRoomMapInDir[FourthIDs[0]];
						FVector2D TempCriticalP = FourthGroup[0];
						FVector TempCloestP1 = FMath::ClosestPointOnInfiniteLine(FVector(MaxLocalRegion[0], 0), FVector(MaxLocalRegion[1], 0), FVector(TempCriticalP, 0));

						FVector2D UpdatePoint1 = FVector2D(TempCloestP1);
						TempFourthPointArr.Add(UpdatePoint1);
						TempFourthPointArr.Add(TempCriticalP);

						IsFourth = true;
					}
				}

				//////第二个线段有子空间匹配,第四个线段没有子空间匹配/////////////////////
				if ((IsSecond) && (!IsFourth))
				{
					for (int _CurI = 0; _CurI < TempSecondPointArr.Num(); ++_CurI)
					{
						//////判定该点到第三条的距离是否大于80厘米
						float JudgeDis = FMath::PointDistToSegment(FVector(TempSecondPointArr[_CurI], 0.0), FVector(MaxLocalRegion[2], 0.0), FVector(MaxLocalRegion[3], 0.0));
						if (JudgeDis > 80)
						{
							CriticalPoints.Add(TempSecondPointArr[_CurI]);
						}
					}
					////////////////第三个线段有子空间匹配/////////////////////////////
					if (SegMapCriticalPs.Contains(3))
					{
						TArray<FVector2D> ThirdGroup = SegMapCriticalPs[3];
						TArray<int> ThirdIDs = SegMapChildRoomIDs[3];
						if (ThirdGroup.Num() == 1)
						{
							FVector2D TempCriticalP = ThirdGroup[0];
							FVector TempCloestP1 = FMath::ClosestPointOnInfiniteLine(FVector(MaxLocalRegion[1], 0), FVector(MaxLocalRegion[2], 0), FVector(TempCriticalP, 0));
							FVector TempCloestP2 = FMath::ClosestPointOnInfiniteLine(FVector(TempCriticalP, 0), TempCloestP1, FVector(CriticalPoints.Last(), 0));

							CriticalPoints.Add(FVector2D(TempCloestP2));
							TArray<FVector2D> TempThirdPs = SegMapCriticalPs[3];
							if (TempThirdPs.Num() == 1)
							{
								CriticalPoints.Add(TempThirdPs[0]);
								FVector2D TempExtendDir = TempThirdPs[0] - FVector2D(TempCloestP2);
								TempExtendDir.Normalize();
								FVector2D PointFrontDoor = TempThirdPs[0] + 50 * TempExtendDir;
								CriticalPoints.Add(PointFrontDoor);
							}
						}
					}
					else
					{
						if (CriticalPoints.Num() > 0)
						{
							FVector TempCloestP1 = FMath::ClosestPointOnInfiniteLine(FVector(MaxLocalRegion[2], 0), FVector(MaxLocalRegion[3], 0), FVector(CriticalPoints.Last(), 0));
							FVector2D TempDir = FVector2D(CriticalPoints.Last()) - FVector2D(TempCloestP1);
							TempDir.Normalize();
							FVector2D TempNode = FVector2D(TempCloestP1) + 80 * TempDir;
							CriticalPoints.Add(TempNode);
						}
					}
				}

				////////第二个线段没有子空间匹配，第四个线段有子空间匹配//////////////////////
				if ((!IsSecond) && (IsFourth))
				{
					for (int _CurI = 0; _CurI < TempFourthPointArr.Num(); ++_CurI)
					{
						/////判断该点到第三条边的距离是否大于80厘米
						float JudgeDis = FMath::PointDistToSegment(FVector(TempFourthPointArr[_CurI], 0.0), FVector(MaxLocalRegion[2], 0.0), FVector(MaxLocalRegion[3], 0.0));
						if (JudgeDis > 80.0)
						{
							CriticalPoints.Add(TempFourthPointArr[_CurI]);
						}
					}
					////////第三个线段有子空间匹配////////////////////
					if (SegMapCriticalPs.Contains(3))
					{
						TArray<FVector2D> ThirdGroup = SegMapCriticalPs[3];
						TArray<int> ThirdIDs = SegMapChildRoomIDs[3];
						if (ThirdGroup.Num() == 1)
						{
							FVector2D TempCriticalP = ThirdGroup[0];
							FVector TempCloestP1 = FMath::ClosestPointOnInfiniteLine(FVector(MaxLocalRegion[0], 0), FVector(MaxLocalRegion[3], 0), FVector(TempCriticalP, 0));
							FVector TempCloestP2 = FMath::ClosestPointOnInfiniteLine(FVector(TempCriticalP, 0), TempCloestP1, FVector(CriticalPoints.Last(), 0));
							CriticalPoints.Add(FVector2D(TempCloestP2));
							TArray<FVector2D> TempThirdPs = SegMapCriticalPs[3];
							if (TempThirdPs.Num() == 1)
							{
								CriticalPoints.Add(TempThirdPs[0]);
								FVector2D TempExtendDir = TempThirdPs[0] - FVector2D(TempCloestP2);
								TempExtendDir.Normalize();
								FVector2D PointFrontDoor = TempThirdPs[0] + 50 * TempExtendDir;
								CriticalPoints.Add(PointFrontDoor);

							}

						}
					}
					else
					{

						if (CriticalPoints.Num() > 0)
						{
							FVector TempCloestP1 = FMath::ClosestPointOnInfiniteLine(FVector(MaxLocalRegion[2], 0), FVector(MaxLocalRegion[3], 0), FVector(CriticalPoints.Last(), 0));
							FVector2D TempDir = FVector2D(CriticalPoints.Last()) - FVector2D(TempCloestP1);
							TempDir.Normalize();
							FVector2D TempNode = FVector2D(TempCloestP1) + 80 * TempDir;
							CriticalPoints.Add(TempNode);
						}

					}
				}


				////////第二个和第四个线段均没有子空间匹配////////////////////////
				if ((!IsSecond) && (!IsFourth))
				{
					/////////////////计算空间中最大模型大概位置区域///////////////////
					TArray<AFurnitureModelActor*> ModelsOfRoom;
					FindModelsOfRoom(WorldContextObject, RoomPs, ModelsOfRoom);
					int TypeValue = 0;
					bool FindModel = false;
					AFurnitureModelActor* FindFur = nullptr;
					if (ModelsOfRoom.Num() > 0)
					{
						for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
						{
							AFurnitureModelActor* TempFur = ModelsOfRoom[_CurM];
							int TempID = 0;
							TempFur->GetModelCategory(TempID);
							if ((TempID >= 5001) && (TempID <= 5005))
							{
								FindFur = TempFur;
								FindModel = true;
								break;
							}
						}
					}
					else
					{
						TypeValue = 1;
					}

					if (!FindModel)
					{
						TypeValue = 1;
					}

					if (FindModel)
					{
						TArray<FVector2D> LeftSidePs, RightSidePs;
						FBox TempBox = FindFur->GetComponentsBoundingBox(true);
						FVector MaxModelCenter = TempBox.GetCenter();
						TypeValue = FPolygonAlg::SplitRegionAndLocateMaxModel(MaxLocalRegion, MaxModelCenter, LeftSidePs, RightSidePs);
					}
					////////第三个线段有子空间匹配////////////////////
					if (SegMapCriticalPs.Contains(3))
					{
						TArray<FVector2D> ThirdGroup = SegMapCriticalPs[3];
						TArray<int> ThirdIDs = SegMapChildRoomIDs[3];
						if ((ThirdGroup.Num() > 0) && (TypeValue > 0))
						{
							FVector2D TempMapDir = ChildRoomMapInDir[ThirdIDs[0]];
							FVector2D TempCriticalP = ThirdGroup[0];
							FVector TempCloestP1, TempCloestP2;
							if (TypeValue == 2)
							{
								TempCloestP1 = FMath::ClosestPointOnInfiniteLine(FVector(MaxLocalRegion[1], 0), FVector(MaxLocalRegion[2], 0), FVector(TempCriticalP, 0));
								TempCloestP2 = FMath::ClosestPointOnInfiniteLine(FVector(MaxLocalRegion[0], 0), FVector(MaxLocalRegion[1], 0), TempCloestP1);
							}
							else if (TypeValue == 1)
							{
								TempCloestP1 = FMath::ClosestPointOnInfiniteLine(FVector(MaxLocalRegion[0], 0), FVector(MaxLocalRegion[3], 0), FVector(TempCriticalP, 0));
								TempCloestP2 = FMath::ClosestPointOnInfiniteLine(FVector(MaxLocalRegion[0], 0), FVector(MaxLocalRegion[1], 0), TempCloestP1);
							}

							FVector2D TempMoveDir1 = TempCriticalP - FVector2D(TempCloestP1);
							TempMoveDir1.Normalize();
							FVector2D UpdatePoint1 = FVector2D(TempCloestP1) + 80 * TempMoveDir1;
							FVector2D TempMoveDir2 = 0.5*(MaxLocalRegion[0] + MaxLocalRegion[1]) - FVector2D(TempCloestP2);
							TempMoveDir2.Normalize();
							FVector2D UpdatePoint2 = FVector2D(TempCloestP2) + 80 * TempMoveDir2;

							CriticalPoints.Add(UpdatePoint2);
							CriticalPoints.Add(UpdatePoint1);

							TArray<FVector2D> TempThirdPs = SegMapCriticalPs[3];
							if (TempThirdPs.Num() > 0)
							{
								CriticalPoints.Add(TempThirdPs[0]);
								FVector2D TempExtendDir = TempThirdPs[0] - UpdatePoint1;
								TempExtendDir.Normalize();
								FVector2D PointFrontDoor = TempThirdPs[0] + 50 * TempExtendDir;
								CriticalPoints.Add(PointFrontDoor);
							}
						}
						else if ((ThirdGroup.Num() > 0) && (TypeValue == 0))
						{
							FVector2D TempVertex = 0.8*(0.25*(MaxLocalRegion[0] + MaxLocalRegion[1] + MaxLocalRegion[2] + MaxLocalRegion[3])) + 0.2*(0.5*(MaxLocalRegion[0] + MaxLocalRegion[1]));
							CriticalPoints.Add(TempVertex);
						}
					}
				}

				////////第二个和第四个线段均有子空间匹配/////////////////////////
				if ((IsSecond) && (IsFourth))
				{
					/////////////////计算空间中最大模型大概位置区域///////////////////
					TArray<AFurnitureModelActor*> ModelsOfRoom;
					FindModelsOfRoom(WorldContextObject, RoomPs, ModelsOfRoom);
					int TypeValue = 0;
					bool FindModel = false;
					AFurnitureModelActor* FindFur = nullptr;
					if (ModelsOfRoom.Num() > 0)
					{
						for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
						{
							AFurnitureModelActor* TempFur = ModelsOfRoom[_CurM];
							int TempID = 0;
							TempFur->GetModelCategory(TempID);
							if ((TempID >= 5001) && (TempID <= 5005))
							{
								FindFur = TempFur;
								FindModel = true;
								break;
							}
						}
					}
					else
					{
						TypeValue = 1;
					}

					if (!FindModel)
					{
						TypeValue = 1;
					}

					if (FindModel)
					{
						TArray<FVector2D> LeftSidePs, RightSidePs;
						FBox TempBox = FindFur->GetComponentsBoundingBox(true);
						FVector MaxModelCenter = TempBox.GetCenter();
						TypeValue = FPolygonAlg::SplitRegionAndLocateMaxModel(MaxLocalRegion, MaxModelCenter, LeftSidePs, RightSidePs);
					}

					////////////////////第三个线段有子空间匹配////////////////////
					if (SegMapCriticalPs.Contains(3))
					{
						TArray<FVector2D> ThirdGroup = SegMapCriticalPs[3];
						TArray<int> ThirdIDs = SegMapChildRoomIDs[3];
						if ((ThirdGroup.Num() > 0) && (TypeValue > 0))
						{
							FVector2D TempMapDir = ChildRoomMapInDir[ThirdIDs[0]];
							FVector2D TempCriticalP = ThirdGroup[0];
							FVector TempCloestP1, TempCloestP2;
							if (TypeValue == 2)
							{
								TempCloestP1 = FMath::ClosestPointOnInfiniteLine(FVector(MaxLocalRegion[1], 0), FVector(MaxLocalRegion[2], 0), FVector(TempCriticalP, 0));
								TempCloestP2 = FMath::ClosestPointOnInfiniteLine(FVector(MaxLocalRegion[0], 0), FVector(MaxLocalRegion[1], 0), TempCloestP1);
							}
							else if (TypeValue == 1)
							{
								TempCloestP1 = FMath::ClosestPointOnInfiniteLine(FVector(MaxLocalRegion[0], 0), FVector(MaxLocalRegion[3], 0), FVector(TempCriticalP, 0));
								TempCloestP2 = FMath::ClosestPointOnInfiniteLine(FVector(MaxLocalRegion[0], 0), FVector(MaxLocalRegion[1], 0), TempCloestP1);
							}

							FVector2D TempMoveDir1 = TempCriticalP - FVector2D(TempCloestP1);
							TempMoveDir1.Normalize();
							FVector2D UpdatePoint1 = FVector2D(TempCloestP1) + 80 * TempMoveDir1;
							FVector2D TempMoveDir2 = 0.5*(MaxLocalRegion[0] + MaxLocalRegion[1]) - FVector2D(TempCloestP2);
							TempMoveDir2.Normalize();
							FVector2D UpdatePoint2 = FVector2D(TempCloestP2) + 80 * TempMoveDir2;

							CriticalPoints.Add(UpdatePoint2);
							FVector2D TempNode = 0.5*(UpdatePoint1 + UpdatePoint2);
							CriticalPoints.Add(TempNode);
							CriticalPoints.Add(UpdatePoint1);

							TArray<FVector2D> TempThirdPs = SegMapCriticalPs[3];
							if (TempThirdPs.Num() > 0)
							{
								CriticalPoints.Add(TempThirdPs[0]);
								FVector2D TempExtendDir = TempThirdPs[0] - UpdatePoint1;
								TempExtendDir.Normalize();
								FVector2D PointFrontDoor = TempThirdPs[0] + 50 * TempExtendDir;
								CriticalPoints.Add(PointFrontDoor);
							}
						}
					}
					else
					{
						TArray<FVector2D> TempSecondPoints = SegMapCriticalPs[2];
						FVector TempP1 = FMath::ClosestPointOnInfiniteLine(FVector(MaxLocalRegion[0], 0), FVector(MaxLocalRegion[1], 0), FVector(TempSecondPoints[0], 0));
						CriticalPoints.Add(FVector2D(TempP1));

						FVector TempP2 = FMath::ClosestPointOnInfiniteLine(FVector(MaxLocalRegion[2], 0), FVector(MaxLocalRegion[3], 0), TempP1);
						FVector2D TempMoveDir1 = FVector2D(TempP1) - FVector2D(TempP2);
						TempMoveDir1.Normalize();

						FVector2D TempAddNode1 = FVector2D(TempP2) + 80 * TempMoveDir1;
						CriticalPoints.Add(TempAddNode1);

						TArray<FVector2D> TempFourthPoints = SegMapCriticalPs[4];
						FVector TempP3 = FMath::ClosestPointOnInfiniteLine(FVector(MaxLocalRegion[2], 0), FVector(MaxLocalRegion[3], 0), FVector(TempFourthPoints[0], 0.0));
						FVector2D TempMoveDir2 = TempFourthPoints[0] - FVector2D(TempP3);
						TempMoveDir2.Normalize();
						FVector2D TempAddNode2 = FVector2D(TempP3) + TempMoveDir2 * 80;
						CriticalPoints.Add(TempAddNode2);

						FVector2D TempAddNode3 = TempFourthPoints[0] + 40 * TempMoveDir2;
						CriticalPoints.Add(TempAddNode3);
					}
				}

				CenterPoint = 0.25*(MaxLocalRegion[0] + MaxLocalRegion[1] + MaxLocalRegion[2] + MaxLocalRegion[3]);
			}
			else if (!IsLiving)
			{
				/////////计算局部最大矩形每条边上的匹配的门洞中心//////////////////////////
				TMap<int, TArray<FVector2D>> SegMapCriticalPs;
				TMap<int, TArray<int>> SegMapChildRoomIDs;
				//////第二条边///////////////
				TArray<FVector2D> SecondSegCriticalPs;
				TArray<int> SecondSegChildRoomIDs;
				for (int _CurP = 0; _CurP < ChildRoomIDs.Num(); ++_CurP)
				{
					float TempDis = FMath::PointDistToSegment(FVector(ChildRoomIDMapDoorCenter[ChildRoomIDs[_CurP]], 0), FVector(MaxLocalRegion[1], 0), FVector(MaxLocalRegion[2], 0));
					if (TempDis <= 20)
					{
						FVector2D TempCriticalP = ChildRoomIDMapDoorCenter[ChildRoomIDs[_CurP]] + 80 * ChildRoomMapInDir[ChildRoomIDs[_CurP]];
						SecondSegCriticalPs.Add(TempCriticalP);
						SecondSegChildRoomIDs.AddUnique(ChildRoomIDs[_CurP]);
					}
				}

				if (SecondSegCriticalPs.Num() > 0)
				{
					SegMapCriticalPs.Add(2, SecondSegCriticalPs);
					SegMapChildRoomIDs.Add(2, SecondSegChildRoomIDs);
				}
				////////第三条边//////////////////////////
				TArray<FVector2D> ThirdSegCriticalPs;
				TArray<int> ThirdSegChildRoomIDs;
				for (int _CurP = 0; _CurP < ChildRoomIDs.Num(); ++_CurP)
				{
					float TempDis = FMath::PointDistToSegment(FVector(ChildRoomIDMapDoorCenter[ChildRoomIDs[_CurP]], 0), FVector(MaxLocalRegion[2], 0), FVector(MaxLocalRegion[3], 0));
					if (TempDis <= 20)
					{
						FVector2D TempCriticalP = ChildRoomIDMapDoorCenter[ChildRoomIDs[_CurP]] + 80 * ChildRoomMapInDir[ChildRoomIDs[_CurP]];
						ThirdSegCriticalPs.Add(TempCriticalP);
						ThirdSegChildRoomIDs.AddUnique(ChildRoomIDs[_CurP]);
					}
				}

				if (ThirdSegCriticalPs.Num() > 0)
				{
					SegMapCriticalPs.Add(3, ThirdSegCriticalPs);
					SegMapChildRoomIDs.Add(3, ThirdSegChildRoomIDs);
				}
				/////////////第四条边//////////////////////////////
				TArray<FVector2D> FourthSegCriticalPs;
				TArray<int> FourthSegChildRoomIDs;
				for (int _CurP = 0; _CurP < ChildRoomIDs.Num(); ++_CurP)
				{
					float TempDis = FMath::PointDistToSegment(FVector(ChildRoomIDMapDoorCenter[ChildRoomIDs[_CurP]], 0), FVector(MaxLocalRegion[3], 0), FVector(MaxLocalRegion[0], 0));
					if (TempDis <= 20)
					{
						FVector2D TempCriticalP = ChildRoomIDMapDoorCenter[ChildRoomIDs[_CurP]] + 80 * ChildRoomMapInDir[ChildRoomIDs[_CurP]];
						FourthSegCriticalPs.Add(TempCriticalP);
						FourthSegChildRoomIDs.AddUnique(ChildRoomIDs[_CurP]);
					}
				}

				if (FourthSegCriticalPs.Num() > 0)
				{
					SegMapCriticalPs.Add(4, FourthSegCriticalPs);
					SegMapChildRoomIDs.Add(4, FourthSegChildRoomIDs);
				}

				//////////////////////////////////添加局部区域关键路径点/////////////////////////////////////
				FVector2D FirstCriticalP = 0.5*(MaxLocalRegion[0] + MaxLocalRegion[1]);
				if ((IsUnNormal) && (CountTimes == 0))
				{
					FVector2D InDir = MaxLocalRegion[3] - MaxLocalRegion[0];
					InDir.Normalize();
					FirstCriticalP = FirstCriticalP + 80 * InDir;
				}

				CriticalPoints.Add(FirstCriticalP);

				TArray<FVector2D> TempSecondPointArr;
				bool IsSecond = false;
				if (SegMapCriticalPs.Contains(2))
				{
					TArray<FVector2D> SecondGroup = SegMapCriticalPs[2];
					TArray<int> SecondIDs = SegMapChildRoomIDs[2];
					if (SecondGroup.Num() > 0)
					{
						FVector2D TempMapDir = ChildRoomMapInDir[SecondIDs[0]];
						FVector2D TempCriticalP = SecondGroup[0];
						FVector TempCloestP1 = FMath::ClosestPointOnInfiniteLine(FVector(MaxLocalRegion[0], 0), FVector(MaxLocalRegion[1], 0), FVector(TempCriticalP, 0));

						FVector2D UpdatePoint1 = FVector2D(TempCloestP1);
						TempSecondPointArr.Add(UpdatePoint1);
						TempSecondPointArr.Add(TempCriticalP);
						IsSecond = true;
					}
				}



				TArray<FVector2D> TempFourthPointArr;
				bool IsFourth = false;
				if (SegMapCriticalPs.Contains(4))
				{
					TArray<FVector2D> FourthGroup = SegMapCriticalPs[4];
					TArray<int> FourthIDs = SegMapChildRoomIDs[4];
					if (FourthGroup.Num() > 0)
					{
						FVector2D TempMapDir = ChildRoomMapInDir[FourthIDs[0]];
						FVector2D TempCriticalP = FourthGroup[0];
						FVector TempCloestP1 = FMath::ClosestPointOnInfiniteLine(FVector(MaxLocalRegion[0], 0), FVector(MaxLocalRegion[1], 0), FVector(TempCriticalP, 0));

						FVector2D UpdatePoint1 = FVector2D(TempCloestP1);
						TempFourthPointArr.Add(UpdatePoint1);
						TempFourthPointArr.Add(TempCriticalP);

						IsFourth = true;
					}
				}

				//////第二个线段有子空间匹配,第四个线段没有子空间匹配/////////////////////
				if ((IsSecond) && (!IsFourth))
				{
					for (int _CurI = 0; _CurI < TempSecondPointArr.Num(); ++_CurI)
					{
						//////判定该点到第三条的距离是否大于80厘米
						float JudgeDis = FMath::PointDistToSegment(FVector(TempSecondPointArr[_CurI], 0.0), FVector(MaxLocalRegion[2], 0.0), FVector(MaxLocalRegion[3], 0.0));
						if (JudgeDis > 80)
						{
							CriticalPoints.Add(TempSecondPointArr[_CurI]);
						}
					}
					////////////////第三个线段有子空间匹配/////////////////////////////
					if (SegMapCriticalPs.Contains(3))
					{
						TArray<FVector2D> ThirdGroup = SegMapCriticalPs[3];
						TArray<int> ThirdIDs = SegMapChildRoomIDs[3];
						if (ThirdGroup.Num() == 1)
						{
							FVector2D TempCriticalP = ThirdGroup[0];
							FVector TempCloestP1 = FMath::ClosestPointOnInfiniteLine(FVector(MaxLocalRegion[1], 0), FVector(MaxLocalRegion[2], 0), FVector(TempCriticalP, 0));
							FVector TempCloestP2 = FMath::ClosestPointOnInfiniteLine(FVector(TempCriticalP, 0), TempCloestP1, FVector(CriticalPoints.Last(), 0));

							CriticalPoints.Add(FVector2D(TempCloestP2));
							TArray<FVector2D> TempThirdPs = SegMapCriticalPs[3];
							if (TempThirdPs.Num() == 1)
							{
								CriticalPoints.Add(TempThirdPs[0]);
								FVector2D TempExtendDir = TempThirdPs[0] - FVector2D(TempCloestP2);
								TempExtendDir.Normalize();
								FVector2D PointFrontDoor = TempThirdPs[0] + 50 * TempExtendDir;
								CriticalPoints.Add(PointFrontDoor);
							}
						}
					}
					else
					{
						if (CriticalPoints.Num() > 0)
						{
							FVector TempCloestP1 = FMath::ClosestPointOnInfiniteLine(FVector(MaxLocalRegion[2], 0), FVector(MaxLocalRegion[3], 0), FVector(CriticalPoints.Last(), 0));
							FVector2D TempDir = FVector2D(CriticalPoints.Last()) - FVector2D(TempCloestP1);
							TempDir.Normalize();
							FVector2D TempNode = FVector2D(TempCloestP1) + 80 * TempDir;
							CriticalPoints.Add(TempNode);
						}
					}
				}

				////////第二个线段没有子空间匹配，第四个线段有子空间匹配//////////////////////
				if ((!IsSecond) && (IsFourth))
				{
					for (int _CurI = 0; _CurI < TempFourthPointArr.Num(); ++_CurI)
					{
						/////判断该点到第三条边的距离是否大于80厘米
						float JudgeDis = FMath::PointDistToSegment(FVector(TempFourthPointArr[_CurI], 0.0), FVector(MaxLocalRegion[2], 0.0), FVector(MaxLocalRegion[3], 0.0));
						if (JudgeDis > 80.0)
						{
							CriticalPoints.Add(TempFourthPointArr[_CurI]);
						}
					}
					////////第三个线段有子空间匹配////////////////////
					if (SegMapCriticalPs.Contains(3))
					{
						TArray<FVector2D> ThirdGroup = SegMapCriticalPs[3];
						TArray<int> ThirdIDs = SegMapChildRoomIDs[3];
						if (ThirdGroup.Num() == 1)
						{
							FVector2D TempCriticalP = ThirdGroup[0];
							FVector TempCloestP1 = FMath::ClosestPointOnInfiniteLine(FVector(MaxLocalRegion[0], 0), FVector(MaxLocalRegion[3], 0), FVector(TempCriticalP, 0));
							FVector TempCloestP2 = FMath::ClosestPointOnInfiniteLine(FVector(TempCriticalP, 0), TempCloestP1, FVector(CriticalPoints.Last(), 0));
							CriticalPoints.Add(FVector2D(TempCloestP2));
							TArray<FVector2D> TempThirdPs = SegMapCriticalPs[3];
							if (TempThirdPs.Num() == 1)
							{
								CriticalPoints.Add(TempThirdPs[0]);
								FVector2D TempExtendDir = TempThirdPs[0] - FVector2D(TempCloestP2);
								TempExtendDir.Normalize();
								FVector2D PointFrontDoor = TempThirdPs[0] + 50 * TempExtendDir;
								CriticalPoints.Add(PointFrontDoor);

							}

						}
					}
					else
					{

						if (CriticalPoints.Num() > 0)
						{
							FVector TempCloestP1 = FMath::ClosestPointOnInfiniteLine(FVector(MaxLocalRegion[2], 0), FVector(MaxLocalRegion[3], 0), FVector(CriticalPoints.Last(), 0));
							FVector2D TempDir = FVector2D(CriticalPoints.Last()) - FVector2D(TempCloestP1);
							TempDir.Normalize();
							FVector2D TempNode = FVector2D(TempCloestP1) + 80 * TempDir;
							CriticalPoints.Add(TempNode);
						}

					}
				}


				////////第二个和第四个线段均没有子空间匹配////////////////////////
				if ((!IsSecond) && (!IsFourth))
				{
					int TypeValue = 1;
					////////第三个线段有子空间匹配////////////////////
					if (SegMapCriticalPs.Contains(3))
					{
						TArray<FVector2D> ThirdGroup = SegMapCriticalPs[3];
						TArray<int> ThirdIDs = SegMapChildRoomIDs[3];
						if ((ThirdGroup.Num() > 0) && (TypeValue > 0))
						{
							FVector2D TempMapDir = ChildRoomMapInDir[ThirdIDs[0]];
							FVector2D TempCriticalP = ThirdGroup[0];
							FVector TempCloestP1, TempCloestP2;
							if (TypeValue == 1)
							{
								TempCloestP1 = FMath::ClosestPointOnInfiniteLine(FVector(MaxLocalRegion[0], 0), FVector(MaxLocalRegion[3], 0), FVector(TempCriticalP, 0));
								TempCloestP2 = FMath::ClosestPointOnInfiniteLine(FVector(MaxLocalRegion[0], 0), FVector(MaxLocalRegion[1], 0), TempCloestP1);
							}

							FVector2D TempMoveDir1 = TempCriticalP - FVector2D(TempCloestP1);
							TempMoveDir1.Normalize();
							FVector2D UpdatePoint1 = FVector2D(TempCloestP1) + 80 * TempMoveDir1;
							FVector2D TempMoveDir2 = 0.5*(MaxLocalRegion[0] + MaxLocalRegion[1]) - FVector2D(TempCloestP2);
							TempMoveDir2.Normalize();
							FVector2D UpdatePoint2 = FVector2D(TempCloestP2) + 80 * TempMoveDir2;

							CriticalPoints.Add(UpdatePoint2);
							CriticalPoints.Add(UpdatePoint1);

							TArray<FVector2D> TempThirdPs = SegMapCriticalPs[3];
							if (TempThirdPs.Num() > 0)
							{
								CriticalPoints.Add(TempThirdPs[0]);
								FVector2D TempExtendDir = TempThirdPs[0] - UpdatePoint1;
								TempExtendDir.Normalize();
								FVector2D PointFrontDoor = TempThirdPs[0] + 50 * TempExtendDir;
								CriticalPoints.Add(PointFrontDoor);
							}
						}
						else if ((ThirdGroup.Num() > 0) && (TypeValue == 0))
						{
							FVector2D TempVertex = 0.8*(0.25*(MaxLocalRegion[0] + MaxLocalRegion[1] + MaxLocalRegion[2] + MaxLocalRegion[3])) + 0.2*(0.5*(MaxLocalRegion[0] + MaxLocalRegion[1]));
							CriticalPoints.Add(TempVertex);
						}
					}
				}

				////////第二个和第四个线段均有子空间匹配/////////////////////////
				if ((IsSecond) && (IsFourth))
				{
					int TypeValue = 1;
					////////////////////第三个线段有子空间匹配////////////////////
					if (SegMapCriticalPs.Contains(3))
					{
						TArray<FVector2D> ThirdGroup = SegMapCriticalPs[3];
						TArray<int> ThirdIDs = SegMapChildRoomIDs[3];
						if ((ThirdGroup.Num() > 0) && (TypeValue > 0))
						{
							FVector2D TempMapDir = ChildRoomMapInDir[ThirdIDs[0]];
							FVector2D TempCriticalP = ThirdGroup[0];
							FVector TempCloestP1, TempCloestP2;

							if (TypeValue == 1)
							{
								TempCloestP1 = FMath::ClosestPointOnInfiniteLine(FVector(MaxLocalRegion[0], 0), FVector(MaxLocalRegion[3], 0), FVector(TempCriticalP, 0));
								TempCloestP2 = FMath::ClosestPointOnInfiniteLine(FVector(MaxLocalRegion[0], 0), FVector(MaxLocalRegion[1], 0), TempCloestP1);
							}

							FVector2D TempMoveDir1 = TempCriticalP - FVector2D(TempCloestP1);
							TempMoveDir1.Normalize();
							FVector2D UpdatePoint1 = FVector2D(TempCloestP1) + 80 * TempMoveDir1;
							FVector2D TempMoveDir2 = 0.5*(MaxLocalRegion[0] + MaxLocalRegion[1]) - FVector2D(TempCloestP2);
							TempMoveDir2.Normalize();
							FVector2D UpdatePoint2 = FVector2D(TempCloestP2) + 80 * TempMoveDir2;

							CriticalPoints.Add(UpdatePoint2);
							FVector2D TempNode = 0.5*(UpdatePoint1 + UpdatePoint2);
							CriticalPoints.Add(TempNode);
							CriticalPoints.Add(UpdatePoint1);

							TArray<FVector2D> TempThirdPs = SegMapCriticalPs[3];
							if (TempThirdPs.Num() > 0)
							{
								CriticalPoints.Add(TempThirdPs[0]);
								FVector2D TempExtendDir = TempThirdPs[0] - UpdatePoint1;
								TempExtendDir.Normalize();
								FVector2D PointFrontDoor = TempThirdPs[0] + 50 * TempExtendDir;
								CriticalPoints.Add(PointFrontDoor);
							}
						}
					}
					else
					{
						TArray<FVector2D> TempSecondPoints = SegMapCriticalPs[2];
						FVector TempP1 = FMath::ClosestPointOnInfiniteLine(FVector(MaxLocalRegion[0], 0), FVector(MaxLocalRegion[1], 0), FVector(TempSecondPoints[0], 0));
						CriticalPoints.Add(FVector2D(TempP1));

						FVector TempP2 = FMath::ClosestPointOnInfiniteLine(FVector(MaxLocalRegion[2], 0), FVector(MaxLocalRegion[3], 0), TempP1);
						FVector2D TempMoveDir1 = FVector2D(TempP1) - FVector2D(TempP2);
						TempMoveDir1.Normalize();

						FVector2D TempAddNode1 = FVector2D(TempP2) + 80 * TempMoveDir1;
						CriticalPoints.Add(TempAddNode1);

						TArray<FVector2D> TempFourthPoints = SegMapCriticalPs[4];
						FVector TempP3 = FMath::ClosestPointOnInfiniteLine(FVector(MaxLocalRegion[2], 0), FVector(MaxLocalRegion[3], 0), FVector(TempFourthPoints[0], 0.0));
						FVector2D TempMoveDir2 = TempFourthPoints[0] - FVector2D(TempP3);
						TempMoveDir2.Normalize();
						FVector2D TempAddNode2 = FVector2D(TempP3) + TempMoveDir2 * 80;
						CriticalPoints.Add(TempAddNode2);

						FVector2D TempAddNode3 = TempFourthPoints[0] + 40 * TempMoveDir2;
						CriticalPoints.Add(TempAddNode3);
					}
				}

				CenterPoint = 0.25*(MaxLocalRegion[0] + MaxLocalRegion[1] + MaxLocalRegion[2] + MaxLocalRegion[3]);

			}
			else
			{
				/////////////调整最大局部区域长短//////////////////
				FVector2D CenterOfFirstAndSecond = 0.5*(MaxLocalRegion[0] + MaxLocalRegion[1]);
				FVector2D CenterOfSecondAndThird = 0.5*(MaxLocalRegion[1] + MaxLocalRegion[2]);
				FVector2D CenterOfThirdAndFourth = 0.5*(MaxLocalRegion[2] + MaxLocalRegion[3]);
				FVector2D CenterOfFourthAndFirst = 0.5*(MaxLocalRegion[3] + MaxLocalRegion[0]);

				FVector2D OppoMarkerP;
				bool LocalOppoCenter = FPolygonAlg::LocateSuitableCenter(OppoSiteRoomPs, OppoMarkerP);
				if (!LocalOppoCenter)
				{
					OppoMarkerP = OppoSiteRoomPs[0];
				}

				float FirstL = FVector2D::Distance(CenterOfFirstAndSecond, OppoMarkerP);
				float SecondL = FVector2D::Distance(CenterOfSecondAndThird, OppoMarkerP);
				float ThirdL = FVector2D::Distance(CenterOfThirdAndFourth, OppoMarkerP);
				float FourthL = FVector2D::Distance(CenterOfFourthAndFirst, OppoMarkerP);

				if ((FirstL <= SecondL) && (FirstL <= ThirdL) && (FirstL <= FourthL))
				{
					CriticalPoints.Add(CenterOfFirstAndSecond);
					FVector2D LocalDir = CenterOfFirstAndSecond - CenterOfThirdAndFourth;
					LocalDir.Normalize();
					FVector2D LocalAddP = CenterOfThirdAndFourth + 80 * LocalDir;
					CriticalPoints.Add(LocalAddP);
					CenterPoint = CenterOfThirdAndFourth;
				}
				else if ((SecondL <= FirstL) && (SecondL <= ThirdL) && (SecondL <= FourthL))
				{
					CriticalPoints.Add(CenterOfSecondAndThird);
					FVector2D LocalDir = CenterOfSecondAndThird - CenterOfFourthAndFirst;
					LocalDir.Normalize();
					FVector2D LocalAddP = CenterOfFourthAndFirst + 80 * LocalDir;
					CriticalPoints.Add(LocalAddP);
					CenterPoint = CenterOfFourthAndFirst;
				}
				else if ((ThirdL <= FirstL) && (ThirdL <= SecondL) && (ThirdL <= FourthL))
				{
					CriticalPoints.Add(CenterOfThirdAndFourth);
					FVector2D LocalDir = CenterOfThirdAndFourth - CenterOfFirstAndSecond;
					LocalDir.Normalize();
					FVector2D LocalAddP = CenterOfFirstAndSecond + 80 * LocalDir;
					CriticalPoints.Add(LocalAddP);
					CenterPoint = CenterOfFirstAndSecond;
				}
				else
				{
					CriticalPoints.Add(CenterOfFourthAndFirst);
					FVector2D LocalDir = CenterOfFourthAndFirst - CenterOfSecondAndThird;
					LocalDir.Normalize();
					FVector2D LocalAddP = CenterOfSecondAndThird + 80 * LocalDir;
					CriticalPoints.Add(LocalAddP);
					CenterPoint = CenterOfSecondAndThird;
				}
			}
		}
		else
		{

			/////////////调整最大局部区域长短//////////////////
			FVector2D CenterOfFirstAndSecond = 0.5*(MaxLocalRegion[0] + MaxLocalRegion[1]);
			FVector2D CenterOfSecondAndThird = 0.5*(MaxLocalRegion[1] + MaxLocalRegion[2]);
			FVector2D CenterOfThirdAndFourth = 0.5*(MaxLocalRegion[2] + MaxLocalRegion[3]);
			FVector2D CenterOfFourthAndFirst = 0.5*(MaxLocalRegion[3] + MaxLocalRegion[0]);

			FVector2D OppoMarkerP;
			bool LocalOppoCenter = FPolygonAlg::LocateSuitableCenter(OppoSiteRoomPs, OppoMarkerP);
			if (!LocalOppoCenter)
			{
				OppoMarkerP = OppoSiteRoomPs[0];
			}

			float FirstL = FVector2D::Distance(CenterOfFirstAndSecond, OppoMarkerP);
			float SecondL = FVector2D::Distance(CenterOfSecondAndThird, OppoMarkerP);
			float ThirdL = FVector2D::Distance(CenterOfThirdAndFourth, OppoMarkerP);
			float FourthL = FVector2D::Distance(CenterOfFourthAndFirst, OppoMarkerP);

			if ((FirstL <= SecondL) && (FirstL <= ThirdL) && (FirstL <= FourthL))
			{
				CriticalPoints.Add(CenterOfFirstAndSecond);
				FVector2D LocalDir = CenterOfFirstAndSecond - CenterOfThirdAndFourth;
				LocalDir.Normalize();
				FVector2D LocalAddP = CenterOfThirdAndFourth + 80 * LocalDir;
				CriticalPoints.Add(LocalAddP);
				CenterPoint = CenterOfThirdAndFourth;
			}
			else if ((SecondL <= FirstL) && (SecondL <= ThirdL) && (SecondL <= FourthL))
			{
				CriticalPoints.Add(CenterOfSecondAndThird);
				FVector2D LocalDir = CenterOfSecondAndThird - CenterOfFourthAndFirst;
				LocalDir.Normalize();
				FVector2D LocalAddP = CenterOfFourthAndFirst + 80 * LocalDir;
				CriticalPoints.Add(LocalAddP);
				CenterPoint = CenterOfFourthAndFirst;
			}
			else if ((ThirdL <= FirstL) && (ThirdL <= SecondL) && (ThirdL <= FourthL))
			{
				CriticalPoints.Add(CenterOfThirdAndFourth);
				FVector2D LocalDir = CenterOfThirdAndFourth - CenterOfFirstAndSecond;
				LocalDir.Normalize();
				FVector2D LocalAddP = CenterOfFirstAndSecond + 80 * LocalDir;
				CriticalPoints.Add(LocalAddP);
				CenterPoint = CenterOfFirstAndSecond;
			}
			else
			{
				CriticalPoints.Add(CenterOfFourthAndFirst);
				FVector2D LocalDir = CenterOfFourthAndFirst - CenterOfSecondAndThird;
				LocalDir.Normalize();
				FVector2D LocalAddP = CenterOfSecondAndThird + 80 * LocalDir;
				CriticalPoints.Add(LocalAddP);
				CenterPoint = CenterOfSecondAndThird;
			}
		}
	}
	else
	{
		return false;
	}
	return true;
}


bool UWriteMeshObj_FunctionLibrary::LocateCriticalPointsOfSpecialLivingOrDining(UObject* WorldContextObject,
	const TArray<FVector2D> RoomPs,
	const int IDOfRoom,
	TArray<FVector2D>& PathPoints,
	FVector2D& WatchPoint,
	bool IsLiving)
{
	TArray<AFurnitureModelActor*> LocalModelsOfRoom;
	FindModelsOfRoom(WorldContextObject, RoomPs, LocalModelsOfRoom);

	TArray<AHouseCustomActor*> LocalCustomModels;
	FindCustomModelsOfRoom(WorldContextObject, RoomPs, LocalCustomModels);

	FVector2D LocalRegionCenter;
	FPolygonAlg::LocateSuitableCenter(RoomPs, LocalRegionCenter);


	bool FindMarkerModel = false;
	AFurnitureModelActor* FindFur = nullptr;
	if (LocalModelsOfRoom.Num() > 0)
	{
		for (int _CurM = 0; _CurM < LocalModelsOfRoom.Num(); ++_CurM)
		{
			AFurnitureModelActor* TempFur = LocalModelsOfRoom[_CurM];
			int TempID = 0;
			TempFur->GetModelCategory(TempID);
			if (IsLiving)
			{
				if ((TempID >= 5001) && (TempID <= 5005))
				{
					FindFur = TempFur;
					FindMarkerModel = true;
					break;
				}
			}
			else
			{
				if (TempID == 5016)
				{
					FindFur = TempFur;
					FindMarkerModel = true;
					break;
				}
			}

		}
	}

	if (FindMarkerModel)
	{
		FBox TempBox = FindFur->GetComponentsBoundingBox(true);
		FVector FMin = TempBox.Min;
		FVector FMax = TempBox.Max;
		FVector2D P1(FMin.X, FMin.Y);
		FVector2D P2(FMax.X, FMin.Y);
		FVector2D P3(FMax.X, FMax.Y);
		FVector2D P4(FMin.X, FMax.Y);
		FVector2D BoxCenter = 0.25*(P1 + P2 + P3 + P4);
		float Dis1 = FVector2D::Distance(P1, P2);
		float Dis2 = FVector2D::Distance(P2, P3);
		FVector2D ModelCenter = 0.25*(P1 + P2 + P3 + P4);
		FVector2D SideDir1 = P2 - P1;
		FVector2D SideDir2 = P4 - P1;
		FVector2D BaseDir = SideDir1;
		FVector2D VerticalDir = SideDir2;
		float Side1L = SideDir1.Size();
		float Side2L = SideDir2.Size();
		if (Side1L > Side2L)
		{
			BaseDir = SideDir2;
			VerticalDir = SideDir1;
		}
		BaseDir.Normalize();
		VerticalDir.Normalize();
		FVector2D InterSectP1, InterSectP2;
		FPolygonAlg::CalculateRayToInterSectP(RoomPs, ModelCenter, BaseDir, InterSectP1);
		FPolygonAlg::CalculateRayToInterSectP(RoomPs, ModelCenter, -BaseDir, InterSectP2);
		WatchPoint = 0.5*(InterSectP1 + InterSectP2);
		if (!FPolygonAlg::JudgePointInPolygon(RoomPs, WatchPoint))
		{
			FPolygonAlg::LocateSuitableCenter(RoomPs, WatchPoint);
		}
		float Dis1ToCenter = FVector2D::Distance(InterSectP1, BoxCenter);
		float Dis2ToCenter = FVector2D::Distance(InterSectP2, BoxCenter);
		FVector2D CriticalNode1;
		if (Dis1ToCenter > Dis2ToCenter)
		{
			CriticalNode1 = 0.5*(InterSectP1 + WatchPoint);
		}
		else
		{
			CriticalNode1 = 0.5*(InterSectP2 + WatchPoint);
		}
		FVector2D RotatedDir = BaseDir.GetRotated(90);
		FVector2D InterSectP3, InterSectP4;
		FPolygonAlg::CalculateRayToInterSectP(RoomPs, CriticalNode1, RotatedDir, InterSectP3);
		FPolygonAlg::CalculateRayToInterSectP(RoomPs, CriticalNode1, -RotatedDir, InterSectP4);
		FVector2D Node1 = 2.0 / 3.0*InterSectP3 + 1.0 / 3.0*CriticalNode1;
		FVector2D Node2 = 2.0 / 3.0*InterSectP4 + 1.0 / 3.0*CriticalNode1;
		bool Node1IsInModel = false;
		bool Node2IsInModel = false;
		for (auto TempModel : LocalModelsOfRoom)
		{
			FString ModelName = TempModel->GetName();
			if (!ModelName.Contains("Light"))
			{
				FBox TempBox = TempModel->GetComponentsBoundingBox(true);
				if (TempBox.IsInside(FVector(Node1, 130)))
				{
					Node1IsInModel = true;
					break;
				}
			}
		}
		for (auto TempModel : LocalCustomModels)
		{
			FString ModelName = TempModel->GetName();
			if (!ModelName.Contains("Light"))
			{
				FBox TempBox = TempModel->GetComponentsBoundingBox(true);
				if (TempBox.IsInside(FVector(Node1, 130)))
				{
					Node1IsInModel = true;
					break;
				}
			}
		}
		for (auto TempModel : LocalModelsOfRoom)
		{
			FString ModelName = TempModel->GetName();
			if (!ModelName.Contains("Light"))
			{
				FBox TempBox = TempModel->GetComponentsBoundingBox(true);
				if (TempBox.IsInside(FVector(Node2, 130)))
				{
					Node2IsInModel = true;
					break;
				}
			}
		}
		for (auto TempModel : LocalCustomModels)
		{
			FString ModelName = TempModel->GetName();
			if (!ModelName.Contains("Light"))
			{
				FBox TempBox = TempModel->GetComponentsBoundingBox(true);
				if (TempBox.IsInside(FVector(Node2, 130)))
				{
					Node2IsInModel = true;
					break;
				}
			}
		}
		if (!Node1IsInModel)
		{
			PathPoints.AddUnique(Node1);
		}
		if (!Node2IsInModel)
		{
			PathPoints.AddUnique(Node2);
		}
		if (PathPoints.Num() == 0)
		{
			bool WatchPointIsInModel = false;
			for (auto TempModel : LocalModelsOfRoom)
			{
				FBox TempBox = TempModel->GetComponentsBoundingBox(true);
				if (TempBox.IsInside(FVector(WatchPoint, 130)))
				{
					WatchPointIsInModel = true;
					break;
				}
			}
			for (auto TempModel : LocalCustomModels)
			{
				FBox TempBox = TempModel->GetComponentsBoundingBox(true);
				if (TempBox.IsInside(FVector(WatchPoint, 130)))
				{
					WatchPointIsInModel = true;
					break;
				}
			}
			if (!WatchPointIsInModel)
			{
				PathPoints.AddUnique(WatchPoint);
			}
			else
			{
				PathPoints.AddUnique(LocalRegionCenter);
			}
		}
	}
	else
	{
		PathPoints.AddUnique(LocalRegionCenter);
		WatchPoint = FVector2D(0.0, 0.0);
	}

	if (PathPoints.Num() == 0)
	{
		return false;
	}
	return true;
}



bool UWriteMeshObj_FunctionLibrary::LocateCriticalPointsOfBalcony(UObject* WorldContextObject,
	const TArray<FVector2D> RoomPs,
	const int IDOfRoom,
	const TArray<FVector> DoorPoints,
	const FVector2D BasePoint,
	TArray<FVector2D>& CriticalPoints,
	FVector2D& RegionWatchPoint,
	int& ActionMarker)
{
	if ((RoomPs.Num() == 0) || (DoorPoints.Num() == 0))
	{
		return false;
	}


	FVector2D TempDoorCenter = FVector2D(0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]));
	float LengthOfSide1 = FVector::Distance(DoorPoints[0], DoorPoints[1]);
	float LengthOfSide2 = FVector::Distance(DoorPoints[0], DoorPoints[2]);
	FVector2D BaseDir, FinalDir;
	if (LengthOfSide1 > LengthOfSide2)
	{
		FVector2D TempDir = FVector2D(DoorPoints[1] - DoorPoints[0]);
		TempDir.Normalize();
		BaseDir = TempDir.GetRotated(90);
	}
	else
	{
		FVector2D TempDir = FVector2D(DoorPoints[2] - DoorPoints[0]);
		TempDir.Normalize();
		BaseDir = TempDir.GetRotated(90);
	}
	FVector2D ExtendPoint1 = BasePoint + 125 * BaseDir;
	FVector2D ExtendPoint2 = BasePoint - 125 * BaseDir;
	bool P1IsLyingInRegion = FPolygonAlg::JudgePointInPolygon(RoomPs, ExtendPoint1);
	bool P2IsLyingInRegion = FPolygonAlg::JudgePointInPolygon(RoomPs, ExtendPoint2);
	if (P1IsLyingInRegion)
	{
		FinalDir = BaseDir;
		CriticalPoints.Add(ExtendPoint1);
	}
	if (P2IsLyingInRegion)
	{
		FinalDir = -BaseDir;
		CriticalPoints.Add(ExtendPoint2);
	}

	FVector2D TempInterSectP1, TempInterSectP2;
	if (CriticalPoints.Num() > 0)
	{
		/////////////////////////////////微调阳台路径点//////////////////////////////////////////////////
		FPolygonAlg::CalculateRayToInterSectP(RoomPs, CriticalPoints.Last(), FinalDir, TempInterSectP1);
		RegionWatchPoint = 0.5*(TempInterSectP1 + CriticalPoints.Last());
	}
	else
	{
		/////////////////////////////////微调阳台路径点//////////////////////////////////////////////////
		//FPolygonAlg::CalculateRayToInterSectP(RoomPs, TempDoorCenter, FinalDir, TempInterSectP2);
		FVector2D SuitableCenter;
		bool IsLocatedCenter = FPolygonAlg::LocateSuitableCenter(RoomPs, SuitableCenter);
		if (IsLocatedCenter)
		{
			FVector TempCloestP = FMath::ClosestPointOnInfiniteLine(DoorPoints[0], DoorPoints[1], FVector(SuitableCenter, 0));
			FinalDir = SuitableCenter - FVector2D(TempCloestP);
			FinalDir.Normalize();
			CriticalPoints.Add(0.5*(FVector2D(TempCloestP) + SuitableCenter));
		}
		RegionWatchPoint = SuitableCenter;
	}

	//////////////////////////////找出阳台区域最大的模型////////////////////////////
	ActionMarker = 1;
	TArray<AFurnitureModelActor*> ModelsOfRoom;
	FindModelsOfRoom(WorldContextObject, RoomPs, ModelsOfRoom);
	bool FindModel = false;
	FBox MaxTargetBox;
	if (ModelsOfRoom.Num() != 0)
	{
		float MaxV = 0.0;
		for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
		{
			FBox TempBox = ModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
			FVector FMin = TempBox.Min;
			FVector FMax = TempBox.Max;
			bool ModelIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, RoomPs);
			float ModelZ = FMax.Z - FMin.Z;
			if ((ModelIsUseful) && (ModelZ <= 250))
			{
				float BoxV = TempBox.GetVolume();
				if ((MaxV <= 0.000001) || (MaxV < BoxV))
				{
					MaxV = BoxV;
					MaxTargetBox = TempBox;
				}
			}
		}
		if (MaxV > 1.0)
		{
			FindModel = true;
		}
	}
	if (FindModel)
	{
		FBox LargeBox = MaxTargetBox;
		FVector LargeModelCenter = LargeBox.GetCenter();
		FVector2D LargeModelCenter2D = FVector2D(LargeModelCenter);
		FVector2D PointDir = LargeModelCenter2D - CriticalPoints.Last();
		PointDir.Normalize();
		float CrossValue = FVector2D::CrossProduct(FinalDir, PointDir);
		if (CrossValue < 0.001f)
		{
			/////////////向左旋转标志//////////////////
			ActionMarker = 2;
		}
	}

	return true;
}


bool UWriteMeshObj_FunctionLibrary::LocateCriticalPointsOfKitchen(UObject* WorldContextObject,
	const TArray<FVector2D> RoomPs,
	const int IDOfRoom,
	TArray<FVector2D>& CriticalPoints,
	FVector2D& RegionWatchPoint)
{
	if (RoomPs.Num() == 0)
	{
		return false;
	}
	FVector2D TempLocatedCenter;
	bool IsLocatedCenter = FPolygonAlg::LocateSuitableCenter(RoomPs, TempLocatedCenter);
	if (IsLocatedCenter)
	{
		RegionWatchPoint = TempLocatedCenter;
	}
	TArray<FVector> DoorPoints;
	FVector2D FinalDir;
	bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, IDOfRoom, DoorPoints);
	if (GetDoorSuccess)
	{
		int NumOfDoors = DoorPoints.Num() / 8;
		if (NumOfDoors >= 1)
		{
			FVector2D TempDoorCenter = FVector2D(0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]));
			float LengthOfSide1 = FVector::Distance(DoorPoints[0], DoorPoints[1]);
			float LengthOfSide2 = FVector::Distance(DoorPoints[1], DoorPoints[2]);
			FVector2D BaseDir;
			if (LengthOfSide1 > LengthOfSide2)
			{
				FVector2D TempDir = FVector2D(DoorPoints[1] - DoorPoints[0]);
				TempDir.Normalize();
				BaseDir = TempDir.GetRotated(90);
			}
			else
			{
				FVector2D TempDir = FVector2D(DoorPoints[2] - DoorPoints[1]);
				TempDir.Normalize();
				BaseDir = TempDir.GetRotated(90);
			}

			FVector2D ExtendPoint1 = TempDoorCenter + 30 * BaseDir;
			FVector2D ExtendPoint2 = TempDoorCenter - 30 * BaseDir;

			bool P1IsLyingInRegion = FPolygonAlg::JudgePointInPolygon(RoomPs, ExtendPoint1);
			bool P2IsLyingInRegion = FPolygonAlg::JudgePointInPolygon(RoomPs, ExtendPoint2);

			if (P1IsLyingInRegion)
			{
				CriticalPoints.Add(ExtendPoint1);
				FinalDir = BaseDir;
			}

			if (P2IsLyingInRegion)
			{
				CriticalPoints.Add(ExtendPoint2);
				FinalDir = -BaseDir;
			}

			if (CriticalPoints.Num() > 0)
			{
				RegionWatchPoint = CriticalPoints.Last() + 10 * FinalDir;
			}
		}
	}
	else
	{
		CriticalPoints.Add(TempLocatedCenter);
		RegionWatchPoint = FVector2D(0.0, 0.0);
	}
	return true;
}


bool UWriteMeshObj_FunctionLibrary::LocateCriticalPointsOfRoom(UObject* WorldContextObject,
	const TArray<FVector2D> LivingRoomPs,
	const TArray<FVector2D> DiningRoomPs,
	const TArray<FVector2D> RoomPoints,
	const int IDOfRoom,
	TArray<FVector2D>& CriticalPoints,
	FVector2D& RoomCenter)
{
	if (RoomPoints.Num() == 0)
	{
		return false;
	}
	/////////////////////计算区域中心////////////////////////
	const float RoomHeight = 110.0f;
	TArray<FVector2D> UpdateSmallRegionCenters;
	TMap<FVector2D, TArray<FVector2D>> CenterMapLocalRegions;
	bool IsLocated = FPolygonAlg::LocateCentersOfRoom(RoomPoints, RoomCenter, UpdateSmallRegionCenters, CenterMapLocalRegions);
	if (!IsLocated)
	{
		return false;
	}
	/////////////////////////////////////////////////////////////
	TArray<FVector> DoorPoints;
	bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, IDOfRoom, DoorPoints);
	if (GetDoorSuccess)
	{
		int NumOfDoors = DoorPoints.Num() / 8;
		if (NumOfDoors == 1)
		{
			FVector2D TempDoorCenter = FVector2D(0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]));
			FVector2D DirOfLongSide = FVector2D(DoorPoints[1] - DoorPoints[0]);
			DirOfLongSide = DirOfLongSide.GetSafeNormal();
			FVector2D DirOfRotated = DirOfLongSide.GetRotated(90);
			FVector2D ExtendP = TempDoorCenter + 40 * DirOfRotated;
			bool IsInRegion = FPolygonAlg::JudgePointInPolygon(RoomPoints, ExtendP);
			if (IsInRegion)
			{
				FVector2D AddPoint1 = TempDoorCenter + 50 * DirOfRotated;
				CriticalPoints.Add(AddPoint1);
			}
			else
			{
				FVector2D AddPoint1 = TempDoorCenter - 50 * DirOfRotated;
				CriticalPoints.Add(AddPoint1);
			}

		}
		else
		{
			int TargetDoorIndex = 0;
			bool FindResult = false;
			FVector2D InRoomDir, TargetDoorCenter;
			for (int _CurDoor = 0; _CurDoor < NumOfDoors; ++_CurDoor)
			{
				FVector TempDoorCenter3D = 0.25*(DoorPoints[8 * _CurDoor] + DoorPoints[8 * _CurDoor + 1] + DoorPoints[8 * _CurDoor + 2] + DoorPoints[8 * _CurDoor + 3]);
				FVector2D TempDoorCenter = FVector2D(TempDoorCenter3D);
				FVector2D TempDir = FVector2D(DoorPoints[8 * _CurDoor + 1] - DoorPoints[8 * _CurDoor]);
				TempDir = TempDir.GetSafeNormal();
				FVector2D TempRotatedDir = TempDir.GetRotated(90);
				FVector2D TempExtendP1 = TempDoorCenter + 40 * TempRotatedDir;
				FVector2D TempExtendP2 = TempDoorCenter - 40 * TempRotatedDir;
				if (LivingRoomPs.Num() != 0)
				{
					bool P1IsInRegion = FPolygonAlg::JudgePointInPolygon(LivingRoomPs, TempExtendP1);
					bool P2IsInRegion = FPolygonAlg::JudgePointInPolygon(LivingRoomPs, TempExtendP2);
					if (P1IsInRegion)
					{
						TargetDoorIndex = _CurDoor;
						InRoomDir = -TempRotatedDir;
						TargetDoorCenter = TempDoorCenter;
						FindResult = true;
						break;
					}

					if (P2IsInRegion)
					{
						TargetDoorIndex = _CurDoor;
						InRoomDir = TempRotatedDir;
						TargetDoorCenter = TempDoorCenter;
						FindResult = true;
						break;
					}
				}

			}
			if (!FindResult)
			{
				for (int _CurDoor = 0; _CurDoor < NumOfDoors; ++_CurDoor)
				{
					FVector2D TempDoorCenter = FVector2D(0.25*(DoorPoints[8 * _CurDoor] + DoorPoints[8 * _CurDoor + 1] + DoorPoints[8 * _CurDoor + 2] + DoorPoints[8 * _CurDoor + 3]));
					FVector2D TempDir = FVector2D(DoorPoints[8 * _CurDoor + 1] - DoorPoints[8 * _CurDoor]);
					TempDir = TempDir.GetSafeNormal();
					FVector2D TempRotatedDir = TempDir.GetRotated(90);
					FVector2D TempExtendP1 = TempDoorCenter + 40 * TempRotatedDir;
					FVector2D TempExtendP2 = TempDoorCenter - 40 * TempRotatedDir;
					if (DiningRoomPs.Num() != 0)
					{
						bool P1IsInRegion = FPolygonAlg::JudgePointInPolygon(DiningRoomPs, TempExtendP1);
						bool P2IsInRegion = FPolygonAlg::JudgePointInPolygon(DiningRoomPs, TempExtendP2);
						if (P1IsInRegion)
						{
							TargetDoorIndex = _CurDoor;
							InRoomDir = -TempRotatedDir;
							TargetDoorCenter = TempDoorCenter;
							FindResult = true;
							break;
						}
						if (P2IsInRegion)
						{
							TargetDoorIndex = _CurDoor;
							InRoomDir = TempRotatedDir;
							TargetDoorCenter = TempDoorCenter;
							FindResult = true;
							break;
						}
					}
				}
			}
			if (FindResult)
			{
				FVector2D AddPoint1 = TargetDoorCenter + 50 * InRoomDir;
				CriticalPoints.Add(AddPoint1);
			}
		}
	}

	TArray<FVector2D> UpdateRegionPs;
	FPolygonAlg::MergeCollinearPoints(RoomPoints, UpdateRegionPs);
	TArray<AFurnitureModelActor*> ModelsOfRoom;
	FindModelsOfRoom(WorldContextObject, UpdateRegionPs, ModelsOfRoom);
	AFurnitureModelActor* FindFur = nullptr;
	bool FindModel = false;
	bool IsSame = false;
	for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
	{
		AFurnitureModelActor* TempFur = ModelsOfRoom[_CurM];
		int TempID = 0;
		TempFur->GetModelCategory(TempID);
		if ((TempID == 5009) || (TempID == 5010))
		{
			FindFur = TempFur;
			FindModel = true;
			break;
		}
	}
	if (FindModel)
	{
		FBox TempBox = FindFur->GetComponentsBoundingBox(true);
		FVector FMin = TempBox.Min;
		FVector FMax = TempBox.Max;
		FVector2D P1(FMin.X, FMin.Y);
		FVector2D P2(FMax.X, FMin.Y);
		FVector2D P3(FMax.X, FMax.Y);
		FVector2D P4(FMin.X, FMax.Y);
		FVector2D BoxCenter = 0.25*(P1 + P2 + P3 + P4);
		float Dis1 = FVector2D::Distance(P1, P2);
		float Dis2 = FVector2D::Distance(P2, P3);
		FVector2D TempWatchP;
		FVector2D TempDir;
		FVector TempAdjustWatchP;
		const float ExtendL = 45;
		if (Dis1 > Dis2)
		{
			FVector2D TempPointVec = P2 - P1;
			TempPointVec = TempPointVec.GetSafeNormal();
			FVector2D TryP1 = BoxCenter + TempPointVec * (0.5*Dis1 + ExtendL);
			FVector2D TryP2 = BoxCenter - TempPointVec * (0.5*Dis1 + ExtendL);
			bool JudgeTryP1 = FPolygonAlg::JudgePointOnOrInPolygon(UpdateRegionPs, TryP1);
			bool JudgeTryP2 = FPolygonAlg::JudgePointOnOrInPolygon(UpdateRegionPs, TryP2);
			if (JudgeTryP1&&JudgeTryP2)
			{
				TempPointVec = P3 - P2;
				TempPointVec = TempPointVec.GetSafeNormal();
				TryP1 = BoxCenter + TempPointVec * (0.5*Dis2 + ExtendL);
				TryP2 = BoxCenter - TempPointVec * (0.5*Dis2 + ExtendL);
				JudgeTryP1 = FPolygonAlg::JudgePointOnOrInPolygon(UpdateRegionPs, TryP1);
				JudgeTryP2 = FPolygonAlg::JudgePointOnOrInPolygon(UpdateRegionPs, TryP2);
				if (JudgeTryP1 || JudgeTryP2)
				{
					FVector2D TempInterSectP1, TempInterSectP2;
					FPolygonAlg::CalculateRayToInterSectP(UpdateRegionPs, BoxCenter, TempPointVec, TempInterSectP1);
					FPolygonAlg::CalculateRayToInterSectP(UpdateRegionPs, BoxCenter, -TempPointVec, TempInterSectP2);
					float DisToInterSectP1 = FVector2D::Distance(BoxCenter, TempInterSectP1);
					float DisToInterSectP2 = FVector2D::Distance(BoxCenter, TempInterSectP2);
					if ((DisToInterSectP1 >= 20) || (DisToInterSectP2 >= 20))
					{
						if (DisToInterSectP1 > DisToInterSectP2)
						{
							TempWatchP = 0.5*(0.5*(P4 + P3) + TempInterSectP1);
							TempDir = -TempPointVec;
							FVector2D TempExtendWatchP = TempWatchP + 100 * TempDir;
							if (CriticalPoints.Num() > 0)
							{
								TempAdjustWatchP = FMath::ClosestPointOnInfiniteLine(FVector(TempWatchP, 0), FVector(TempExtendWatchP, 0), FVector(CriticalPoints.Last(), 0));
							}

						}
						else
						{
							TempWatchP = 0.5*(0.5*(P2 + P1) + TempInterSectP2);
							TempDir = TempPointVec;
							FVector2D TempExtendWatchP = TempWatchP + 100 * TempDir;
							if (CriticalPoints.Num() > 0)
							{
								TempAdjustWatchP = FMath::ClosestPointOnInfiniteLine(FVector(TempWatchP, 0), FVector(TempExtendWatchP, 0), FVector(CriticalPoints.Last(), 0));
							}
						}
					}
				}
				else
				{
					IsSame = true;
				}
			}
			else
			{
				FVector2D TempInterSectP1, TempInterSectP2;
				FPolygonAlg::CalculateRayToInterSectP(UpdateRegionPs, BoxCenter, TempPointVec, TempInterSectP1);
				FPolygonAlg::CalculateRayToInterSectP(UpdateRegionPs, BoxCenter, -TempPointVec, TempInterSectP2);
				float DisToInterSectP1 = FVector2D::Distance(BoxCenter, TempInterSectP1);
				float DisToInterSectP2 = FVector2D::Distance(BoxCenter, TempInterSectP2);
				if ((DisToInterSectP1 >= 20) || (DisToInterSectP2 >= 20))
				{
					if (DisToInterSectP1 > DisToInterSectP2)
					{
						TempWatchP = 0.5*(0.5*(P2 + P3) + TempInterSectP1);
						TempDir = -TempPointVec;
						FVector2D TempExtendWatchP = TempWatchP + 100 * TempDir;
						if (CriticalPoints.Num() > 0)
						{
							TempAdjustWatchP = FMath::ClosestPointOnInfiniteLine(FVector(TempWatchP, 0), FVector(TempExtendWatchP, 0), FVector(CriticalPoints.Last(), 0));
						}

					}
					else
					{
						TempWatchP = 0.5*(0.5*(P4 + P1) + TempInterSectP2);
						TempDir = TempPointVec;
						FVector2D TempExtendWatchP = TempWatchP + 100 * TempDir;
						if (CriticalPoints.Num() > 0)
						{
							TempAdjustWatchP = FMath::ClosestPointOnInfiniteLine(FVector(TempWatchP, 0), FVector(TempExtendWatchP, 0), FVector(CriticalPoints.Last(), 0));
						}
					}
				}
			}
		}
		else
		{
			FVector2D TempPointVec = P3 - P2;
			TempPointVec = TempPointVec.GetSafeNormal();
			FVector2D TryP1 = BoxCenter + TempPointVec * (0.5*Dis2 + ExtendL);
			FVector2D TryP2 = BoxCenter - TempPointVec * (0.5*Dis2 + ExtendL);
			bool JudgeTryP1 = FPolygonAlg::JudgePointOnOrInPolygon(UpdateRegionPs, TryP1);
			bool JudgeTryP2 = FPolygonAlg::JudgePointOnOrInPolygon(UpdateRegionPs, TryP2);
			if (JudgeTryP1 && JudgeTryP2)
			{
				TempPointVec = P2 - P1;
				TempPointVec = TempPointVec.GetSafeNormal();
				TryP1 = BoxCenter + TempPointVec * (0.5*Dis1 + ExtendL);
				TryP2 = BoxCenter - TempPointVec * (0.5*Dis1 + ExtendL);
				JudgeTryP1 = FPolygonAlg::JudgePointOnOrInPolygon(UpdateRegionPs, TryP1);
				JudgeTryP2 = FPolygonAlg::JudgePointOnOrInPolygon(UpdateRegionPs, TryP2);
				if (JudgeTryP1 || JudgeTryP2)
				{
					FVector2D TempInterSectP1, TempInterSectP2;
					FPolygonAlg::CalculateRayToInterSectP(UpdateRegionPs, BoxCenter, TempPointVec, TempInterSectP1);
					FPolygonAlg::CalculateRayToInterSectP(UpdateRegionPs, BoxCenter, -TempPointVec, TempInterSectP2);
					float DisToInterSectP1 = FVector2D::Distance(BoxCenter, TempInterSectP1);
					float DisToInterSectP2 = FVector2D::Distance(BoxCenter, TempInterSectP2);
					if ((DisToInterSectP1 >= 20) || (DisToInterSectP2 >= 20))
					{
						if (DisToInterSectP1 > DisToInterSectP2)
						{
							TempWatchP = 0.5*(0.5*(P2 + P3) + TempInterSectP1);
							TempDir = -TempPointVec;
							FVector2D TempExtendWatchP = TempWatchP + 100 * TempDir;
							if (CriticalPoints.Num() > 0)
							{
								TempAdjustWatchP = FMath::ClosestPointOnInfiniteLine(FVector(TempWatchP, 0), FVector(TempExtendWatchP, 0), FVector(CriticalPoints.Last(), 0));
							}

						}
						else
						{
							TempWatchP = 0.5*(0.5*(P4 + P1) + TempInterSectP2);
							TempDir = TempPointVec;
							FVector2D TempExtendWatchP = TempWatchP + 100 * TempDir;
							if (CriticalPoints.Num() > 0)
							{
								TempAdjustWatchP = FMath::ClosestPointOnInfiniteLine(FVector(TempWatchP, 0), FVector(TempExtendWatchP, 0), FVector(CriticalPoints.Last(), 0));
							}
						}
					}
				}
				else
				{
					IsSame = true;
				}
			}
			else
			{
				FVector2D TempInterSectP1, TempInterSectP2;
				FPolygonAlg::CalculateRayToInterSectP(UpdateRegionPs, BoxCenter, TempPointVec, TempInterSectP1);
				FPolygonAlg::CalculateRayToInterSectP(UpdateRegionPs, BoxCenter, -TempPointVec, TempInterSectP2);
				float DisToInterSectP1 = FVector2D::Distance(BoxCenter, TempInterSectP1);
				float DisToInterSectP2 = FVector2D::Distance(BoxCenter, TempInterSectP2);
				if ((DisToInterSectP1 >= 20) || (DisToInterSectP2 >= 20))
				{
					if (DisToInterSectP1 > DisToInterSectP2)
					{
						TempWatchP = 0.5*(0.5*(P3 + P4) + TempInterSectP1);
						TempDir = -TempPointVec;
						FVector2D TempExtendWatchP = TempWatchP + 100 * TempDir;
						if (CriticalPoints.Num() > 0)
						{
							TempAdjustWatchP = FMath::ClosestPointOnInfiniteLine(FVector(TempWatchP, 0), FVector(TempExtendWatchP, 0), FVector(CriticalPoints.Last(), 0));
						}
					}
					else
					{
						TempWatchP = 0.5*(0.5*(P1 + P2) + TempInterSectP2);
						TempDir = TempPointVec;
						FVector2D TempExtendWatchP = TempWatchP + 100 * TempDir;
						if (CriticalPoints.Num() > 0)
						{
							TempAdjustWatchP = FMath::ClosestPointOnInfiniteLine(FVector(TempWatchP, 0), FVector(TempExtendWatchP, 0), FVector(CriticalPoints.Last(), 0));
						}
					}
				}
			}
		}

		if (!IsSame)
		{
			bool FindPointInModel = false;
			for (auto TempModelInRoom : ModelsOfRoom)
			{
				FString ModelName = TempModelInRoom->GetName();
				if (!ModelName.Contains("Light"))
				{
					FBox TempBox = TempModelInRoom->GetComponentsBoundingBox(true);
					bool IfInModel = TempBox.IsInsideOrOn(FVector(TempWatchP, RoomHeight));
					if (IfInModel)
					{
						FVector FMin = TempBox.Min;
						FVector FMax = TempBox.Max;
						bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, UpdateRegionPs);
						if (ModelBoxIsUseful)
						{
							FindPointInModel = true;
							break;
						}
					}
				}
			}
			bool IsInSide = false;
			IsInSide = FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, FVector2D(TempAdjustWatchP));


			if (!IsInSide)
			{
				FVector2D TempRoV = TempDir.GetRotated(90);
				FVector2D TempSideP = TempWatchP + 200 * TempRoV;
				if (CriticalPoints.Num() > 0)
				{
					TempAdjustWatchP = FMath::ClosestPointOnInfiniteLine(FVector(TempWatchP, 0), FVector(TempSideP, 0), FVector(CriticalPoints.Last(), 0));
					if (FPolygonAlg::JudgePointInPolygon(UpdateRegionPs, FVector2D(TempAdjustWatchP)))
					{
						CriticalPoints.Add(FVector2D(TempAdjustWatchP));
						if (!FindPointInModel)
						{
							CriticalPoints.Add(FVector2D(TempWatchP));
						}
					}
				}

			}

			if ((!FindPointInModel) && (IsInSide))
			{
				CriticalPoints.Add(FVector2D(TempAdjustWatchP));
			}
			else
			{
				IsSame = true;
			}
		}
	}

	////////////////////////////判定区域内有没有窗户///////////////////////
	if (!IsSame)
	{
		TArray<FVector> WindowPoints;
		bool GetWindowSuccess = GetWindowsOfRegion(WorldContextObject, IDOfRoom, WindowPoints);
		if (GetWindowSuccess)
		{
			int NumOfWindows = WindowPoints.Num() / 8;
			if (NumOfWindows == 1)
			{
				FVector2D TempWindowCenter = FVector2D(0.25*(WindowPoints[0] + WindowPoints[1] + WindowPoints[2] + WindowPoints[3]));
				FVector2D WindowSegMiddle1 = FVector2D(0.5*(WindowPoints[0] + WindowPoints[1]));
				FVector2D WindowSegMiddle2 = FVector2D(0.5*(WindowPoints[2] + WindowPoints[3]));
				float HalfThickness = 0.5*(FVector2D::Distance(WindowSegMiddle1, WindowSegMiddle2));
				FVector2D TempDir = FVector2D(WindowPoints[1] - WindowPoints[0]);
				TempDir = TempDir.GetSafeNormal();
				FVector2D TempDirOfRotated = TempDir.GetRotated(90);
				FVector2D TempExtendP = TempWindowCenter + (50 + HalfThickness) * TempDirOfRotated;

				bool IsInRoom = FPolygonAlg::JudgePointInPolygon(RoomPoints, TempExtendP);
				if (IsInRoom)
				{
					if (CriticalPoints.Num() == 1)
					{
						TArray<FVector2D> UpdateSmallRegionCenters;
						TMap<FVector2D, TArray<FVector2D>>CenterMapLocalRegions;
						FVector2D MaxRegionCenter;
						bool LocCenter = FPolygonAlg::LocateCentersOfRoom(RoomPoints, MaxRegionCenter, UpdateSmallRegionCenters, CenterMapLocalRegions);
						if (LocCenter)
						{
							FVector2D TempMiddleP = 0.5*(MaxRegionCenter + CriticalPoints[0]);
							CriticalPoints.Add(TempMiddleP);
						}
					}
					else if (CriticalPoints.Num() >= 2)
					{
						FVector TempP = FMath::ClosestPointOnInfiniteLine(FVector(CriticalPoints[0], 0), FVector(CriticalPoints[1], 0), FVector(TempExtendP, 0));
						CriticalPoints.Add(FVector2D(TempP));
						CriticalPoints.Add(TempExtendP);
					}
				}
				else
				{
					if (CriticalPoints.Num() == 1)
					{
						TArray<FVector2D> UpdateSmallRegionCenters;
						TMap<FVector2D, TArray<FVector2D>>CenterMapLocalRegions;
						FVector2D MaxRegionCenter;
						bool LocCenter = FPolygonAlg::LocateCentersOfRoom(RoomPoints, MaxRegionCenter, UpdateSmallRegionCenters, CenterMapLocalRegions);
						if (LocCenter)
						{
							FVector2D TempMiddleP = 0.5*(MaxRegionCenter + CriticalPoints[0]);
							CriticalPoints.Add(TempMiddleP);
						}
					}
					else if (CriticalPoints.Num() >= 2)
					{
						FVector2D TempExtendP2 = TempWindowCenter - (50 + HalfThickness) * TempDirOfRotated;
						FVector TempP = FMath::ClosestPointOnInfiniteLine(FVector(CriticalPoints[0], 0), FVector(CriticalPoints[1], 0), FVector(TempExtendP2, 0));
						CriticalPoints.Add(FVector2D(TempP));
						CriticalPoints.Add(TempExtendP2);
					}

				}
			}
		}
	}
	else
	{
		TArray<FVector2D> UpdateSmallRegionCenters;
		TMap<FVector2D, TArray<FVector2D>>CenterMapLocalRegions;
		FVector2D MaxRegionCenter;
		bool LocCenter = FPolygonAlg::LocateCentersOfRoom(RoomPoints, MaxRegionCenter, UpdateSmallRegionCenters, CenterMapLocalRegions);
		if ((LocCenter) && (CriticalPoints.Num() > 0))
		{
			FVector2D TempMiddleP = 0.5*(MaxRegionCenter + CriticalPoints.Last());
			CriticalPoints.Add(TempMiddleP);
		}
	}
	///////////////////预防卧室内没有路径点/////////////////////////
	if (CriticalPoints.Num() == 0)
	{
		int NumOfDoors = DoorPoints.Num() / 8;

		if (NumOfDoors == 1)
		{
			FVector2D TempDoorCenter = FVector2D(0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]));
			FVector2D DirOfLongSide = FVector2D(DoorPoints[1] - DoorPoints[0]);
			DirOfLongSide = DirOfLongSide.GetSafeNormal();
			FVector2D DirOfRotated = DirOfLongSide.GetRotated(90);
			FVector2D ExtendP = TempDoorCenter + 40 * DirOfRotated;
			bool IsInRegion = FPolygonAlg::JudgePointInPolygon(RoomPoints, ExtendP);
			if (IsInRegion)
			{
				FVector2D AddPoint1 = TempDoorCenter + 50 * DirOfRotated;
				CriticalPoints.Add(AddPoint1);
			}
			else
			{
				FVector2D AddPoint1 = TempDoorCenter - 50 * DirOfRotated;
				CriticalPoints.Add(AddPoint1);
			}

		}
		else
		{
			int TargetLocalDoorIndex = 0;
			float MaxDisToRoomCenter = 0.0f;
			FVector2D TargetLocalDoorCenter;
			for (int _CurDoor = 0; _CurDoor < NumOfDoors; ++_CurDoor)
			{
				FVector TempDoorCenter3D = 0.25*(DoorPoints[8 * _CurDoor] + DoorPoints[8 * _CurDoor + 1] + DoorPoints[8 * _CurDoor + 2] + DoorPoints[8 * _CurDoor + 3]);
				FVector2D TempDoorCenter = FVector2D(TempDoorCenter3D);
				float DoorToCenter = FVector2D::Distance(TempDoorCenter, RoomCenter);
				if ((MaxDisToRoomCenter <= 0.001f) || (DoorToCenter > MaxDisToRoomCenter))
				{
					MaxDisToRoomCenter = DoorToCenter;
					TargetLocalDoorIndex = _CurDoor;
					TargetLocalDoorCenter = TempDoorCenter;
				}
			}

			FVector2D TempDir = FVector2D(DoorPoints[8 * TargetLocalDoorIndex + 1] - DoorPoints[8 * TargetLocalDoorIndex]);
			TempDir = TempDir.GetSafeNormal();
			FVector2D TempRotatedDir = TempDir.GetRotated(90);
			FVector2D TempExtendP1 = TargetLocalDoorCenter + 40 * TempRotatedDir;
			FVector2D TempExtendP2 = TargetLocalDoorCenter - 40 * TempRotatedDir;

			bool P1IsInRegion = FPolygonAlg::JudgePointInPolygon(RoomPoints, TempExtendP1);
			if (P1IsInRegion)
			{
				CriticalPoints.Add(TempExtendP1);
			}
			bool P2IsInRegion = FPolygonAlg::JudgePointInPolygon(RoomPoints, TempExtendP2);
			if (P2IsInRegion)
			{
				CriticalPoints.Add(TempExtendP2);
			}
			if (CriticalPoints.Num() == 1)
			{
				CriticalPoints.Add(0.5*(CriticalPoints.Last() + RoomCenter));
			}
			else if (CriticalPoints.Num() == 0)
			{
				CriticalPoints.Add(RoomCenter);
			}
		}

	}
	return true;
}




bool UWriteMeshObj_FunctionLibrary::LocateTwoCriticalPointsOfBalcony(UObject* WorldContextObject,
	const TArray<FVector2D> RoomPs,
	const int IDOfRoom,
	TArray<FVector2D>& CriticalPoints,
	FVector2D& RegionWatchPoint)
{
	if (RoomPs.Num() == 0)
	{
		return false;
	}

	TArray<FVector> DoorPoints;
	bool IsGetted = GetDoorsOfRegion(WorldContextObject, IDOfRoom, DoorPoints);
	if (IsGetted)
	{
		FVector2D TempDoorCenter = FVector2D(0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]));
		float LengthOfSide1 = FVector::Distance(DoorPoints[0], DoorPoints[1]);
		float LengthOfSide2 = FVector::Distance(DoorPoints[0], DoorPoints[2]);
		FVector2D BaseDir, FinalDir;
		FVector2D TempExtendP;
		if (LengthOfSide1 > LengthOfSide2)
		{
			FVector2D TempDir = FVector2D(DoorPoints[1] - DoorPoints[0]);
			TempDir.Normalize();
			BaseDir = TempDir.GetRotated(90);
		}
		else
		{
			FVector2D TempDir = FVector2D(DoorPoints[2] - DoorPoints[0]);
			TempDir.Normalize();
			BaseDir = TempDir.GetRotated(90);
		}
		FVector2D ExtendPoint1 = TempDoorCenter + 35 * BaseDir;
		FVector2D ExtendPoint2 = TempDoorCenter - 35 * BaseDir;
		bool P1IsLyingInRegion = FPolygonAlg::JudgePointInPolygon(RoomPs, ExtendPoint1);
		bool P2IsLyingInRegion = FPolygonAlg::JudgePointInPolygon(RoomPs, ExtendPoint2);
		if (P1IsLyingInRegion)
		{
			FinalDir = BaseDir;
			TempExtendP = ExtendPoint1;
		}
		if (P2IsLyingInRegion)
		{
			FinalDir = -BaseDir;
			TempExtendP = ExtendPoint2;
		}
		FVector2D TempInterSectP;
		FPolygonAlg::CalculateRayToInterSectP(RoomPs, TempExtendP, FinalDir, TempInterSectP);
		FVector2D TempCenter = 0.5*(TempInterSectP + TempDoorCenter);

		//////////////////////////////////////////////////////////////////////////////////////////////////
		//	//////////////找出阳台区域最大的模型////////////////////////////
		TArray<AFurnitureModelActor*> ModelsOfRoom;
		FindModelsOfRoom(WorldContextObject, RoomPs, ModelsOfRoom);
		bool FindModel = false;
		FBox MaxTargetBox;
		if (ModelsOfRoom.Num() != 0)
		{
			float MaxV = 0.0;
			for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
			{
				FBox TempBox = ModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
				FVector FMin = TempBox.Min;
				FVector FMax = TempBox.Max;
				float ModelZ = FMax.Z - FMin.Z;
				bool ModelIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, RoomPs);
				if ((ModelIsUseful) && (ModelZ <= 250))
				{
					float BoxV = TempBox.GetVolume();
					if ((MaxV <= 0.000001) || (MaxV < BoxV))
					{
						MaxV = BoxV;
						MaxTargetBox = TempBox;
					}
				}
			}
			if (MaxV > 1.0)
			{
				FindModel = true;
			}
		}
		if (FindModel)
		{
			FBox LargeBox = MaxTargetBox;
			FVector LargeModelCenter = LargeBox.GetCenter();
			FVector2D LargeModelCenter2D = FVector2D(LargeModelCenter);
			FVector2D PointDir = LargeModelCenter2D - TempExtendP;
			PointDir.Normalize();
			FVector CloestP = FMath::ClosestPointOnInfiniteLine(FVector(TempDoorCenter, 0.0), FVector(TempExtendP, 0.0), LargeModelCenter);
			FVector2D TempRayDir = FVector2D(CloestP) - LargeModelCenter2D;
			TempRayDir.Normalize();
			FVector2D SideP;
			FPolygonAlg::CalculateRayToInterSectP(RoomPs, TempCenter, TempRayDir, SideP);
			FVector2D TempCriticalP1 = 0.25*FVector2D(TempCenter) + 0.75*SideP;
			CriticalPoints.Add(TempCriticalP1);
			CriticalPoints.Add(TempCenter);
			RegionWatchPoint = TempCenter - 10 * TempRayDir;
		}
		else
		{
			FVector2D TempRotV = FinalDir.GetRotated(90);
			FVector2D SideP;
			FPolygonAlg::CalculateRayToInterSectP(RoomPs, TempCenter, TempRotV, SideP);
			FVector2D TempCriticalP1 = 0.25*FVector2D(TempCenter) + 0.75*SideP;
			CriticalPoints.Add(TempCriticalP1);
			CriticalPoints.Add(TempCenter);
			RegionWatchPoint = TempCenter - 10 * TempRotV;
		}
	}
	return true;
}

bool UWriteMeshObj_FunctionLibrary::LocateCriticalPointsOfNormalBalcony(UObject* WorldContextObject,
	const TArray<FVector2D> RoomPs,
	const int IDOfRoom,
	TArray<FVector2D>& CriticalPoints,
	FVector2D& RegionWatchPoint,
	int& ActionMarker)
{
	if (RoomPs.Num() == 0)
	{
		return false;
	}

	TArray<FVector> DoorPoints;
	bool IsGetted = GetDoorsOfRegion(WorldContextObject, IDOfRoom, DoorPoints);
	if (IsGetted)
	{
		FVector2D TempDoorCenter = FVector2D(0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]));
		float LengthOfSide1 = FVector::Distance(DoorPoints[0], DoorPoints[1]);
		float LengthOfSide2 = FVector::Distance(DoorPoints[0], DoorPoints[2]);
		FVector2D BaseDir, FinalDir;
		if (LengthOfSide1 > LengthOfSide2)
		{
			FVector2D TempDir = FVector2D(DoorPoints[1] - DoorPoints[0]);
			TempDir.Normalize();
			BaseDir = TempDir.GetRotated(90);
		}
		else
		{
			FVector2D TempDir = FVector2D(DoorPoints[2] - DoorPoints[0]);
			TempDir.Normalize();
			BaseDir = TempDir.GetRotated(90);
		}
		FVector2D ExtendPoint1 = TempDoorCenter + 35 * BaseDir;
		FVector2D ExtendPoint2 = TempDoorCenter - 35 * BaseDir;
		bool P1IsLyingInRegion = FPolygonAlg::JudgePointInPolygon(RoomPs, ExtendPoint1);
		bool P2IsLyingInRegion = FPolygonAlg::JudgePointInPolygon(RoomPs, ExtendPoint2);
		if (P1IsLyingInRegion)
		{
			FinalDir = BaseDir;
			CriticalPoints.Add(ExtendPoint1);
		}
		if (P2IsLyingInRegion)
		{
			FinalDir = -BaseDir;
			CriticalPoints.Add(ExtendPoint2);
		}
		FVector2D TempInterSectP;
		FPolygonAlg::CalculateRayToInterSectP(RoomPs, CriticalPoints.Last(), FinalDir, TempInterSectP);
		RegionWatchPoint = TempInterSectP;

		//////////////////////////////////////////////////////////////////////////////////////////////////
		//	//////////////找出阳台区域最大的模型////////////////////////////
		ActionMarker = 1;
		TArray<AFurnitureModelActor*> ModelsOfRoom;
		FindModelsOfRoom(WorldContextObject, RoomPs, ModelsOfRoom);
		bool FindModel = false;
		FBox MaxTargetBox;
		if (ModelsOfRoom.Num() != 0)
		{
			float MaxV = 0.0;
			for (int _CurM = 0; _CurM < ModelsOfRoom.Num(); ++_CurM)
			{
				FBox TempBox = ModelsOfRoom[_CurM]->GetComponentsBoundingBox(true);
				FVector FMin = TempBox.Min;
				FVector FMax = TempBox.Max;
				float ModelZ = FMax.Z - FMin.Z;
				bool ModelIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, RoomPs);
				if ((ModelIsUseful) && (ModelZ <= 250))
				{
					float BoxV = TempBox.GetVolume();
					if ((MaxV <= 0.000001) || (MaxV < BoxV))
					{
						MaxV = BoxV;
						MaxTargetBox = TempBox;
					}
				}
			}
			if (MaxV > 1.0)
			{
				FindModel = true;
			}
		}
		if (FindModel)
		{
			FBox LargeBox = MaxTargetBox;
			FVector LargeModelCenter = LargeBox.GetCenter();
			FVector2D LargeModelCenter2D = FVector2D(LargeModelCenter);
			FVector2D PointDir = LargeModelCenter2D - CriticalPoints.Last();
			PointDir.Normalize();
			float CrossValue = FVector2D::CrossProduct(FinalDir, PointDir);
			if (CrossValue < 0.001f)
			{
				/////////////向左旋转标志//////////////////
				ActionMarker = 2;
			}
		}
	}
	return true;
}


bool UWriteMeshObj_FunctionLibrary::LocateCriticalPointsOfToilet(UObject* WorldContextObject,
	const TArray<FVector2D> ToiletRoomPs,
	const TArray<FVector2D> WallCenters,
	const int IDOfRoom,
	TArray<FVector2D>& CriticalPoints,
	FVector2D& ToiletCenter)
{
	if ((ToiletRoomPs.Num() == 0) || (WallCenters.Num() == 0))
	{
		return false;
	}

	FVector2D TempRegionCenter;
	bool LocateSuccess = FPolygonAlg::LocateSuitableCenter(ToiletRoomPs, TempRegionCenter);
	if (LocateSuccess)
	{
		ToiletCenter = TempRegionCenter;
	}
	//////////////////判定卫生间类型/////////////////////////////////////////////
	bool IsFirstType = false;
	for (int _CurWall = 0; _CurWall < WallCenters.Num(); ++_CurWall)
	{
		bool TempJudgeInRegion = FPolygonAlg::JudgePointInPolygon(ToiletRoomPs, WallCenters[_CurWall]);
		if (TempJudgeInRegion)
		{
			////////干湿分离类型区域//////////////////
			IsFirstType = true;
			break;
		}
	}
	TArray<FVector> DoorPoints;
	bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, IDOfRoom, DoorPoints);
	if (GetDoorSuccess)
	{
		int NumOfDoors = DoorPoints.Num() / 8;
		if (NumOfDoors == 1)
		{
			FVector2D TempLocateCenter;
			bool IsLocated = FPolygonAlg::LocateSuitableCenter(ToiletRoomPs, TempLocateCenter);
			FVector2D TempDoorCenter = FVector2D(0.25*(DoorPoints[0] + DoorPoints[1] + DoorPoints[2] + DoorPoints[3]));
			float LengthOfSide1 = FVector::Distance(DoorPoints[1], DoorPoints[0]);
			float LengthOfSide2 = FVector::Distance(DoorPoints[2], DoorPoints[0]);
			FVector2D DirOfLongSide;
			if (LengthOfSide1 > LengthOfSide2)
			{
				FVector2D TempBaseDir = FVector2D(DoorPoints[1] - DoorPoints[0]);
				DirOfLongSide = TempBaseDir.GetSafeNormal();
			}
			else
			{
				FVector2D TempBaseDir = FVector2D(DoorPoints[2] - DoorPoints[0]);
				DirOfLongSide = TempBaseDir.GetSafeNormal();
			}
			FVector2D DirOfRotated = DirOfLongSide.GetRotated(90);
			FVector2D ExtendP = TempDoorCenter + 40 * DirOfRotated;
			bool IsInRegion = FPolygonAlg::JudgePointInPolygon(ToiletRoomPs, ExtendP);
			if (IsInRegion)
			{
				FVector2D AddPoint1 = TempDoorCenter + 20 * DirOfRotated;
				CriticalPoints.Add(AddPoint1);
			}
			else
			{
				FVector2D AddPoint1 = TempDoorCenter - 20 * DirOfRotated;
				CriticalPoints.Add(AddPoint1);
			}
		}
		else
		{
			if (IsFirstType)
			{
				/////////////定位干湿分离区域中间的门的中心点/////////////////////////
				int LocatedDoorIndex = 0;
				FVector2D LocatedDoorDir;
				bool IsFoundedDoor = false;
				FVector2D CatchedDoorCenter;
				for (int _CurI = 0; _CurI < NumOfDoors; ++_CurI)
				{
					FVector TempDoorCenter3D = 0.25*(DoorPoints[8 * _CurI] + DoorPoints[8 * _CurI + 1] + DoorPoints[8 * _CurI + 2] + DoorPoints[8 * _CurI + 3]);
					CatchedDoorCenter = FVector2D(TempDoorCenter3D);
					bool IsLyingInRegion = FPolygonAlg::JudgePointInPolygon(ToiletRoomPs, CatchedDoorCenter);
					if (IsLyingInRegion)
					{
						LocatedDoorIndex = _CurI;
						IsFoundedDoor = true;
						break;
					}
				}

				float LengthOfLocatedDoorSide1 = FVector::Distance(DoorPoints[8 * LocatedDoorIndex], DoorPoints[8 * LocatedDoorIndex + 1]);
				float LengthOfLocatedDoorSide2 = FVector::Distance(DoorPoints[8 * LocatedDoorIndex], DoorPoints[8 * LocatedDoorIndex + 2]);
				if (LengthOfLocatedDoorSide1 > LengthOfLocatedDoorSide2)
				{
					LocatedDoorDir = FVector2D(DoorPoints[8 * LocatedDoorIndex + 1] - DoorPoints[8 * LocatedDoorIndex]);
				}
				else
				{
					LocatedDoorDir = FVector2D(DoorPoints[8 * LocatedDoorIndex + 2] - DoorPoints[8 * LocatedDoorIndex]);
				}
				LocatedDoorDir = LocatedDoorDir.GetSafeNormal();
				LocatedDoorDir = LocatedDoorDir.GetRotated(90);
				if (IsFoundedDoor)
				{
					if (NumOfDoors == 2)
					{
						FVector2D TempDirOfFirstDoor;
						for (int _CurDoor = 0; _CurDoor < NumOfDoors; ++_CurDoor)
						{
							if (_CurDoor != LocatedDoorIndex)
							{
								FVector FirstDoorCenter3D = 0.25*(DoorPoints[8 * _CurDoor] + DoorPoints[8 * _CurDoor + 1] + DoorPoints[8 * _CurDoor + 2] + DoorPoints[8 * _CurDoor + 3]);
								FVector2D FirstDoorCenter = FVector2D(FirstDoorCenter3D);
								float LengthOfFirstDoorSide1 = FVector::Distance(DoorPoints[8 * _CurDoor], DoorPoints[8 * _CurDoor + 1]);
								float LengthOfFirstDoorSide2 = FVector::Distance(DoorPoints[8 * _CurDoor], DoorPoints[8 * _CurDoor + 2]);

								if (LengthOfFirstDoorSide1 > LengthOfFirstDoorSide2)
								{
									TempDirOfFirstDoor = FVector2D(DoorPoints[8 * _CurDoor + 1] - DoorPoints[8 * _CurDoor]);
								}
								else
								{
									TempDirOfFirstDoor = FVector2D(DoorPoints[8 * _CurDoor + 2] - DoorPoints[8 * _CurDoor]);
								}
								TempDirOfFirstDoor = TempDirOfFirstDoor.GetSafeNormal();
								TempDirOfFirstDoor = TempDirOfFirstDoor.GetRotated(90);
								FVector2D TempExtendP1OfFirstDoor = FirstDoorCenter + 20 * TempDirOfFirstDoor;
								FVector2D TempExtendP2OfFirstDoor = FirstDoorCenter - 20 * TempDirOfFirstDoor;
								if (FPolygonAlg::JudgePointInPolygon(ToiletRoomPs, TempExtendP1OfFirstDoor))
								{
									CriticalPoints.Add(TempExtendP1OfFirstDoor);
									TempDirOfFirstDoor = TempDirOfFirstDoor;
								}
								if (FPolygonAlg::JudgePointInPolygon(ToiletRoomPs, TempExtendP2OfFirstDoor))
								{
									CriticalPoints.Add(TempExtendP2OfFirstDoor);
									TempDirOfFirstDoor = -TempDirOfFirstDoor;
								}
							}
						}
						float IsNearValue = abs(LocatedDoorDir.X*TempDirOfFirstDoor.Y - LocatedDoorDir.Y*TempDirOfFirstDoor.X);
						if (IsNearValue <= 0.01f)
						{
							FVector2D ExtendPOfSecondDoorCenter = CatchedDoorCenter + TempDirOfFirstDoor * 30;
							CriticalPoints.Add(ExtendPOfSecondDoorCenter);
						}
						else
						{
							FVector2D LineEnd = CatchedDoorCenter + LocatedDoorDir * 30;
							if (CriticalPoints.Num() > 0)
							{
								FVector CloestPointOfExtendPoint = FMath::ClosestPointOnInfiniteLine(FVector(CatchedDoorCenter, 0), FVector(LineEnd, 0), FVector(CriticalPoints.Last(), 0));
								FVector2D CloestPointOfExtendPoint2D = FVector2D(CloestPointOfExtendPoint);
								CriticalPoints.Add(CloestPointOfExtendPoint2D);
								FVector2D TempStraightDir = CatchedDoorCenter - CloestPointOfExtendPoint2D;
								TempStraightDir.Normalize();
								FVector2D TempExtendPoint = CatchedDoorCenter + TempStraightDir * 30;
								CriticalPoints.Add(TempExtendPoint);
							}
						}
					}
					else if (NumOfDoors >= 3)
					{
						float TempMaxFarDis = 0.0;
						int TargetFarDoorIndex = 0;
						FVector2D TempDirOfFirstDoor;
						FVector2D TempTargetDoorCenter;
						for (int _CurDoor = 0; _CurDoor < NumOfDoors; ++_CurDoor)
						{
							if (_CurDoor != LocatedDoorIndex)
							{
								FVector TempDoorCenter3D = 0.25*(DoorPoints[8 * _CurDoor] + DoorPoints[8 * _CurDoor + 1] + DoorPoints[8 * _CurDoor + 2] + DoorPoints[8 * _CurDoor + 3]);
								FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter3D);

								float TempDis = FVector2D::Distance(TempRegionCenter, TempDoorCenter2D);
								if ((TempMaxFarDis <= 0.0001f) || (TempMaxFarDis < TempDis))
								{
									TempMaxFarDis = TempDis;
									TargetFarDoorIndex = _CurDoor;
								}
							}
						}

						float LengthOfFirstDoorSide1 = FVector::Distance(DoorPoints[8 * TargetFarDoorIndex], DoorPoints[8 * TargetFarDoorIndex + 1]);
						float LengthOfFirstDoorSide2 = FVector::Distance(DoorPoints[8 * TargetFarDoorIndex], DoorPoints[8 * TargetFarDoorIndex + 2]);

						if (LengthOfFirstDoorSide1 > LengthOfFirstDoorSide2)
						{
							TempDirOfFirstDoor = FVector2D(DoorPoints[8 * TargetFarDoorIndex + 1] - DoorPoints[8 * TargetFarDoorIndex]);
						}
						else
						{
							TempDirOfFirstDoor = FVector2D(DoorPoints[8 * TargetFarDoorIndex + 2] - DoorPoints[8 * TargetFarDoorIndex]);
						}
						TempDirOfFirstDoor = TempDirOfFirstDoor.GetSafeNormal();
						TempDirOfFirstDoor = TempDirOfFirstDoor.GetRotated(90);
						FVector TempTargetDoorCenter3D = 0.25*(DoorPoints[8 * TargetFarDoorIndex] + DoorPoints[8 * TargetFarDoorIndex + 1] + DoorPoints[8 * TargetFarDoorIndex + 2] + DoorPoints[8 * TargetFarDoorIndex + 3]);
						TempTargetDoorCenter = FVector2D(TempTargetDoorCenter3D);
						FVector2D TempExtendP1OfFirstDoor = TempTargetDoorCenter + 30 * TempDirOfFirstDoor;
						FVector2D TempExtendP2OfFirstDoor = TempTargetDoorCenter - 30 * TempDirOfFirstDoor;
						if (FPolygonAlg::JudgePointInPolygon(ToiletRoomPs, TempExtendP1OfFirstDoor))
						{
							CriticalPoints.Add(TempExtendP1OfFirstDoor);
							TempDirOfFirstDoor = TempDirOfFirstDoor;
						}
						if (FPolygonAlg::JudgePointInPolygon(ToiletRoomPs, TempExtendP2OfFirstDoor))
						{
							CriticalPoints.Add(TempExtendP2OfFirstDoor);
							TempDirOfFirstDoor = -TempDirOfFirstDoor;
						}


						float IsNearValue = abs(LocatedDoorDir.X*TempDirOfFirstDoor.Y - LocatedDoorDir.Y*TempDirOfFirstDoor.X);
						if (IsNearValue <= 0.01f)
						{
							FVector2D ExtendPOfSecondDoorCenter = CatchedDoorCenter + TempDirOfFirstDoor * 30;
							CriticalPoints.Add(ExtendPOfSecondDoorCenter);
						}
						else
						{
							FVector2D LineEnd = CatchedDoorCenter + LocatedDoorDir * 30;
							if (CriticalPoints.Num() > 0)
							{
								FVector CloestPointOfExtendPoint = FMath::ClosestPointOnInfiniteLine(FVector(CatchedDoorCenter, 0), FVector(LineEnd, 0), FVector(CriticalPoints.Last(), 0));
								FVector2D CloestPointOfExtendPoint2D = FVector2D(CloestPointOfExtendPoint);
								CriticalPoints.Add(CloestPointOfExtendPoint2D);
								FVector2D TempStraightDir = CatchedDoorCenter - CloestPointOfExtendPoint2D;
								TempStraightDir.Normalize();
								FVector2D TempExtendPoint = CatchedDoorCenter + TempStraightDir * 30;
								CriticalPoints.Add(TempExtendPoint);
							}
						}
					}
				}
			}
		}
	}
	else
	{
		CriticalPoints.Add(TempRegionCenter);
		ToiletCenter = FVector2D(0.0, 0.0);
	}
	return true;
}

bool UWriteMeshObj_FunctionLibrary::IsPointInOrOnRegion(const TArray<FVector2D> Region, const FVector2D JudgePoint)
{
	bool IsSuccess = FPolygonAlg::JudgePointOnOrInPolygon(Region, JudgePoint);
	return IsSuccess;
}
///////////////////////////////////////RTX效果相关////////////////////////////////////////
bool UWriteMeshObj_FunctionLibrary::LocateRTXLightsOfDiningOrLivingRegion(UObject* WorldContextObject, const TArray<FVector2D> InPnts, const int RoomID, TArray<FVector>&LightsLoc, const float WallHeight, const float ReduceHeight)
{
	FVector2D CenterPoint;
	const float ShrinkLength = 10 * sqrt(2);
	const float ExtendLength = 30.0f;
	const float EqualLightSpace = 100.0f;
	TArray<FVector2D> OutPnts;
	TArray<FVector2D> TempLights;
	bool MergeCollinearSuccess = FPolygonAlg::MergeCollinearPoints(InPnts, OutPnts);
	if (!MergeCollinearSuccess)
	{
		return false;
	}
	TArray<FVector> DoorPoints, WindowPoints;
	bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, RoomID, DoorPoints);
	bool GetWindowSuccess = GetWindowsOfRegion(WorldContextObject, RoomID, WindowPoints);
	FVector2D SuitableCenter;
	if (OutPnts.Num() <= 3)
	{
		return false;
	}
	else if (OutPnts.Num() == 4)
	{
		FVector2D LocalCenter = 0.25*(OutPnts[0] + OutPnts[1] + OutPnts[2] + OutPnts[3]);
		//////////////////////结合门洞以及窗洞信息计算/////////////////////////////////////////////
		int NumOfDoors = DoorPoints.Num() / 8;
		int NumOfWindows = WindowPoints.Num() / 8;
		TArray<int> RemovedEdgeIndexs;
		int NextEdge = 0;
		if (NumOfDoors > 0)
		{
			for (int _CurDoor = 0; _CurDoor < NumOfDoors; ++_CurDoor)
			{
				FVector TempDir = DoorPoints[8 * _CurDoor + 1] - DoorPoints[8 * _CurDoor];
				TempDir.Normalize();
				FVector2D TempDir2D = FVector2D(TempDir);
				FVector2D TempRotatedDir = TempDir2D.GetRotated(90);
				FVector TempDoorCenter = 0.25*(DoorPoints[8 * _CurDoor] + DoorPoints[8 * _CurDoor + 1] + DoorPoints[8 * _CurDoor + 2] + DoorPoints[8 * _CurDoor + 3]);
				FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter);
				///////////////////////////剔除靠近门洞的区域内边界////////////////////////////
				for (int _CurEdge = 0; _CurEdge < OutPnts.Num(); ++_CurEdge)
				{
					if (_CurEdge == OutPnts.Num() - 1)
					{
						NextEdge = 0;
					}
					else
					{
						NextEdge = _CurEdge + 1;
					}
					float TempDis = FMath::PointDistToSegment(FVector(TempDoorCenter2D, 0), FVector(OutPnts[_CurEdge], 0), FVector(OutPnts[NextEdge], 0));
					if (TempDis <= 20)
					{
						RemovedEdgeIndexs.AddUnique(_CurEdge);
					}
				}
			}
		}

		if (NumOfWindows > 0)
		{
			for (int _CurWindow = 0; _CurWindow < NumOfWindows; ++_CurWindow)
			{
				FVector TempDir = WindowPoints[8 * _CurWindow + 1] - WindowPoints[8 * _CurWindow];
				TempDir.Normalize();
				FVector2D TempDir2D = FVector2D(TempDir);
				FVector2D TempRotatedDir = TempDir2D.GetRotated(90);
				FVector TempWindowCenter = 0.25*(WindowPoints[8 * _CurWindow] + WindowPoints[8 * _CurWindow + 1] + WindowPoints[8 * _CurWindow + 2] + WindowPoints[8 * _CurWindow + 3]);
				FVector2D TempWindowCenter2D = FVector2D(TempWindowCenter);
				///////////////////////////剔除靠近窗洞的区域内边界////////////////////////////
				for (int _CurEdge = 0; _CurEdge < OutPnts.Num(); ++_CurEdge)
				{
					if (_CurEdge == OutPnts.Num() - 1)
					{
						NextEdge = 0;
					}
					else
					{
						NextEdge = _CurEdge + 1;
					}
					float TempDis = FMath::PointDistToSegment(FVector(TempWindowCenter2D, 0), FVector(OutPnts[_CurEdge], 0), FVector(OutPnts[NextEdge], 0));
					if (TempDis <= 20)
					{
						RemovedEdgeIndexs.AddUnique(_CurEdge);
					}
				}
			}
		}
		/////////////////////设置区域内边界附近的布灯位置/////////////////////////////////////
		for (int _CurE = 0; _CurE < OutPnts.Num(); ++_CurE)
		{
			if (!RemovedEdgeIndexs.Contains(_CurE))
			{
				if (_CurE == OutPnts.Num() - 1)
				{
					NextEdge = 0;
				}
				else
				{
					NextEdge = _CurE + 1;
				}
				FVector2D StartVec = LocalCenter - OutPnts[_CurE];
				FVector2D EndVec = LocalCenter - OutPnts[NextEdge];
				StartVec.Normalize();
				EndVec.Normalize();
				FVector2D StartP = OutPnts[_CurE] + ShrinkLength * StartVec;
				FVector2D EndP = OutPnts[NextEdge] + ShrinkLength * EndVec;
				FVector2D TempExtendVec = EndP - StartP;
				TempExtendVec.Normalize();
				float DisOfEdge = FVector2D::Distance(StartP, EndP);
				FVector2D TempMiddleP = 0.5*(StartP + EndP);
				int NumToAdd = (int)(DisOfEdge / EqualLightSpace);
				if ((DisOfEdge <= 150) || (NumToAdd <= 2))
				{
					TempLights.AddUnique(TempMiddleP);
				}
				else
				{
					if (NumToAdd >= 3)
					{
						int NumOfSide1 = (NumToAdd - 1) / 2;
						int NumOfSide2 = NumToAdd - 1 - NumOfSide1;
						TempLights.AddUnique(TempMiddleP);
						////////计算Side1的灯的位置/////////////////////
						for (int _CurI = 0; _CurI < NumOfSide1; ++_CurI)
						{
							FVector2D TempLightOfSide1 = TempMiddleP + (_CurI + 1)*EqualLightSpace * TempExtendVec;
							TempLights.AddUnique(TempLightOfSide1);
						}
						/////////计算Side2的灯的位置//////////////////
						for (int _CurJ = 0; _CurJ < NumOfSide2; ++_CurJ)
						{
							FVector2D TempLightOfSide2 = TempMiddleP - (_CurJ + 1)*EqualLightSpace*TempExtendVec;
							TempLights.AddUnique(TempLightOfSide2);
						}
					}
				}
			}
		}

	}
	else
	{
		Polygon_2 Region2D;
		for (int32 PIndex = 0; PIndex < OutPnts.Num(); PIndex++)
		{
			Region2D.push_back(Point_2(OutPnts[PIndex].X, OutPnts[PIndex].Y));
		}
		int32 PNext = 0, PFront = 0, PNextNext = 0;
		TArray<float> AreaSet;
		TArray<FVector2D> AreaCenters;
		TMap<FVector2D, TArray<FVector2D>> MaxCenterMapBounds;
		for (int32 PStart = 0; PStart < OutPnts.Num(); PStart++)
		{
			if (PStart == 0)
			{
				PNext = PStart + 1;
				PFront = OutPnts.Num() - 1;
				PNextNext = PNext + 1;
			}
			else if (PStart == OutPnts.Num() - 1)
			{
				PNext = 0;
				PNextNext = PNext + 1;
				PFront = PStart - 1;
			}
			else if (PStart == OutPnts.Num() - 2)
			{
				PNext = PStart + 1;
				PNextNext = 0;
				PFront = PStart - 1;
			}
			else if (PStart == 1)
			{
				PNext = PStart + 1;
				PNextNext = PNext + 1;
				PFront = 0;
			}
			else
			{
				PNext = PStart + 1;
				PNextNext = PNext + 1;
				PFront = PStart - 1;
			}
			FVector2D Vec1 = FVector2D(OutPnts[PNext].X - OutPnts[PStart].X, OutPnts[PNext].Y - OutPnts[PStart].Y);
			FVector2D Vec2 = FVector2D(OutPnts[PNextNext].X - OutPnts[PNext].X, OutPnts[PNextNext].Y - OutPnts[PNext].Y);
			FVector2D Vec3 = FVector2D(OutPnts[PFront].X - OutPnts[PStart].X, OutPnts[PFront].Y - OutPnts[PStart].Y);
			float OutCrossZ1 = Vec1.X*Vec2.Y - Vec1.Y*Vec2.X;
			float OutCrossZ2 = Vec1.X*Vec3.Y - Vec1.Y*Vec3.X;

			float Vec1L = sqrt(Vec1.X*Vec1.X + Vec1.Y*Vec1.Y);
			float Vec1_x = Vec1.X / Vec1L;
			float Vec1_y = Vec1.Y / Vec1L;

			float Vec2L = sqrt(Vec2.X*Vec2.X + Vec2.Y*Vec2.Y);
			float Vec2_x = Vec2.X / Vec2L;
			float Vec2_y = Vec2.Y / Vec2L;

			float Vec3L = sqrt(Vec3.X*Vec3.X + Vec3.Y*Vec3.Y);
			float Vec3_x = Vec3.X / Vec3L;
			float Vec3_y = Vec3.Y / Vec3L;
			if (OutCrossZ1*OutCrossZ2 > 0)
			{
				Point_2 P1(OutPnts[PStart].X, OutPnts[PStart].Y);
				Point_2 P2(OutPnts[PNext].X, OutPnts[PNext].Y);
				Point_2 P3(OutPnts[PNextNext].X, OutPnts[PNextNext].Y);
				Point_2 P4(OutPnts[PFront].X, OutPnts[PFront].Y);
				float TempCenterX = 0.0, TempCenterY = 0.0, TempArea = 0.0;
				float DisPFrontToPStart = sqrt(CGAL::squared_distance(P1, P4));
				float DisPNextToPNextNext = sqrt(CGAL::squared_distance(P2, P3));
				float DisPStartToPNext = sqrt(CGAL::squared_distance(P1, P2));

				bool FindLocalCenter = false;
				if ((DisPFrontToPStart < DisPNextToPNextNext) && (DisPStartToPNext / DisPFrontToPStart <= 4.0))
				{
					TempCenterX = 0.5*(P4.x() + P2.x());
					TempCenterY = 0.5*(P4.y() + P2.y());
					TempArea = DisPFrontToPStart * DisPStartToPNext;

					TArray<FVector2D> TempPointArray;
					FVector2D ExtendPoint = FVector2D(OutPnts[PNext].X + Vec2_x * DisPFrontToPStart, OutPnts[PNext].Y + Vec2_y * DisPFrontToPStart);
					TempPointArray.Add(ExtendPoint);
					TempPointArray.Add(OutPnts[PFront]);
					TempPointArray.Add(OutPnts[PStart]);
					TempPointArray.Add(OutPnts[PNext]);
					MaxCenterMapBounds.Add(FVector2D(TempCenterX, TempCenterY), TempPointArray);
					FindLocalCenter = true;
				}
				else if ((DisPFrontToPStart >= DisPNextToPNextNext) && (DisPStartToPNext / DisPNextToPNextNext <= 4.0))
				{

					TempCenterX = 0.5*(P3.x() + P1.x());
					TempCenterY = 0.5*(P3.y() + P1.y());
					TempArea = DisPNextToPNextNext * DisPStartToPNext;

					TArray<FVector2D> TempPointArray;
					FVector2D ExtendPoint = FVector2D(OutPnts[PStart].X + Vec3_x * DisPNextToPNextNext, OutPnts[PStart].Y + Vec3_y * DisPNextToPNextNext);
					TempPointArray.Add(ExtendPoint);
					TempPointArray.Add(OutPnts[PNextNext]);
					TempPointArray.Add(OutPnts[PNext]);
					TempPointArray.Add(OutPnts[PStart]);
					MaxCenterMapBounds.Add(FVector2D(TempCenterX, TempCenterY), TempPointArray);
					FindLocalCenter = true;
				}



				if ((Region2D.bounded_side(Point_2(TempCenterX, TempCenterY)) == CGAL::ON_BOUNDED_SIDE) && (FindLocalCenter))
				{
					FVector2D TempCenter = FVector2D(TempCenterX, TempCenterY);
					AreaCenters.Add(TempCenter);
					AreaSet.Add(TempArea);
				}
				else
				{
					AreaCenters.Add(FVector2D(0.0, 0.0));
					AreaSet.Add(0.0);
				}
			}
			else
			{
				AreaCenters.Add(FVector2D(0.0, 0.0));
				AreaSet.Add(0.0);
			}
		}




		float MaxArea = 0.0;
		int32 TargetIndex = 0;
		for (int32 CenterIndex = 0; CenterIndex < AreaCenters.Num(); CenterIndex++)
		{
			if (AreaSet[CenterIndex] != 0.0)
			{
				if (AreaSet[CenterIndex] > MaxArea)
				{
					MaxArea = AreaSet[CenterIndex];
					TargetIndex = CenterIndex;
				}
			}

		}

		if (MaxArea >= 150 * 100)
		{
			SuitableCenter = AreaCenters[TargetIndex];
			TArray<FVector2D> BoundPs = MaxCenterMapBounds[SuitableCenter];
			//////////////////////结合门洞以及窗洞信息计算/////////////////////////////////////////////
			int NumOfDoors = DoorPoints.Num() / 8;
			int NumOfWindows = WindowPoints.Num() / 8;
			TArray<int> RemovedEdgeIndexs;
			int NextEdge = 0;
			if (NumOfDoors > 0)
			{
				for (int _CurDoor = 0; _CurDoor < NumOfDoors; ++_CurDoor)
				{
					FVector TempDir = DoorPoints[8 * _CurDoor + 1] - DoorPoints[8 * _CurDoor];
					TempDir.Normalize();
					FVector2D TempDir2D = FVector2D(TempDir);
					FVector2D TempRotatedDir = TempDir2D.GetRotated(90);
					FVector TempDoorCenter = 0.25*(DoorPoints[8 * _CurDoor] + DoorPoints[8 * _CurDoor + 1] + DoorPoints[8 * _CurDoor + 2] + DoorPoints[8 * _CurDoor + 3]);
					FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter);
					///////////////////////////剔除靠近门洞的区域内边界////////////////////////////
					for (int _CurEdge = 0; _CurEdge < BoundPs.Num(); ++_CurEdge)
					{
						if (_CurEdge == BoundPs.Num() - 1)
						{
							NextEdge = 0;
						}
						else
						{
							NextEdge = _CurEdge + 1;
						}
						float TempDis = FMath::PointDistToSegment(FVector(TempDoorCenter2D, 0), FVector(BoundPs[_CurEdge], 0), FVector(BoundPs[NextEdge], 0));
						if (TempDis <= 20)
						{
							RemovedEdgeIndexs.AddUnique(_CurEdge);
						}
					}
				}
			}

			if (NumOfWindows > 0)
			{
				for (int _CurWindow = 0; _CurWindow < NumOfWindows; ++_CurWindow)
				{
					FVector TempDir = WindowPoints[8 * _CurWindow + 1] - WindowPoints[8 * _CurWindow];
					TempDir.Normalize();
					FVector2D TempDir2D = FVector2D(TempDir);
					FVector2D TempRotatedDir = TempDir2D.GetRotated(90);
					FVector TempWindowCenter = 0.25*(WindowPoints[8 * _CurWindow] + WindowPoints[8 * _CurWindow + 1] + WindowPoints[8 * _CurWindow + 2] + WindowPoints[8 * _CurWindow + 3]);
					FVector2D TempWindowCenter2D = FVector2D(TempWindowCenter);
					///////////////////////////剔除靠近窗洞的区域内边界////////////////////////////
					for (int _CurEdge = 0; _CurEdge < BoundPs.Num(); ++_CurEdge)
					{
						if (_CurEdge == BoundPs.Num() - 1)
						{
							NextEdge = 0;
						}
						else
						{
							NextEdge = _CurEdge + 1;
						}
						float TempDis = FMath::PointDistToSegment(FVector(TempWindowCenter2D, 0), FVector(BoundPs[_CurEdge], 0), FVector(BoundPs[NextEdge], 0));
						if (TempDis <= 20)
						{
							RemovedEdgeIndexs.AddUnique(_CurEdge);
						}
					}
				}
			}
			/////////////////////设置区域内边界附近的布灯位置/////////////////////////////////////
			for (int _CurE = 0; _CurE < BoundPs.Num(); ++_CurE)
			{
				if (!RemovedEdgeIndexs.Contains(_CurE))
				{
					if (_CurE == BoundPs.Num() - 1)
					{
						NextEdge = 0;
					}
					else
					{
						NextEdge = _CurE + 1;
					}
					FVector2D StartVec = SuitableCenter - BoundPs[_CurE];
					FVector2D EndVec = SuitableCenter - BoundPs[NextEdge];
					StartVec.Normalize();
					EndVec.Normalize();
					FVector2D StartP = BoundPs[_CurE] + ShrinkLength * StartVec;
					FVector2D EndP = BoundPs[NextEdge] + ShrinkLength * EndVec;
					FVector2D TempExtendVec = EndP - StartP;
					TempExtendVec.Normalize();
					float DisOfEdge = FVector2D::Distance(StartP, EndP);
					int NumToAdd = (int)((DisOfEdge) / EqualLightSpace);
					if ((DisOfEdge <= 150) || (NumToAdd <= 2))
					{
						TempLights.AddUnique(0.5*(StartP + EndP));
					}
					else
					{
						if (NumToAdd >= 3)
						{

							int NumOfSide1 = (NumToAdd - 1) / 2;
							int NumOfSide2 = NumToAdd - 1 - NumOfSide1;
							TempLights.AddUnique(0.5*(StartP + EndP));
							////////计算Side1的灯的位置/////////////////////
							for (int _CurI = 0; _CurI < NumOfSide1; ++_CurI)
							{
								FVector2D TempLightOfSide1 = 0.5*(StartP + EndP) + (_CurI + 1)*EqualLightSpace * TempExtendVec;
								TempLights.AddUnique(TempLightOfSide1);
							}
							/////////计算Side2的灯的位置//////////////////
							for (int _CurJ = 0; _CurJ < NumOfSide2; ++_CurJ)
							{
								FVector2D TempLightOfSide2 = 0.5*(StartP + EndP) - (_CurJ + 1)*EqualLightSpace*TempExtendVec;
								TempLights.AddUnique(TempLightOfSide2);
							}
						}
					}
				}
			}
		}
		else
		{
			float MinX = OutPnts[0].X;
			float MaxX = OutPnts[0].X;
			float MinY = OutPnts[0].Y;
			float MaxY = OutPnts[0].Y;
			for (int _CurP = 0; _CurP < OutPnts.Num(); ++_CurP)
			{
				if (MinX > OutPnts[_CurP].X)
				{
					MinX = OutPnts[_CurP].X;
				}
				if (MaxX < OutPnts[_CurP].X)
				{
					MaxX = OutPnts[_CurP].X;
				}
				if (MinY > OutPnts[_CurP].Y)
				{
					MinY = OutPnts[_CurP].Y;
				}
				if (MaxY < OutPnts[_CurP].Y)
				{
					MaxY = OutPnts[_CurP].Y;
				}
			}
			FVector2D PLeftUp = FVector2D(MinX, MaxY);
			FVector2D PLeftDown = FVector2D(MinX, MinY);
			FVector2D PRightDown = FVector2D(MaxX, MinY);
			FVector2D PRightUp = FVector2D(MaxX, MaxY);
			FVector2D TempCenter = 0.25*(PLeftUp + PLeftDown + PRightDown + PRightUp);
			if (FPolygonAlg::JudgePointInPolygon(OutPnts, TempCenter))
			{
				SuitableCenter = TempCenter;
				float Distance1 = FVector2D::Distance(PLeftUp, SuitableCenter);
				float Distance2 = FVector2D::Distance(PLeftDown, SuitableCenter);
				float Distance3 = FVector2D::Distance(PRightDown, SuitableCenter);
				float Distance4 = FVector2D::Distance(PRightUp, SuitableCenter);
				float ShrinkAge1 = (Distance1 - ShrinkLength) / Distance1;
				float ShrinkAge2 = (Distance2 - ShrinkLength) / Distance2;
				float ShrinkAge3 = (Distance3 - ShrinkLength) / Distance3;
				float ShrinkAge4 = (Distance4 - ShrinkLength) / Distance4;
				FVector2D UpdateOutPnt1 = (1 - ShrinkAge1)*SuitableCenter + ShrinkAge1 * PLeftUp;
				FVector2D UpdateOutPnt2 = (1 - ShrinkAge2)*SuitableCenter + ShrinkAge2 * PLeftDown;
				FVector2D UpdateOutPnt3 = (1 - ShrinkAge3)*SuitableCenter + ShrinkAge3 * PRightDown;
				FVector2D UpdateOutPnt4 = (1 - ShrinkAge4)*SuitableCenter + ShrinkAge4 * PRightUp;
				//////////////////////结合门洞以及窗洞信息计算/////////////////////////////////////////////
				TArray<FVector2D> TempBoundPs;
				TempBoundPs.Add(UpdateOutPnt1);
				TempBoundPs.Add(UpdateOutPnt2);
				TempBoundPs.Add(UpdateOutPnt3);
				TempBoundPs.Add(UpdateOutPnt4);

				int NumOfDoors = DoorPoints.Num() / 8;
				int NumOfWindows = WindowPoints.Num() / 8;
				TArray<int> RemovedEdgeIndexs;
				int NextEdge = 0;
				if (NumOfDoors > 0)
				{
					for (int _CurDoor = 0; _CurDoor < NumOfDoors; ++_CurDoor)
					{
						FVector TempDir = DoorPoints[8 * _CurDoor + 1] - DoorPoints[8 * _CurDoor];
						TempDir.Normalize();
						FVector2D TempDir2D = FVector2D(TempDir);
						FVector2D TempRotatedDir = TempDir2D.GetRotated(90);
						FVector TempDoorCenter = 0.25*(DoorPoints[8 * _CurDoor] + DoorPoints[8 * _CurDoor + 1] + DoorPoints[8 * _CurDoor + 2] + DoorPoints[8 * _CurDoor + 3]);
						FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter);
						///////////////////////////剔除靠近门洞的区域内边界////////////////////////////
						for (int _CurEdge = 0; _CurEdge < TempBoundPs.Num(); ++_CurEdge)
						{
							if (_CurEdge == TempBoundPs.Num() - 1)
							{
								NextEdge = 0;
							}
							else
							{
								NextEdge = _CurEdge + 1;
							}
							float TempDis = FMath::PointDistToSegment(FVector(TempDoorCenter2D, 0), FVector(TempBoundPs[_CurEdge], 0), FVector(TempBoundPs[NextEdge], 0));
							if (TempDis <= 30)
							{
								RemovedEdgeIndexs.AddUnique(_CurEdge);
							}
						}
					}
				}

				if (NumOfWindows > 0)
				{
					for (int _CurWindow = 0; _CurWindow < NumOfWindows; ++_CurWindow)
					{
						FVector TempDir = WindowPoints[8 * _CurWindow + 1] - WindowPoints[8 * _CurWindow];
						TempDir.Normalize();
						FVector2D TempDir2D = FVector2D(TempDir);
						FVector2D TempRotatedDir = TempDir2D.GetRotated(90);
						FVector TempWindowCenter = 0.25*(WindowPoints[8 * _CurWindow] + WindowPoints[8 * _CurWindow + 1] + WindowPoints[8 * _CurWindow + 2] + WindowPoints[8 * _CurWindow + 3]);
						FVector2D TempWindowCenter2D = FVector2D(TempWindowCenter);
						///////////////////////////剔除靠近窗洞的区域内边界////////////////////////////
						for (int _CurEdge = 0; _CurEdge < TempBoundPs.Num(); ++_CurEdge)
						{
							if (_CurEdge == TempBoundPs.Num() - 1)
							{
								NextEdge = 0;
							}
							else
							{
								NextEdge = _CurEdge + 1;
							}
							float TempDis = FMath::PointDistToSegment(FVector(TempWindowCenter2D, 0), FVector(TempBoundPs[_CurEdge], 0), FVector(TempBoundPs[NextEdge], 0));
							if (TempDis <= 30)
							{
								RemovedEdgeIndexs.AddUnique(_CurEdge);
							}
						}
					}
				}
				/////////////////////设置区域内边界附近的布灯位置/////////////////////////////////////
				for (int _CurE = 0; _CurE < TempBoundPs.Num(); ++_CurE)
				{
					if (!RemovedEdgeIndexs.Contains(_CurE))
					{
						if (_CurE == TempBoundPs.Num() - 1)
						{
							NextEdge = 0;
						}
						else
						{
							NextEdge = _CurE + 1;
						}
						FVector2D StartVec = TempCenter - TempBoundPs[_CurE];
						FVector2D EndVec = TempCenter - TempBoundPs[NextEdge];
						StartVec.Normalize();
						EndVec.Normalize();
						FVector2D StartP = TempBoundPs[_CurE] + ShrinkLength * StartVec;
						FVector2D EndP = TempBoundPs[NextEdge] + ShrinkLength * EndVec;
						FVector2D TempExtendVec = EndP - StartP;
						TempExtendVec.Normalize();
						float DisOfEdge = FVector2D::Distance(StartP, EndP);
						int NumToAdd = (int)((DisOfEdge) / EqualLightSpace);
						if ((DisOfEdge <= 150) || (NumToAdd <= 2))
						{
							TempLights.AddUnique(0.5*(StartP + EndP));
						}
						else
						{
							if (NumToAdd >= 3)
							{

								int NumOfSide1 = (NumToAdd - 1) / 2;
								int NumOfSide2 = NumToAdd - 1 - NumOfSide1;
								TempLights.AddUnique(0.5*(StartP + EndP));
								////////计算Side1的灯的位置/////////////////////
								for (int _CurI = 0; _CurI < NumOfSide1; ++_CurI)
								{
									FVector2D TempLightOfSide1 = 0.5*(StartP + EndP) + (_CurI + 1)*EqualLightSpace * TempExtendVec;
									TempLights.AddUnique(TempLightOfSide1);
								}
								/////////计算Side2的灯的位置//////////////////
								for (int _CurJ = 0; _CurJ < NumOfSide2; ++_CurJ)
								{
									FVector2D TempLightOfSide2 = 0.5*(StartP + EndP) - (_CurJ + 1)*EqualLightSpace*TempExtendVec;
									TempLights.AddUnique(TempLightOfSide2);
								}
							}
						}
					}
				}
			}
		}
	}

	for (int _CurL = 0; _CurL < TempLights.Num(); ++_CurL)
	{
		if (FPolygonAlg::JudgePointInPolygon(OutPnts, TempLights[_CurL]))
		{
			LightsLoc.AddUnique(FVector(TempLights[_CurL], WallHeight - ReduceHeight));
		}
	}
	return true;
}


bool UWriteMeshObj_FunctionLibrary::LocateRTXLightsOfRoom(UObject* WorldContextObject, const TArray<FVector2D> InPnts, const int RoomID, TArray<FVector>&LightsLoc, const float WallHeight, const float ReduceHeight)
{
	FVector2D SuitableCenter;
	TArray<FVector2D>  OutPnts;
	const float ShrinkLength = 10 * sqrt(2);
	TArray<FVector2D> TempLights;
	const float EqualLightSpace = 100.0f;
	bool MergeCollinearSuccess = FPolygonAlg::MergeCollinearPoints(InPnts, OutPnts);
	if (!MergeCollinearSuccess)
	{
		return false;
	}
	TArray<FVector> DoorPoints, WindowPoints;
	bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, RoomID, DoorPoints);
	bool GetWindowSuccess = GetWindowsOfRegion(WorldContextObject, RoomID, WindowPoints);
	if (OutPnts.Num() <= 3)
	{
		return false;
	}
	else if (OutPnts.Num() == 4)
	{
		FVector2D LocalCenter = 0.25*(OutPnts[0] + OutPnts[1] + OutPnts[2] + OutPnts[3]);
		//////////////////////结合门洞以及窗洞信息计算/////////////////////////////////////////////
		int NumOfDoors = DoorPoints.Num() / 8;
		int NumOfWindows = WindowPoints.Num() / 8;
		TArray<int> RemovedEdgeIndexs;
		int NextEdge = 0;
		if (NumOfDoors > 0)
		{
			for (int _CurDoor = 0; _CurDoor < NumOfDoors; ++_CurDoor)
			{
				FVector TempDir = DoorPoints[8 * _CurDoor + 1] - DoorPoints[8 * _CurDoor];
				TempDir.Normalize();
				FVector2D TempDir2D = FVector2D(TempDir);
				FVector2D TempRotatedDir = TempDir2D.GetRotated(90);
				FVector TempDoorCenter = 0.25*(DoorPoints[8 * _CurDoor] + DoorPoints[8 * _CurDoor + 1] + DoorPoints[8 * _CurDoor + 2] + DoorPoints[8 * _CurDoor + 3]);
				FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter);
				///////////////////////////剔除靠近门洞的区域内边界////////////////////////////
				for (int _CurEdge = 0; _CurEdge < OutPnts.Num(); ++_CurEdge)
				{
					if (_CurEdge == OutPnts.Num() - 1)
					{
						NextEdge = 0;
					}
					else
					{
						NextEdge = _CurEdge + 1;
					}
					float TempDis = FMath::PointDistToSegment(FVector(TempDoorCenter2D, 0), FVector(OutPnts[_CurEdge], 0), FVector(OutPnts[NextEdge], 0));
					if (TempDis <= 20)
					{
						RemovedEdgeIndexs.AddUnique(_CurEdge);
					}
				}
			}
		}

		if (NumOfWindows > 0)
		{
			for (int _CurWindow = 0; _CurWindow < NumOfWindows; ++_CurWindow)
			{
				FVector TempDir = WindowPoints[8 * _CurWindow + 1] - WindowPoints[8 * _CurWindow];
				TempDir.Normalize();
				FVector2D TempDir2D = FVector2D(TempDir);
				FVector2D TempRotatedDir = TempDir2D.GetRotated(90);
				FVector TempWindowCenter = 0.25*(WindowPoints[8 * _CurWindow] + WindowPoints[8 * _CurWindow + 1] + WindowPoints[8 * _CurWindow + 2] + WindowPoints[8 * _CurWindow + 3]);
				FVector2D TempWindowCenter2D = FVector2D(TempWindowCenter);
				///////////////////////////剔除靠近窗洞的区域内边界////////////////////////////
				for (int _CurEdge = 0; _CurEdge < OutPnts.Num(); ++_CurEdge)
				{
					if (_CurEdge == OutPnts.Num() - 1)
					{
						NextEdge = 0;
					}
					else
					{
						NextEdge = _CurEdge + 1;
					}
					float TempDis = FMath::PointDistToSegment(FVector(TempWindowCenter2D, 0), FVector(OutPnts[_CurEdge], 0), FVector(OutPnts[NextEdge], 0));
					if (TempDis <= 20)
					{
						RemovedEdgeIndexs.AddUnique(_CurEdge);
					}
				}
			}
		}
		/////////////////////设置区域内边界附近的布灯位置/////////////////////////////////////
		for (int _CurE = 0; _CurE < OutPnts.Num(); ++_CurE)
		{
			if (!RemovedEdgeIndexs.Contains(_CurE))
			{
				if (_CurE == OutPnts.Num() - 1)
				{
					NextEdge = 0;
				}
				else
				{
					NextEdge = _CurE + 1;
				}
				FVector2D StartVec = LocalCenter - OutPnts[_CurE];
				FVector2D EndVec = LocalCenter - OutPnts[NextEdge];
				StartVec.Normalize();
				EndVec.Normalize();
				FVector2D StartP = OutPnts[_CurE] + ShrinkLength * StartVec;
				FVector2D EndP = OutPnts[NextEdge] + ShrinkLength * EndVec;
				FVector2D TempExtendVec = EndP - StartP;
				TempExtendVec.Normalize();
				float DisOfEdge = FVector2D::Distance(StartP, EndP);
				FVector2D TempMiddleP = 0.5*(StartP + EndP);
				int NumToAdd = (int)(DisOfEdge / EqualLightSpace);
				if ((DisOfEdge <= 150) || (NumToAdd <= 2))
				{
					TempLights.AddUnique(TempMiddleP);
				}
				else
				{
					if (NumToAdd >= 3)
					{
						int NumOfSide1 = (NumToAdd - 1) / 2;
						int NumOfSide2 = NumToAdd - 1 - NumOfSide1;
						TempLights.AddUnique(TempMiddleP);
						////////计算Side1的灯的位置/////////////////////
						for (int _CurI = 0; _CurI < NumOfSide1; ++_CurI)
						{
							FVector2D TempLightOfSide1 = TempMiddleP + (_CurI + 1)*EqualLightSpace * TempExtendVec;
							TempLights.AddUnique(TempLightOfSide1);
						}
						/////////计算Side2的灯的位置//////////////////
						for (int _CurJ = 0; _CurJ < NumOfSide2; ++_CurJ)
						{
							FVector2D TempLightOfSide2 = TempMiddleP - (_CurJ + 1)*EqualLightSpace*TempExtendVec;
							TempLights.AddUnique(TempLightOfSide2);
						}
					}
				}
			}
		}
	}
	else
	{
		Polygon_2 Region2D;
		for (int32 PIndex = 0; PIndex < OutPnts.Num(); PIndex++)
		{
			Region2D.push_back(Point_2(OutPnts[PIndex].X, OutPnts[PIndex].Y));
		}
		int32 PNext = 0, PFront = 0, PNextNext = 0;
		TArray<float> AreaSet;
		TArray<FVector2D> AreaCenters;
		TMap<FVector2D, TArray<FVector2D>> MaxCenterMapBounds;
		for (int32 PStart = 0; PStart < OutPnts.Num(); PStart++)
		{
			if (PStart == 0)
			{
				PNext = PStart + 1;
				PFront = OutPnts.Num() - 1;
				PNextNext = PNext + 1;
			}
			else if (PStart == OutPnts.Num() - 1)
			{
				PNext = 0;
				PNextNext = PNext + 1;
				PFront = PStart - 1;
			}
			else if (PStart == OutPnts.Num() - 2)
			{
				PNext = PStart + 1;
				PNextNext = 0;
				PFront = PStart - 1;
			}
			else if (PStart == 1)
			{
				PNext = PStart + 1;
				PNextNext = PNext + 1;
				PFront = 0;
			}
			else
			{
				PNext = PStart + 1;
				PNextNext = PNext + 1;
				PFront = PStart - 1;
			}
			FVector2D Vec1 = FVector2D(OutPnts[PNext].X - OutPnts[PStart].X, OutPnts[PNext].Y - OutPnts[PStart].Y);
			FVector2D Vec2 = FVector2D(OutPnts[PNextNext].X - OutPnts[PNext].X, OutPnts[PNextNext].Y - OutPnts[PNext].Y);
			FVector2D Vec3 = FVector2D(OutPnts[PFront].X - OutPnts[PStart].X, OutPnts[PFront].Y - OutPnts[PStart].Y);
			float OutCrossZ1 = Vec1.X*Vec2.Y - Vec1.Y*Vec2.X;
			float OutCrossZ2 = Vec1.X*Vec3.Y - Vec1.Y*Vec3.X;

			float Vec1L = sqrt(Vec1.X*Vec1.X + Vec1.Y*Vec1.Y);
			float Vec1_x = Vec1.X / Vec1L;
			float Vec1_y = Vec1.Y / Vec1L;

			float Vec2L = sqrt(Vec2.X*Vec2.X + Vec2.Y*Vec2.Y);
			float Vec2_x = Vec2.X / Vec2L;
			float Vec2_y = Vec2.Y / Vec2L;

			float Vec3L = sqrt(Vec3.X*Vec3.X + Vec3.Y*Vec3.Y);
			float Vec3_x = Vec3.X / Vec3L;
			float Vec3_y = Vec3.Y / Vec3L;
			if (OutCrossZ1*OutCrossZ2 > 0)
			{

				Point_2 P1(OutPnts[PStart].X, OutPnts[PStart].Y);
				Point_2 P2(OutPnts[PNext].X, OutPnts[PNext].Y);
				Point_2 P3(OutPnts[PNextNext].X, OutPnts[PNextNext].Y);
				Point_2 P4(OutPnts[PFront].X, OutPnts[PFront].Y);
				float TempCenterX = 0.0, TempCenterY = 0.0, TempArea = 0.0;
				float DisPFrontToPStart = sqrt(CGAL::squared_distance(P1, P4));
				float DisPNextToPNextNext = sqrt(CGAL::squared_distance(P2, P3));
				float DisPStartToPNext = sqrt(CGAL::squared_distance(P1, P2));

				float Product1 = Vec3_x * Vec1_x + Vec3_y * Vec1_y;
				float Product2 = Vec2_x * Vec1_x + Vec2_y * Vec1_y;

				bool RegionUseness = false;
				if ((DisPFrontToPStart < DisPNextToPNextNext) && (DisPStartToPNext / DisPFrontToPStart <= 3))
				{
					TempCenterX = 0.5*(P4.x() + P2.x());
					TempCenterY = 0.5*(P4.y() + P2.y());
					TempArea = DisPFrontToPStart * DisPStartToPNext;
					TArray<FVector2D> TempPointArray;
					FVector2D ExtendPoint = FVector2D(OutPnts[PNext].X + Vec2_x * DisPFrontToPStart, OutPnts[PNext].Y + Vec2_y * DisPFrontToPStart);
					TempPointArray.Add(ExtendPoint);
					TempPointArray.Add(OutPnts[PFront]);
					TempPointArray.Add(OutPnts[PStart]);
					TempPointArray.Add(OutPnts[PNext]);
					MaxCenterMapBounds.Add(FVector2D(TempCenterX, TempCenterY), TempPointArray);
					RegionUseness = true;
				}
				else if ((DisPFrontToPStart >= DisPNextToPNextNext) && (DisPStartToPNext / DisPNextToPNextNext <= 3))
				{
					TempCenterX = 0.5*(P3.x() + P1.x());
					TempCenterY = 0.5*(P3.y() + P1.y());
					TempArea = DisPNextToPNextNext * DisPStartToPNext;
					TArray<FVector2D> TempPointArray;
					FVector2D ExtendPoint = FVector2D(OutPnts[PStart].X + Vec3_x * DisPNextToPNextNext, OutPnts[PStart].Y + Vec3_y * DisPNextToPNextNext);
					TempPointArray.Add(ExtendPoint);
					TempPointArray.Add(OutPnts[PNextNext]);
					TempPointArray.Add(OutPnts[PNext]);
					TempPointArray.Add(OutPnts[PStart]);
					MaxCenterMapBounds.Add(FVector2D(TempCenterX, TempCenterY), TempPointArray);
					RegionUseness = true;
				}



				if ((Region2D.bounded_side(Point_2(TempCenterX, TempCenterY)) == CGAL::ON_BOUNDED_SIDE) && (RegionUseness))
				{
					FVector2D TempCenter = FVector2D(TempCenterX, TempCenterY);
					AreaCenters.Add(TempCenter);
					AreaSet.Add(TempArea);

				}
				else
				{
					AreaCenters.Add(FVector2D(0.0, 0.0));
					AreaSet.Add(0.0);
				}
			}
			else
			{
				AreaCenters.Add(FVector2D(0.0, 0.0));
				AreaSet.Add(0.0);
			}
		}

		float MaxArea = AreaSet[0];
		int32 TargetIndex = 0;
		for (int32 CenterIndex = 1; CenterIndex < AreaCenters.Num(); CenterIndex++)
		{
			if (AreaSet[CenterIndex] > MaxArea)
			{
				MaxArea = AreaSet[CenterIndex];
				TargetIndex = CenterIndex;
			}
		}

		if (MaxArea >= 150 * 100)
		{
			SuitableCenter = AreaCenters[TargetIndex];
			TArray<FVector2D> BoundPs = MaxCenterMapBounds[SuitableCenter];
			//////////////////////结合门洞以及窗洞信息计算/////////////////////////////////////////////
			int NumOfDoors = DoorPoints.Num() / 8;
			int NumOfWindows = WindowPoints.Num() / 8;
			TArray<int> RemovedEdgeIndexs;
			int NextEdge = 0;
			if (NumOfDoors > 0)
			{
				for (int _CurDoor = 0; _CurDoor < NumOfDoors; ++_CurDoor)
				{
					FVector TempDir = DoorPoints[8 * _CurDoor + 1] - DoorPoints[8 * _CurDoor];
					TempDir.Normalize();
					FVector2D TempDir2D = FVector2D(TempDir);
					FVector2D TempRotatedDir = TempDir2D.GetRotated(90);
					FVector TempDoorCenter = 0.25*(DoorPoints[8 * _CurDoor] + DoorPoints[8 * _CurDoor + 1] + DoorPoints[8 * _CurDoor + 2] + DoorPoints[8 * _CurDoor + 3]);
					FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter);
					///////////////////////////剔除靠近门洞的区域内边界////////////////////////////
					for (int _CurEdge = 0; _CurEdge < BoundPs.Num(); ++_CurEdge)
					{
						if (_CurEdge == BoundPs.Num() - 1)
						{
							NextEdge = 0;
						}
						else
						{
							NextEdge = _CurEdge + 1;
						}
						float TempDis = FMath::PointDistToSegment(FVector(TempDoorCenter2D, 0), FVector(BoundPs[_CurEdge], 0), FVector(BoundPs[NextEdge], 0));
						if (TempDis <= 20)
						{
							RemovedEdgeIndexs.AddUnique(_CurEdge);
						}
					}
				}
			}

			if (NumOfWindows > 0)
			{
				for (int _CurWindow = 0; _CurWindow < NumOfWindows; ++_CurWindow)
				{
					FVector TempDir = WindowPoints[8 * _CurWindow + 1] - WindowPoints[8 * _CurWindow];
					TempDir.Normalize();
					FVector2D TempDir2D = FVector2D(TempDir);
					FVector2D TempRotatedDir = TempDir2D.GetRotated(90);
					FVector TempWindowCenter = 0.25*(WindowPoints[8 * _CurWindow] + WindowPoints[8 * _CurWindow + 1] + WindowPoints[8 * _CurWindow + 2] + WindowPoints[8 * _CurWindow + 3]);
					FVector2D TempWindowCenter2D = FVector2D(TempWindowCenter);
					///////////////////////////剔除靠近窗洞的区域内边界////////////////////////////
					for (int _CurEdge = 0; _CurEdge < BoundPs.Num(); ++_CurEdge)
					{
						if (_CurEdge == BoundPs.Num() - 1)
						{
							NextEdge = 0;
						}
						else
						{
							NextEdge = _CurEdge + 1;
						}
						float TempDis = FMath::PointDistToSegment(FVector(TempWindowCenter2D, 0), FVector(BoundPs[_CurEdge], 0), FVector(BoundPs[NextEdge], 0));
						if (TempDis <= 20)
						{
							RemovedEdgeIndexs.AddUnique(_CurEdge);
						}
					}
				}
			}
			/////////////////////设置区域内边界附近的布灯位置/////////////////////////////////////
			for (int _CurE = 0; _CurE < BoundPs.Num(); ++_CurE)
			{
				if (!RemovedEdgeIndexs.Contains(_CurE))
				{
					if (_CurE == BoundPs.Num() - 1)
					{
						NextEdge = 0;
					}
					else
					{
						NextEdge = _CurE + 1;
					}
					FVector2D StartVec = SuitableCenter - BoundPs[_CurE];
					FVector2D EndVec = SuitableCenter - BoundPs[NextEdge];
					StartVec.Normalize();
					EndVec.Normalize();
					FVector2D StartP = BoundPs[_CurE] + ShrinkLength * StartVec;
					FVector2D EndP = BoundPs[NextEdge] + ShrinkLength * EndVec;
					FVector2D TempExtendVec = EndP - StartP;
					TempExtendVec.Normalize();
					float DisOfEdge = FVector2D::Distance(StartP, EndP);
					int NumToAdd = (int)((DisOfEdge) / EqualLightSpace);
					if ((DisOfEdge <= 150) || (NumToAdd <= 2))
					{
						TempLights.AddUnique(0.5*(StartP + EndP));
					}
					else
					{
						if (NumToAdd >= 3)
						{

							int NumOfSide1 = (NumToAdd - 1) / 2;
							int NumOfSide2 = NumToAdd - 1 - NumOfSide1;
							TempLights.AddUnique(0.5*(StartP + EndP));
							////////计算Side1的灯的位置/////////////////////
							for (int _CurI = 0; _CurI < NumOfSide1; ++_CurI)
							{
								FVector2D TempLightOfSide1 = 0.5*(StartP + EndP) + (_CurI + 1)*EqualLightSpace * TempExtendVec;
								TempLights.AddUnique(TempLightOfSide1);
							}
							/////////计算Side2的灯的位置//////////////////
							for (int _CurJ = 0; _CurJ < NumOfSide2; ++_CurJ)
							{
								FVector2D TempLightOfSide2 = 0.5*(StartP + EndP) - (_CurJ + 1)*EqualLightSpace*TempExtendVec;
								TempLights.AddUnique(TempLightOfSide2);
							}
						}
					}
				}
			}
		}
		else
		{
			float MinX = OutPnts[0].X;
			float MaxX = OutPnts[0].X;
			float MinY = OutPnts[0].Y;
			float MaxY = OutPnts[0].Y;
			for (int _CurP = 0; _CurP < OutPnts.Num(); ++_CurP)
			{
				if (MinX > OutPnts[_CurP].X)
				{
					MinX = OutPnts[_CurP].X;
				}
				if (MaxX < OutPnts[_CurP].X)
				{
					MaxX = OutPnts[_CurP].X;
				}
				if (MinY > OutPnts[_CurP].Y)
				{
					MinY = OutPnts[_CurP].Y;
				}
				if (MaxY < OutPnts[_CurP].Y)
				{
					MaxY = OutPnts[_CurP].Y;
				}
			}
			FVector2D PLeftUp = FVector2D(MinX, MaxY);
			FVector2D PLeftDown = FVector2D(MinX, MinY);
			FVector2D PRightDown = FVector2D(MaxX, MinY);
			FVector2D PRightUp = FVector2D(MaxX, MaxY);
			FVector2D TempCenter = 0.25*(PLeftUp + PLeftDown + PRightDown + PRightUp);
			if (FPolygonAlg::JudgePointInPolygon(OutPnts, TempCenter))
			{
				SuitableCenter = TempCenter;
				float Distance1 = FVector2D::Distance(PLeftUp, SuitableCenter);
				float Distance2 = FVector2D::Distance(PLeftDown, SuitableCenter);
				float Distance3 = FVector2D::Distance(PRightDown, SuitableCenter);
				float Distance4 = FVector2D::Distance(PRightUp, SuitableCenter);
				float ShrinkAge1 = (Distance1 - ShrinkLength) / Distance1;
				float ShrinkAge2 = (Distance2 - ShrinkLength) / Distance2;
				float ShrinkAge3 = (Distance3 - ShrinkLength) / Distance3;
				float ShrinkAge4 = (Distance4 - ShrinkLength) / Distance4;
				FVector2D UpdateOutPnt1 = (1 - ShrinkAge1)*SuitableCenter + ShrinkAge1 * PLeftUp;
				FVector2D UpdateOutPnt2 = (1 - ShrinkAge2)*SuitableCenter + ShrinkAge2 * PLeftDown;
				FVector2D UpdateOutPnt3 = (1 - ShrinkAge3)*SuitableCenter + ShrinkAge3 * PRightDown;
				FVector2D UpdateOutPnt4 = (1 - ShrinkAge4)*SuitableCenter + ShrinkAge4 * PRightUp;

				//////////////////////结合门洞以及窗洞信息计算/////////////////////////////////////////////
				TArray<FVector2D> TempBoundPs;
				TempBoundPs.Add(UpdateOutPnt1);
				TempBoundPs.Add(UpdateOutPnt2);
				TempBoundPs.Add(UpdateOutPnt3);
				TempBoundPs.Add(UpdateOutPnt4);

				int NumOfDoors = DoorPoints.Num() / 8;
				int NumOfWindows = WindowPoints.Num() / 8;
				TArray<int> RemovedEdgeIndexs;
				int NextEdge = 0;
				if (NumOfDoors > 0)
				{
					for (int _CurDoor = 0; _CurDoor < NumOfDoors; ++_CurDoor)
					{
						FVector TempDir = DoorPoints[8 * _CurDoor + 1] - DoorPoints[8 * _CurDoor];
						TempDir.Normalize();
						FVector2D TempDir2D = FVector2D(TempDir);
						FVector2D TempRotatedDir = TempDir2D.GetRotated(90);
						FVector TempDoorCenter = 0.25*(DoorPoints[8 * _CurDoor] + DoorPoints[8 * _CurDoor + 1] + DoorPoints[8 * _CurDoor + 2] + DoorPoints[8 * _CurDoor + 3]);
						FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter);
						///////////////////////////剔除靠近门洞的区域内边界////////////////////////////
						for (int _CurEdge = 0; _CurEdge < TempBoundPs.Num(); ++_CurEdge)
						{
							if (_CurEdge == TempBoundPs.Num() - 1)
							{
								NextEdge = 0;
							}
							else
							{
								NextEdge = _CurEdge + 1;
							}
							float TempDis = FMath::PointDistToSegment(FVector(TempDoorCenter2D, 0), FVector(TempBoundPs[_CurEdge], 0), FVector(TempBoundPs[NextEdge], 0));
							if (TempDis <= 30)
							{
								RemovedEdgeIndexs.AddUnique(_CurEdge);
							}
						}
					}
				}

				if (NumOfWindows > 0)
				{
					for (int _CurWindow = 0; _CurWindow < NumOfWindows; ++_CurWindow)
					{
						FVector TempDir = WindowPoints[8 * _CurWindow + 1] - WindowPoints[8 * _CurWindow];
						TempDir.Normalize();
						FVector2D TempDir2D = FVector2D(TempDir);
						FVector2D TempRotatedDir = TempDir2D.GetRotated(90);
						FVector TempWindowCenter = 0.25*(WindowPoints[8 * _CurWindow] + WindowPoints[8 * _CurWindow + 1] + WindowPoints[8 * _CurWindow + 2] + WindowPoints[8 * _CurWindow + 3]);
						FVector2D TempWindowCenter2D = FVector2D(TempWindowCenter);
						///////////////////////////剔除靠近窗洞的区域内边界////////////////////////////
						for (int _CurEdge = 0; _CurEdge < TempBoundPs.Num(); ++_CurEdge)
						{
							if (_CurEdge == TempBoundPs.Num() - 1)
							{
								NextEdge = 0;
							}
							else
							{
								NextEdge = _CurEdge + 1;
							}
							float TempDis = FMath::PointDistToSegment(FVector(TempWindowCenter2D, 0), FVector(TempBoundPs[_CurEdge], 0), FVector(TempBoundPs[NextEdge], 0));
							if (TempDis <= 30)
							{
								RemovedEdgeIndexs.AddUnique(_CurEdge);
							}
						}
					}
				}
				/////////////////////设置区域内边界附近的布灯位置/////////////////////////////////////
				for (int _CurE = 0; _CurE < TempBoundPs.Num(); ++_CurE)
				{
					if (!RemovedEdgeIndexs.Contains(_CurE))
					{
						if (_CurE == TempBoundPs.Num() - 1)
						{
							NextEdge = 0;
						}
						else
						{
							NextEdge = _CurE + 1;
						}
						FVector2D StartVec = TempCenter - TempBoundPs[_CurE];
						FVector2D EndVec = TempCenter - TempBoundPs[NextEdge];
						StartVec.Normalize();
						EndVec.Normalize();
						FVector2D StartP = TempBoundPs[_CurE] + ShrinkLength * StartVec;
						FVector2D EndP = TempBoundPs[NextEdge] + ShrinkLength * EndVec;
						FVector2D TempExtendVec = EndP - StartP;
						TempExtendVec.Normalize();
						float DisOfEdge = FVector2D::Distance(StartP, EndP);
						int NumToAdd = (int)((DisOfEdge) / EqualLightSpace);
						if ((DisOfEdge <= 150) || (NumToAdd <= 2))
						{
							TempLights.AddUnique(0.5*(StartP + EndP));
						}
						else
						{
							if (NumToAdd >= 3)
							{

								int NumOfSide1 = (NumToAdd - 1) / 2;
								int NumOfSide2 = NumToAdd - 1 - NumOfSide1;
								TempLights.AddUnique(0.5*(StartP + EndP));
								////////计算Side1的灯的位置/////////////////////
								for (int _CurI = 0; _CurI < NumOfSide1; ++_CurI)
								{
									FVector2D TempLightOfSide1 = 0.5*(StartP + EndP) + (_CurI + 1)*EqualLightSpace * TempExtendVec;
									TempLights.AddUnique(TempLightOfSide1);
								}
								/////////计算Side2的灯的位置//////////////////
								for (int _CurJ = 0; _CurJ < NumOfSide2; ++_CurJ)
								{
									FVector2D TempLightOfSide2 = 0.5*(StartP + EndP) - (_CurJ + 1)*EqualLightSpace*TempExtendVec;
									TempLights.AddUnique(TempLightOfSide2);
								}
							}
						}
					}
				}
			}
		}
	}
	for (int _CurL = 0; _CurL < TempLights.Num(); ++_CurL)
	{
		if (FPolygonAlg::JudgePointInPolygon(OutPnts, TempLights[_CurL]))
		{
			LightsLoc.AddUnique(FVector(TempLights[_CurL], WallHeight - ReduceHeight));
		}
	}
	return true;
}


bool UWriteMeshObj_FunctionLibrary::LocateRTXLightsOfNormalRoom(UObject* WorldContextObject, const TArray<FVector2D> InPnts, const int RoomID, TArray<FVector>&LightsLoc, const float WallHeight,
	const float ReduceHeight)
{
	FVector2D LocalCenter;
	TArray<FVector2D>  OutPnts, TempLights;
	const float ShrinkLength = 10 * sqrt(2);
	const float EqualLightSpace = 100.0f;
	bool MergeCollinearSuccess = FPolygonAlg::MergeCollinearPoints(InPnts, OutPnts);
	if (!MergeCollinearSuccess)
	{
		return false;
	}
	TArray<FVector> DoorPoints, WindowPoints;
	bool GetDoorSuccess = GetDoorsOfRegion(WorldContextObject, RoomID, DoorPoints);
	bool GetWindowSuccess = GetWindowsOfRegion(WorldContextObject, RoomID, WindowPoints);
	if (OutPnts.Num() <= 3)
	{
		return false;
	}
	else
	{
		bool IsLocated = FPolygonAlg::LocateSuitableCenter(InPnts, LocalCenter);
		if (IsLocated)
		{
			//////////////////////结合门洞以及窗洞信息计算/////////////////////////////////////////////
			int NumOfDoors = DoorPoints.Num() / 8;
			int NumOfWindows = WindowPoints.Num() / 8;
			TArray<int> RemovedEdgeIndexs;
			int NextEdge = 0;
			if (NumOfDoors > 0)
			{
				for (int _CurDoor = 0; _CurDoor < NumOfDoors; ++_CurDoor)
				{
					FVector TempDir = DoorPoints[8 * _CurDoor + 1] - DoorPoints[8 * _CurDoor];
					TempDir.Normalize();
					FVector2D TempDir2D = FVector2D(TempDir);
					FVector2D TempRotatedDir = TempDir2D.GetRotated(90);
					FVector TempDoorCenter = 0.25*(DoorPoints[8 * _CurDoor] + DoorPoints[8 * _CurDoor + 1] + DoorPoints[8 * _CurDoor + 2] + DoorPoints[8 * _CurDoor + 3]);
					FVector2D TempDoorCenter2D = FVector2D(TempDoorCenter);
					///////////////////////////剔除靠近门洞的区域内边界////////////////////////////
					for (int _CurEdge = 0; _CurEdge < OutPnts.Num(); ++_CurEdge)
					{
						if (_CurEdge == OutPnts.Num() - 1)
						{
							NextEdge = 0;
						}
						else
						{
							NextEdge = _CurEdge + 1;
						}
						float TempDis = FMath::PointDistToSegment(FVector(TempDoorCenter2D, 0), FVector(OutPnts[_CurEdge], 0), FVector(OutPnts[NextEdge], 0));
						if (TempDis <= 20)
						{
							RemovedEdgeIndexs.AddUnique(_CurEdge);
						}
					}
				}
			}

			if (NumOfWindows > 0)
			{
				for (int _CurWindow = 0; _CurWindow < NumOfWindows; ++_CurWindow)
				{
					FVector TempDir = WindowPoints[8 * _CurWindow + 1] - WindowPoints[8 * _CurWindow];
					TempDir.Normalize();
					FVector2D TempDir2D = FVector2D(TempDir);
					FVector2D TempRotatedDir = TempDir2D.GetRotated(90);
					FVector TempWindowCenter = 0.25*(WindowPoints[8 * _CurWindow] + WindowPoints[8 * _CurWindow + 1] + WindowPoints[8 * _CurWindow + 2] + WindowPoints[8 * _CurWindow + 3]);
					FVector2D TempWindowCenter2D = FVector2D(TempWindowCenter);
					///////////////////////////剔除靠近窗洞的区域内边界////////////////////////////
					for (int _CurEdge = 0; _CurEdge < OutPnts.Num(); ++_CurEdge)
					{
						if (_CurEdge == OutPnts.Num() - 1)
						{
							NextEdge = 0;
						}
						else
						{
							NextEdge = _CurEdge + 1;
						}
						float TempDis = FMath::PointDistToSegment(FVector(TempWindowCenter2D, 0), FVector(OutPnts[_CurEdge], 0), FVector(OutPnts[NextEdge], 0));
						if (TempDis <= 20)
						{
							RemovedEdgeIndexs.AddUnique(_CurEdge);
						}
					}
				}
			}
			/////////////////////设置区域内边界附近的布灯位置/////////////////////////////////////
			for (int _CurE = 0; _CurE < OutPnts.Num(); ++_CurE)
			{
				if (!RemovedEdgeIndexs.Contains(_CurE))
				{
					if (_CurE == OutPnts.Num() - 1)
					{
						NextEdge = 0;
					}
					else
					{
						NextEdge = _CurE + 1;
					}
					FVector2D StartVec = LocalCenter - OutPnts[_CurE];
					FVector2D EndVec = LocalCenter - OutPnts[NextEdge];
					StartVec.Normalize();
					EndVec.Normalize();
					FVector2D StartP = OutPnts[_CurE] + ShrinkLength * StartVec;
					FVector2D EndP = OutPnts[NextEdge] + ShrinkLength * EndVec;
					FVector2D TempExtendVec = EndP - StartP;
					TempExtendVec.Normalize();
					float DisOfEdge = FVector2D::Distance(StartP, EndP);
					int NumToAdd = (int)((DisOfEdge) / EqualLightSpace);
					if ((DisOfEdge <= 150) || (NumToAdd <= 2))
					{
						TempLights.AddUnique(0.5*(StartP + EndP));
					}
					else
					{
						if (NumToAdd >= 3)
						{

							int NumOfSide1 = (NumToAdd - 1) / 2;
							int NumOfSide2 = NumToAdd - 1 - NumOfSide1;
							TempLights.AddUnique(0.5*(StartP + EndP));
							////////计算Side1的灯的位置/////////////////////
							for (int _CurI = 0; _CurI < NumOfSide1; ++_CurI)
							{
								FVector2D TempLightOfSide1 = 0.5*(StartP + EndP) + (_CurI + 1)*EqualLightSpace * TempExtendVec;
								TempLights.AddUnique(TempLightOfSide1);
							}
							/////////计算Side2的灯的位置//////////////////
							for (int _CurJ = 0; _CurJ < NumOfSide2; ++_CurJ)
							{
								FVector2D TempLightOfSide2 = 0.5*(StartP + EndP) - (_CurJ + 1)*EqualLightSpace*TempExtendVec;
								TempLights.AddUnique(TempLightOfSide2);
							}
						}
					}
				}
			}
		}
		else
		{
			return false;
		}
	}
	for (int _CurL = 0; _CurL < TempLights.Num(); ++_CurL)
	{
		if (FPolygonAlg::JudgePointInPolygon(OutPnts, TempLights[_CurL]))
		{
			LightsLoc.AddUnique(FVector(TempLights[_CurL], WallHeight - ReduceHeight));
		}
	}
	return true;
}


bool UWriteMeshObj_FunctionLibrary::AutoMaticCreateLightsOfRTX(UObject* WorldContextObject, UVaRestJsonObject* InJson, FRegionLightsOfRTX& LightsOfVestibule, FRegionLightsOfRTX& LightsOfOthers, const float ReduceHeight)
{
	if (InJson == nullptr)
	{
		return false;
	}

	TArray<FOldSceneLights>OldLightsArr;
	TArray<UVaRestJsonObject*> WallJsonObj = InJson->GetObjectArrayField("walls");
	TArray<Polygon_2> WallPolygon;
	TArray<FVector2D> WallCenters;
	TMap<int, TArray<FVector2D>> IndexMapWallPs;
	float WallHeight = 280;
	for (int Index = 0; Index < WallJsonObj.Num(); Index++)
	{
		TArray<FVector2D> WallRegionPoints;
		TArray<UVaRestJsonObject*> EachWallRegion = WallJsonObj[Index]->GetObjectArrayField("wallPoints");

		for (int WallIndex = 0; WallIndex < EachWallRegion.Num(); WallIndex++)
		{
			float TempZ = EachWallRegion[WallIndex]->GetNumberField("z");
			if (TempZ != 0.0)
			{
				WallHeight = TempZ;
				break;
			}
		}

		for (int WallIndex = 0; WallIndex < EachWallRegion.Num(); WallIndex++)
		{
			float TempX = EachWallRegion[WallIndex]->GetNumberField("x");
			float TempY = EachWallRegion[WallIndex]->GetNumberField("y");

			WallRegionPoints.Add(FVector2D(TempX, TempY));
		}
		Polygon_2 TempWallPolygon;
		float WallCenterX = 0.0, WallCenterY = 0.0;
		for (int PIndex = 0; PIndex < 4; PIndex++)
		{
			TempWallPolygon.push_back(Point_2(WallRegionPoints[PIndex].X, WallRegionPoints[PIndex].Y));
			WallCenterX = WallCenterX + WallRegionPoints[PIndex].X;
			WallCenterY = WallCenterY + WallRegionPoints[PIndex].Y;
		}
		WallCenterX = WallCenterX / 4;
		WallCenterY = WallCenterY / 4;
		WallCenters.Add(FVector2D(WallCenterX, WallCenterY));
		IndexMapWallPs.Add(Index, WallRegionPoints);
		WallPolygon.Add(TempWallPolygon);
		TempWallPolygon.clear();
	}


	TArray<FString> RoomNameSet, RoomUsageNameSet;
	TArray<int> RoomIDs;
	TArray<UVaRestJsonObject*> RoomJsonObj = InJson->GetObjectArrayField("roomList");

	TMap<int, TArray<FVector2D>> RoomIDMapRoomPs;
	TArray<int> RoomIDsToRemove;


	TArray<FVector2D> LivingRoomPs, DiningRoomPs, ThirdRoomPs, FourthRoomPs;

	TArray<FVector> LivingRegionLights, DiningRegionLights, ThirdLights, FourthLights;

	int LivingRoomID, DiningRoomID, ThirdRoomID, FourthRoomID;


	float CuttingHeight = ReduceHeight;
	const float FilterDisBound = 20.0;
	bool IsLiving = false;
	bool IsDining = false;
	for (int Index = 0; Index < RoomJsonObj.Num(); Index++)
	{
		TArray<FVector2D> AreaPoints;

		TArray<FVector>LightsLoc;
		TArray<UVaRestJsonObject*> AreaCoorJson = RoomJsonObj[Index]->GetObjectArrayField("areas");

		FString TempRoomNameString = RoomJsonObj[Index]->GetStringField("roomName");
		RoomNameSet.Add(TempRoomNameString);

		int TempRoomID = RoomJsonObj[Index]->GetIntegerField("roomId");
		RoomIDs.Add(TempRoomID);

		for (int AreaIndex = 0; AreaIndex < AreaCoorJson.Num(); AreaIndex++)
		{
			float TempX = AreaCoorJson[AreaIndex]->GetNumberField("x");
			float TempY = AreaCoorJson[AreaIndex]->GetNumberField("y");
			AreaPoints.Add(FVector2D(TempX, TempY));
		}

		RoomIDMapRoomPs.Add(TempRoomID, AreaPoints);

		FString LocalRoomName = RoomJsonObj[Index]->GetStringField("roomName");

		CuttingHeight = RoomJsonObj[Index]->GetNumberField("ReduceHeight");
		if (CuttingHeight != 0)
		{
			CuttingHeight = CuttingHeight + 10;
		}
		else
		{
			CuttingHeight = ReduceHeight + 35;
		}

		if ((LocalRoomName == TEXT("客厅")) || (LocalRoomName == TEXT("起居室")))
		{
			if (!IsLiving)
			{
				IsLiving = true;
				LivingRoomID = TempRoomID;
				bool IsSuccess = LocateRTXLightsOfDiningOrLivingRegion(WorldContextObject, AreaPoints, TempRoomID, LightsLoc, WallHeight, ReduceHeight);
				TArray<AFurnitureModelActor*> ModelsInRegion;
				FindModelsOfRoom(WorldContextObject, AreaPoints, ModelsInRegion);
				TArray<int> LocalRemoveIndexs;
				if (IsSuccess)
				{
					for (int _CurLight = 0; _CurLight < LightsLoc.Num(); ++_CurLight)
					{
						if (ModelsInRegion.Num() != 0)
						{
							for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
							{
								FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
								bool IfInModel = TempBox.IsInsideOrOn(LightsLoc[_CurLight]);
								if (IfInModel)
								{
									FVector FMin = TempBox.Min;
									FVector FMax = TempBox.Max;
									bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
									if (ModelBoxIsUseful)
									{
										LocalRemoveIndexs.AddUnique(_CurLight);
									}
								}
							}
						}
					}
					LivingRoomPs = AreaPoints;
				}
				for (int _CurLight = 0; _CurLight < LightsLoc.Num(); ++_CurLight)
				{

					if (!LocalRemoveIndexs.Contains(_CurLight))
					{
						FIntelligentLight LocalLight;
						LocalLight.Loc = LightsLoc[_CurLight];
						if (FPolygonAlg::JudgePointInPolygon(AreaPoints, FVector2D(LightsLoc[_CurLight])))
						{
							LightsOfOthers.LightInfo.Add(LocalLight);
						}
					}
				}
			}
			else
			{
				ThirdRoomID = TempRoomID;
				bool IsSuccess = LocateRTXLightsOfDiningOrLivingRegion(WorldContextObject, AreaPoints, TempRoomID, LightsLoc, WallHeight, ReduceHeight);
				TArray<AFurnitureModelActor*> ModelsInRegion;
				FindModelsOfRoom(WorldContextObject, AreaPoints, ModelsInRegion);
				if (IsSuccess)
				{

					TArray<int> LocalRemoveIndexs;
					for (int _CurLight = 0; _CurLight < LightsLoc.Num(); ++_CurLight)
					{
						if (ModelsInRegion.Num() != 0)
						{
							for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
							{
								FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
								bool IfInModel = TempBox.IsInsideOrOn(LightsLoc[_CurLight]);
								if (IfInModel)
								{
									FVector FMin = TempBox.Min;
									FVector FMax = TempBox.Max;
									bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
									if (ModelBoxIsUseful)
									{
										LocalRemoveIndexs.AddUnique(_CurLight);
									}
								}
							}
						}

					}
					for (int _CurLight = 0; _CurLight < LightsLoc.Num(); ++_CurLight)
					{

						if (!LocalRemoveIndexs.Contains(_CurLight))
						{
							FIntelligentLight LocalLight;
							LocalLight.Loc = LightsLoc[_CurLight];
							if (FPolygonAlg::JudgePointInPolygon(AreaPoints, FVector2D(LightsLoc[_CurLight])))
							{
								LightsOfOthers.LightInfo.Add(LocalLight);
							}
						}
					}
					ThirdRoomPs = AreaPoints;
				}
			}
		}
		else if (LocalRoomName == TEXT("餐厅"))
		{
			if (!IsDining)
			{
				IsDining = true;
				DiningRoomID = TempRoomID;
				bool IsSuccess = LocateRTXLightsOfDiningOrLivingRegion(WorldContextObject, AreaPoints, TempRoomID, LightsLoc, WallHeight, ReduceHeight);

				TArray<AFurnitureModelActor*> ModelsInRegion;
				FindModelsOfRoom(WorldContextObject, AreaPoints, ModelsInRegion);

				if (IsSuccess)
				{
					TArray<int> LocalRemoveIndexs;
					for (int _CurLight = 0; _CurLight < LightsLoc.Num(); ++_CurLight)
					{

						if (ModelsInRegion.Num() != 0)
						{
							for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
							{
								FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
								bool IfInModel = TempBox.IsInsideOrOn(LightsLoc[_CurLight]);
								if (IfInModel)
								{
									FVector FMin = TempBox.Min;
									FVector FMax = TempBox.Max;
									bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
									if (ModelBoxIsUseful)
									{
										LocalRemoveIndexs.AddUnique(_CurLight);
									}
								}

							}
						}

					}
					for (int _CurLight = 0; _CurLight < LightsLoc.Num(); ++_CurLight)
					{

						if (!LocalRemoveIndexs.Contains(_CurLight))
						{
							FIntelligentLight LocalLight;
							LocalLight.Loc = LightsLoc[_CurLight];
							if (FPolygonAlg::JudgePointInPolygon(AreaPoints, FVector2D(LightsLoc[_CurLight])))
							{
								LightsOfOthers.LightInfo.Add(LocalLight);
							}
						}
					}
					DiningRoomPs = AreaPoints;
				}
			}
			else
			{
				FourthRoomID = TempRoomID;
				bool IsSuccess = LocateRTXLightsOfDiningOrLivingRegion(WorldContextObject, AreaPoints, TempRoomID, LightsLoc, WallHeight, ReduceHeight);
				TArray<AFurnitureModelActor*> ModelsInRegion;
				FindModelsOfRoom(WorldContextObject, AreaPoints, ModelsInRegion);
				if (IsSuccess)
				{

					TArray<int> LocalRemoveIndexs;
					for (int _CurLight = 0; _CurLight < LightsLoc.Num(); ++_CurLight)
					{
						if (ModelsInRegion.Num() != 0)
						{
							for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
							{
								FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
								bool IfInModel = TempBox.IsInsideOrOn(LightsLoc[_CurLight]);
								if (IfInModel)
								{
									FVector FMin = TempBox.Min;
									FVector FMax = TempBox.Max;
									bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
									if (ModelBoxIsUseful)
									{
										LocalRemoveIndexs.AddUnique(_CurLight);
									}
								}
							}
						}
					}
					for (int _CurLight = 0; _CurLight < LightsLoc.Num(); ++_CurLight)
					{

						if (!LocalRemoveIndexs.Contains(_CurLight))
						{
							FIntelligentLight LocalLight;
							LocalLight.Loc = LightsLoc[_CurLight];
							if (FPolygonAlg::JudgePointInPolygon(AreaPoints, FVector2D(LightsLoc[_CurLight])))
							{
								LightsOfOthers.LightInfo.Add(LocalLight);
							}
						}
					}
					FourthRoomPs = AreaPoints;
				}
			}
		}
		else if ((LocalRoomName == TEXT("主卧")) || (LocalRoomName == TEXT("次卧")) || (LocalRoomName == TEXT("儿童房")) || (LocalRoomName == TEXT("老人房"))
			|| (LocalRoomName == TEXT("榻榻米房")) || (LocalRoomName == TEXT("客人房")) || (LocalRoomName == TEXT("书房")) || (LocalRoomName == TEXT("健身房"))
			|| (LocalRoomName == TEXT("多功能房")))
		{

			TArray<FVector2D> TempSmallCenters;
			TMap<FVector2D, TArray<FVector2D>> TempCenterMapLocalRegions;
			bool IsCreated = LocateRTXLightsOfRoom(WorldContextObject, AreaPoints, TempRoomID, LightsLoc, WallHeight, ReduceHeight);
			TArray<AFurnitureModelActor*> ModelsInRegion;
			FindModelsOfRoom(WorldContextObject, AreaPoints, ModelsInRegion);
			if (IsCreated)
			{
				TArray<int> LocalRemoveIndexs;
				for (int _CurLight = 0; _CurLight < LightsLoc.Num(); ++_CurLight)
				{
					if (ModelsInRegion.Num() != 0)
					{
						for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
						{
							FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
							bool IfInModel = TempBox.IsInsideOrOn(LightsLoc[_CurLight]);
							if (IfInModel)
							{
								FVector FMin = TempBox.Min;
								FVector FMax = TempBox.Max;
								bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
								if (ModelBoxIsUseful)
								{
									LocalRemoveIndexs.AddUnique(_CurLight);
								}
							}
						}
					}
				}
				for (int _CurLight = 0; _CurLight < LightsLoc.Num(); ++_CurLight)
				{

					if (!LocalRemoveIndexs.Contains(_CurLight))
					{
						FIntelligentLight LocalLight;
						LocalLight.Loc = LightsLoc[_CurLight];
						if (FPolygonAlg::JudgePointInPolygon(AreaPoints, FVector2D(LightsLoc[_CurLight])))
						{
							LightsOfOthers.LightInfo.Add(LocalLight);
						}
					}
				}

			}
		}
		else if ((LocalRoomName == TEXT("厨房")) || (LocalRoomName == TEXT("储藏间")) || (LocalRoomName == TEXT("衣帽间")) || (LocalRoomName == TEXT("茶室")))
		{
			bool IsCreated = LocateRTXLightsOfNormalRoom(WorldContextObject, AreaPoints, TempRoomID, LightsLoc, WallHeight, ReduceHeight);
			TArray<AFurnitureModelActor*> ModelsInRegion;
			FindModelsOfRoom(WorldContextObject, AreaPoints, ModelsInRegion);
			if (IsCreated)
			{
				TArray<int> LocalRemoveIndexs;
				for (int _CurLight = 0; _CurLight < LightsLoc.Num(); ++_CurLight)
				{
					if (ModelsInRegion.Num() != 0)
					{
						for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
						{
							FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
							bool IfInModel = TempBox.IsInsideOrOn(LightsLoc[_CurLight]);
							if (IfInModel)
							{
								FVector FMin = TempBox.Min;
								FVector FMax = TempBox.Max;
								bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
								if (ModelBoxIsUseful)
								{
									LocalRemoveIndexs.AddUnique(_CurLight);
								}
							}
						}
					}
				}
				for (int _CurLight = 0; _CurLight < LightsLoc.Num(); ++_CurLight)
				{

					if (!LocalRemoveIndexs.Contains(_CurLight))
					{
						FIntelligentLight LocalLight;
						LocalLight.Loc = LightsLoc[_CurLight];
						if (FPolygonAlg::JudgePointInPolygon(AreaPoints, FVector2D(LightsLoc[_CurLight])))
						{
							LightsOfOthers.LightInfo.Add(LocalLight);
						}
					}
				}
			}
		}
		else if ((LocalRoomName == TEXT("主卫")) || (LocalRoomName == TEXT("客卫")) || (LocalRoomName == TEXT("卫生间")))
		{
			bool FindWall = false;
			int TargetIndex = 0;
			for (int _CurIndex = 0; _CurIndex < WallCenters.Num(); ++_CurIndex)
			{
				bool JudgeIfInRegion = FPolygonAlg::JudgePointInPolygon(AreaPoints, WallCenters[_CurIndex]);
				if (JudgeIfInRegion)
				{
					FindWall = true;
					TargetIndex = _CurIndex;
					break;
				}
			}
			TArray<AFurnitureModelActor*> ModelsInRegion;
			FindModelsOfRoom(WorldContextObject, AreaPoints, ModelsInRegion);
			TArray<int> LocalRemoveIndexs;
			if (FindWall)
			{
				TArray<FVector2D> WallPoints = IndexMapWallPs[TargetIndex];
				bool LocateSuccess = FPolygonAlg::LocateLightsOfSecondToliet(AreaPoints, WallPoints, LightsLoc, WallHeight, CuttingHeight);

				if (LocateSuccess)
				{
					for (int _CurL = 0; _CurL < LightsLoc.Num(); ++_CurL)
					{
						FIntelligentLight LocalLight;
						LocalLight.Loc = LightsLoc[_CurL];
						if (ModelsInRegion.Num() != 0)
						{
							for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
							{
								FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
								bool IfInModel = TempBox.IsInsideOrOn(LocalLight.Loc);
								if (IfInModel)
								{
									FVector FMin = TempBox.Min;
									FVector FMax = TempBox.Max;
									bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
									if (ModelBoxIsUseful)
									{
										LocalRemoveIndexs.AddUnique(_CurL);
									}
								}

							}
						}
					}
				}
			}
			else
			{
				bool IsSuccess = FPolygonAlg::LocateTwoLightsOfOneToilet(AreaPoints, LightsLoc, WallHeight, CuttingHeight);
				if (IsSuccess)
				{
					for (int I = 0; I < LightsLoc.Num(); ++I)
					{
						FIntelligentLight LocalLight;
						LocalLight.Loc = LightsLoc[I];

						if (ModelsInRegion.Num() != 0)
						{
							for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
							{
								FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
								bool IfInModel = TempBox.IsInsideOrOn(LocalLight.Loc);
								if (IfInModel)
								{
									FVector FMin = TempBox.Min;
									FVector FMax = TempBox.Max;
									bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, AreaPoints);
									if (ModelBoxIsUseful)
									{
										LocalRemoveIndexs.AddUnique(I);
									}
								}

							}
						}
					}

				}
			}

			for (int _CurLight = 0; _CurLight < LightsLoc.Num(); ++_CurLight)
			{

				if (!LocalRemoveIndexs.Contains(_CurLight))
				{
					FIntelligentLight LocalLight;
					LocalLight.Loc = LightsLoc[_CurLight];
					if (FPolygonAlg::JudgePointInPolygon(AreaPoints, FVector2D(LightsLoc[_CurLight])))
					{
						LightsOfOthers.LightInfo.Add(LocalLight);
					}
				}
			}

		}
	}
	if ((LivingRoomPs.Num() != 0) && (DiningRoomPs.Num() != 0))
	{
		bool IfConnected1 = FPolygonAlg::JudgeHasClosePoint(LivingRoomPs, DiningRoomPs);
		if (IfConnected1)
		{
			int NumOfLivingPs = LivingRoomPs.Num();
			int NumOfDiningPs = DiningRoomPs.Num();
			TArray<FVector2D> TempAreaPs, LocalRegion;
			TArray<FVector> LocationOfLights, LocalLights;
			if (NumOfLivingPs > NumOfDiningPs)
			{
				TempAreaPs = LivingRoomPs;
				LocalRegion = DiningRoomPs;
			}
			else
			{
				TempAreaPs = DiningRoomPs;
				LocalRegion = LivingRoomPs;
			}
			//
			TArray<AFurnitureModelActor*> ModelsInRegion;
			FindModelsOfRoom(WorldContextObject, TempAreaPs, ModelsInRegion);

			bool IsSuccessful = FPolygonAlg::LocateLightsOfPassageAndVestibule(TempAreaPs, LocationOfLights, WallHeight, CuttingHeight);
			if (IsSuccessful)
			{
				TArray<FVector> UpdateLocationOfLights;
				bool FilterLocs = FPolygonAlg::FilterLights(LocationOfLights, TempAreaPs, UpdateLocationOfLights, FilterDisBound);
				if (FilterLocs)
				{
					TArray<int> LocalRemoveIndexs;
					for (int _CurLight = 0; _CurLight < UpdateLocationOfLights.Num(); ++_CurLight)
					{
						if (FPolygonAlg::JudgePointInPolygon(LivingRoomPs, FVector2D(UpdateLocationOfLights[_CurLight])))
						{
							if (ModelsInRegion.Num() != 0)
							{
								for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
								{
									FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
									bool IfInModel = TempBox.IsInsideOrOn(UpdateLocationOfLights[_CurLight]);
									if (IfInModel)
									{
										FVector FMin = TempBox.Min;
										FVector FMax = TempBox.Max;
										bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, TempAreaPs);
										if (ModelBoxIsUseful)
										{
											LocalRemoveIndexs.AddUnique(_CurLight);
										}

									}

								}
							}

							if (!LocalRemoveIndexs.Contains(_CurLight))
							{
								LivingRegionLights.AddUnique(UpdateLocationOfLights[_CurLight]);
							}
						}
						if (FPolygonAlg::JudgePointInPolygon(DiningRoomPs, FVector2D(UpdateLocationOfLights[_CurLight])))
						{
							if (ModelsInRegion.Num() != 0)
							{
								for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
								{
									FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
									bool IfInModel = TempBox.IsInsideOrOn(UpdateLocationOfLights[_CurLight]);
									if (IfInModel)
									{
										FVector FMin = TempBox.Min;
										FVector FMax = TempBox.Max;
										bool ModelBoxIsUseful = FPolygonAlg::JudgeModelBoxUseness(FMin, FMax, TempAreaPs);
										if (ModelBoxIsUseful)
										{
											LocalRemoveIndexs.AddUnique(_CurLight);
										}
									}

								}
							}

							if (!LocalRemoveIndexs.Contains(_CurLight))
							{
								DiningRegionLights.AddUnique(UpdateLocationOfLights[_CurLight]);
							}
						}
					}
				}

				///////////////////////////计算局部小区域的灯的位置//////////////////////
				TArray<int> LocalIndexs;
				TArray<FVector> LightsLocOfSmallRegion;
				bool LocateSuccess = FPolygonAlg::LocateLightsOfSmallRegion(LocalRegion, LightsLocOfSmallRegion, WallHeight, CuttingHeight);
				if (LocateSuccess)
				{
					TArray<FVector> UpdateLightsLocOfSmallRegion;
					bool FilterSuccess = FPolygonAlg::FilterLights(LightsLocOfSmallRegion, LocalRegion, UpdateLightsLocOfSmallRegion, FilterDisBound);
					if (FilterSuccess)
					{
						TArray<AFurnitureModelActor*> TempModelsInRegion;
						FindModelsOfRoom(WorldContextObject, LocalRegion, TempModelsInRegion);
						for (int _CurLight = 0; _CurLight < UpdateLightsLocOfSmallRegion.Num(); ++_CurLight)
						{
							if (FPolygonAlg::JudgePointInPolygon(LivingRoomPs, FVector2D(UpdateLightsLocOfSmallRegion[_CurLight])))
							{
								if (TempModelsInRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < TempModelsInRegion.Num(); ++_CurM)
									{
										FBox TempBox = TempModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(UpdateLightsLocOfSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalIndexs.AddUnique(_CurLight);
										}
									}
								}
								if (ModelsInRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
									{
										FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(UpdateLightsLocOfSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalIndexs.AddUnique(_CurLight);
										}

									}
								}
								if (!LocalIndexs.Contains(_CurLight))
								{
									LivingRegionLights.AddUnique(UpdateLightsLocOfSmallRegion[_CurLight]);
								}
							}

							if (FPolygonAlg::JudgePointInPolygon(DiningRoomPs, FVector2D(UpdateLightsLocOfSmallRegion[_CurLight])))
							{
								if (TempModelsInRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < TempModelsInRegion.Num(); ++_CurM)
									{
										FBox TempBox = TempModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(UpdateLightsLocOfSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalIndexs.AddUnique(_CurLight);
										}
									}
								}
								if (ModelsInRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
									{
										FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(UpdateLightsLocOfSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalIndexs.AddUnique(_CurLight);
										}

									}
								}
								if (!LocalIndexs.Contains(_CurLight))
								{
									DiningRegionLights.AddUnique(UpdateLightsLocOfSmallRegion[_CurLight]);
								}
							}

						}
					}

				}
			}

			else
			{
				TArray<int> LocalRemoveIndexs;
				TArray<FVector> LightsLocOfSmallRegion;
				bool LocateSuccess = FPolygonAlg::LocateLightsOfSmallRegion(TempAreaPs, LightsLocOfSmallRegion, WallHeight, CuttingHeight);
				if (LocateSuccess)
				{
					TArray<AFurnitureModelActor*> TempModelsInRegion;
					FindModelsOfRoom(WorldContextObject, LocalRegion, TempModelsInRegion);

					TArray<FVector> UpdateLightsLocOfSmallRegion;
					bool FilterPs = FPolygonAlg::FilterLights(LightsLocOfSmallRegion, TempAreaPs, UpdateLightsLocOfSmallRegion, FilterDisBound);
					if (FilterPs)
					{
						for (int _CurLight = 0; _CurLight < UpdateLightsLocOfSmallRegion.Num(); ++_CurLight)
						{
							if (FPolygonAlg::JudgePointInPolygon(LivingRoomPs, FVector2D(UpdateLightsLocOfSmallRegion[_CurLight])))
							{
								if (ModelsInRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
									{
										FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(UpdateLightsLocOfSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalRemoveIndexs.AddUnique(_CurLight);
										}

									}
								}
								if (TempModelsInRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < TempModelsInRegion.Num(); ++_CurM)
									{
										FBox TempBox = TempModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(UpdateLightsLocOfSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalRemoveIndexs.AddUnique(_CurLight);
										}
									}
								}
								if (!LocalRemoveIndexs.Contains(_CurLight))
								{
									LivingRegionLights.AddUnique(UpdateLightsLocOfSmallRegion[_CurLight]);
								}
							}
							if (FPolygonAlg::JudgePointInPolygon(DiningRoomPs, FVector2D(UpdateLightsLocOfSmallRegion[_CurLight])))
							{
								if (ModelsInRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
									{
										FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(UpdateLightsLocOfSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalRemoveIndexs.AddUnique(_CurLight);
										}

									}
								}
								if (TempModelsInRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < TempModelsInRegion.Num(); ++_CurM)
									{
										FBox TempBox = TempModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(UpdateLightsLocOfSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalRemoveIndexs.AddUnique(_CurLight);
										}
									}
								}
								if (!LocalRemoveIndexs.Contains(_CurLight))
								{
									DiningRegionLights.AddUnique(UpdateLightsLocOfSmallRegion[_CurLight]);
								}
							}
						}
					}


				}

				///////////////计算另一区域的小区域内的灯/////////////////////////////////////
				TArray<int> LocalIndexsOfOppoRegion;
				TArray<FVector> LightsOfOppoSmallRegion;
				bool IsSuccess = FPolygonAlg::LocateLightsOfSmallRegion(LocalRegion, LightsOfOppoSmallRegion, WallHeight, CuttingHeight);
				if (IsSuccess)
				{
					TArray<AFurnitureModelActor*> TempModelsOfOppoRegion;
					FindModelsOfRoom(WorldContextObject, LocalRegion, TempModelsOfOppoRegion);

					TArray<FVector> UpdateLightsOfOppoSmallRegion;
					bool FilterLightLocs = FPolygonAlg::FilterLights(LightsOfOppoSmallRegion, LocalRegion, UpdateLightsOfOppoSmallRegion, FilterDisBound);
					if (FilterLightLocs)
					{
						for (int _CurLight = 0; _CurLight < UpdateLightsOfOppoSmallRegion.Num(); ++_CurLight)
						{
							if (FPolygonAlg::JudgePointInPolygon(LivingRoomPs, FVector2D(UpdateLightsOfOppoSmallRegion[_CurLight])))
							{
								if (TempModelsOfOppoRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < TempModelsOfOppoRegion.Num(); ++_CurM)
									{
										FBox TempBox = TempModelsOfOppoRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(UpdateLightsOfOppoSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalIndexsOfOppoRegion.AddUnique(_CurLight);
										}

									}
								}
								if (ModelsInRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
									{
										FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(UpdateLightsOfOppoSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalIndexsOfOppoRegion.AddUnique(_CurLight);
										}

									}
								}
								if (!LocalIndexsOfOppoRegion.Contains(_CurLight))
								{
									LivingRegionLights.AddUnique(UpdateLightsOfOppoSmallRegion[_CurLight]);
								}
							}
							if (FPolygonAlg::JudgePointInPolygon(DiningRoomPs, FVector2D(UpdateLightsOfOppoSmallRegion[_CurLight])))
							{
								if (TempModelsOfOppoRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < TempModelsOfOppoRegion.Num(); ++_CurM)
									{
										FBox TempBox = TempModelsOfOppoRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(UpdateLightsOfOppoSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalIndexsOfOppoRegion.AddUnique(_CurLight);
										}

									}
								}

								if (ModelsInRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
									{
										FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(UpdateLightsOfOppoSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalIndexsOfOppoRegion.AddUnique(_CurLight);
										}

									}
								}

								if (!LocalIndexsOfOppoRegion.Contains(_CurLight))
								{
									DiningRegionLights.AddUnique(UpdateLightsOfOppoSmallRegion[_CurLight]);
								}
							}
						}
					}

				}

			}
		}
	}


	if ((ThirdRoomPs.Num() != 0) && (FourthRoomPs.Num() != 0))
	{
		bool IfConnected2 = FPolygonAlg::JudgeHasClosePoint(ThirdRoomPs, FourthRoomPs);
		if (IfConnected2)
		{
			int NumOfThirdPs = ThirdRoomPs.Num();
			int NumOfFourthPs = FourthRoomPs.Num();
			TArray<FVector2D> TempAreaPs, LocalRegion;
			TArray<FVector> LocationOfLights, LocalLights;
			if (NumOfThirdPs > NumOfFourthPs)
			{
				TempAreaPs = ThirdRoomPs;
				LocalRegion = FourthRoomPs;
			}
			else
			{
				TempAreaPs = FourthRoomPs;
				LocalRegion = ThirdRoomPs;
			}
			TArray<AFurnitureModelActor*> ModelsInRegion;
			FindModelsOfRoom(WorldContextObject, TempAreaPs, ModelsInRegion);

			bool IsSuccessful = FPolygonAlg::LocateLightsOfPassageAndVestibule(TempAreaPs, LocationOfLights, WallHeight, CuttingHeight);
			if (IsSuccessful)
			{
				TArray<int> LocalRemoveIndexs;
				for (int _CurLight = 0; _CurLight < LocationOfLights.Num(); ++_CurLight)
				{
					if (FPolygonAlg::JudgePointInPolygon(ThirdRoomPs, FVector2D(LocationOfLights[_CurLight])))
					{
						if (ModelsInRegion.Num() != 0)
						{
							for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
							{
								FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
								bool IfInModel = TempBox.IsInsideOrOn(LocationOfLights[_CurLight]);
								if (IfInModel)
								{
									LocalRemoveIndexs.AddUnique(_CurLight);
								}

							}
						}

						if (!LocalRemoveIndexs.Contains(_CurLight))
						{
							ThirdLights.AddUnique(LocationOfLights[_CurLight]);
						}
					}
					if (FPolygonAlg::JudgePointInPolygon(FourthRoomPs, FVector2D(LocationOfLights[_CurLight])))
					{
						if (ModelsInRegion.Num() != 0)
						{
							for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
							{
								FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
								bool IfInModel = TempBox.IsInsideOrOn(LocationOfLights[_CurLight]);
								if (IfInModel)
								{
									LocalRemoveIndexs.AddUnique(_CurLight);
								}

							}
						}

						if (!LocalRemoveIndexs.Contains(_CurLight))
						{
							FourthLights.AddUnique(LocationOfLights[_CurLight]);
						}
					}
				}
				///////////////////////////计算局部小区域的灯的位置//////////////////////
				TArray<int> LocalIndexs;
				TArray<FVector> LightsLocOfSmallRegion;
				bool LocateSuccess = FPolygonAlg::LocateLightsOfSmallRegion(LocalRegion, LightsLocOfSmallRegion, WallHeight, CuttingHeight);
				if (LocateSuccess)
				{
					TArray<AFurnitureModelActor*> TempModelsInRegion;
					FindModelsOfRoom(WorldContextObject, LocalRegion, TempModelsInRegion);
					for (int _CurLight = 0; _CurLight < LightsLocOfSmallRegion.Num(); ++_CurLight)
					{
						if (FPolygonAlg::JudgePointInPolygon(ThirdRoomPs, FVector2D(LightsLocOfSmallRegion[_CurLight])))
						{
							if (TempModelsInRegion.Num() != 0)
							{
								for (int _CurM = 0; _CurM < TempModelsInRegion.Num(); ++_CurM)
								{
									FBox TempBox = TempModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
									bool IfInModel = TempBox.IsInsideOrOn(LightsLocOfSmallRegion[_CurLight]);
									if (IfInModel)
									{
										LocalIndexs.AddUnique(_CurLight);
									}
								}
							}
							if (ModelsInRegion.Num() != 0)
							{
								for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
								{
									FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
									bool IfInModel = TempBox.IsInsideOrOn(LightsLocOfSmallRegion[_CurLight]);
									if (IfInModel)
									{
										LocalIndexs.AddUnique(_CurLight);
									}

								}
							}
							if (!LocalIndexs.Contains(_CurLight))
							{
								ThirdLights.AddUnique(LightsLocOfSmallRegion[_CurLight]);
							}
						}

						if (FPolygonAlg::JudgePointInPolygon(FourthRoomPs, FVector2D(LightsLocOfSmallRegion[_CurLight])))
						{
							if (TempModelsInRegion.Num() != 0)
							{
								for (int _CurM = 0; _CurM < TempModelsInRegion.Num(); ++_CurM)
								{
									FBox TempBox = TempModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
									bool IfInModel = TempBox.IsInsideOrOn(LightsLocOfSmallRegion[_CurLight]);
									if (IfInModel)
									{
										LocalIndexs.AddUnique(_CurLight);
									}
								}
							}
							if (ModelsInRegion.Num() != 0)
							{
								for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
								{
									FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
									bool IfInModel = TempBox.IsInsideOrOn(LightsLocOfSmallRegion[_CurLight]);
									if (IfInModel)
									{
										LocalIndexs.AddUnique(_CurLight);
									}

								}
							}
							if (!LocalIndexs.Contains(_CurLight))
							{
								FourthLights.AddUnique(LightsLocOfSmallRegion[_CurLight]);
							}
						}

					}
				}

			}
			else
			{
				TArray<int> LocalRemoveIndexs;
				TArray<FVector> LightsLocOfSmallRegion;
				bool LocateSuccess = FPolygonAlg::LocateLightsOfSmallRegion(TempAreaPs, LightsLocOfSmallRegion, WallHeight, CuttingHeight);
				if (LocateSuccess)
				{
					TArray<AFurnitureModelActor*> TempModelsInRegion;
					FindModelsOfRoom(WorldContextObject, LocalRegion, TempModelsInRegion);
					for (int _CurLight = 0; _CurLight < LightsLocOfSmallRegion.Num(); ++_CurLight)
					{
						if (FPolygonAlg::JudgePointInPolygon(ThirdRoomPs, FVector2D(LightsLocOfSmallRegion[_CurLight])))
						{
							if (ModelsInRegion.Num() != 0)
							{
								for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
								{
									FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
									bool IfInModel = TempBox.IsInsideOrOn(LightsLocOfSmallRegion[_CurLight]);
									if (IfInModel)
									{
										LocalRemoveIndexs.AddUnique(_CurLight);
									}

								}
							}
							if (TempModelsInRegion.Num() != 0)
							{
								for (int _CurM = 0; _CurM < TempModelsInRegion.Num(); ++_CurM)
								{
									FBox TempBox = TempModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
									bool IfInModel = TempBox.IsInsideOrOn(LightsLocOfSmallRegion[_CurLight]);
									if (IfInModel)
									{
										LocalRemoveIndexs.AddUnique(_CurLight);
									}
								}
							}
							if (!LocalRemoveIndexs.Contains(_CurLight))
							{
								{
									ThirdLights.AddUnique(LightsLocOfSmallRegion[_CurLight]);
								}
							}
							if (FPolygonAlg::JudgePointInPolygon(FourthRoomPs, FVector2D(LightsLocOfSmallRegion[_CurLight])))
							{
								if (ModelsInRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
									{
										FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(LightsLocOfSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalRemoveIndexs.AddUnique(_CurLight);
										}

									}
								}
								if (TempModelsInRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < TempModelsInRegion.Num(); ++_CurM)
									{
										FBox TempBox = TempModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(LightsLocOfSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalRemoveIndexs.AddUnique(_CurLight);
										}
									}
								}
								if (!LocalRemoveIndexs.Contains(_CurLight))
								{
									FourthLights.AddUnique(LightsLocOfSmallRegion[_CurLight]);
								}
							}
						}
					}

					///////////////计算另一区域的小区域内的灯/////////////////////////////////////
					TArray<int> LocalIndexsOfOppoRegion;
					TArray<FVector> LightsOfOppoSmallRegion;
					bool IsSuccess = FPolygonAlg::LocateLightsOfSmallRegion(LocalRegion, LightsOfOppoSmallRegion, WallHeight, CuttingHeight);
					if (IsSuccess)
					{
						TArray<AFurnitureModelActor*> TempModelsOfOppoRegion;
						FindModelsOfRoom(WorldContextObject, LocalRegion, TempModelsOfOppoRegion);
						for (int _CurLight = 0; _CurLight < LightsOfOppoSmallRegion.Num(); ++_CurLight)
						{
							if (FPolygonAlg::JudgePointInPolygon(ThirdRoomPs, FVector2D(LightsOfOppoSmallRegion[_CurLight])))
							{
								if (TempModelsOfOppoRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < TempModelsOfOppoRegion.Num(); ++_CurM)
									{
										FBox TempBox = TempModelsOfOppoRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(LightsOfOppoSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalIndexsOfOppoRegion.AddUnique(_CurLight);
										}

									}
								}
								if (ModelsInRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
									{
										FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(LightsOfOppoSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalIndexsOfOppoRegion.AddUnique(_CurLight);
										}

									}
								}
								if (!LocalIndexsOfOppoRegion.Contains(_CurLight))
								{
									ThirdLights.AddUnique(LightsOfOppoSmallRegion[_CurLight]);
								}
							}
							if (FPolygonAlg::JudgePointInPolygon(DiningRoomPs, FVector2D(LightsOfOppoSmallRegion[_CurLight])))
							{
								if (TempModelsOfOppoRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < TempModelsOfOppoRegion.Num(); ++_CurM)
									{
										FBox TempBox = TempModelsOfOppoRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(LightsOfOppoSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalIndexsOfOppoRegion.AddUnique(_CurLight);
										}

									}
								}

								if (ModelsInRegion.Num() != 0)
								{
									for (int _CurM = 0; _CurM < ModelsInRegion.Num(); ++_CurM)
									{
										FBox TempBox = ModelsInRegion[_CurM]->GetComponentsBoundingBox(true);
										bool IfInModel = TempBox.IsInsideOrOn(LightsOfOppoSmallRegion[_CurLight]);
										if (IfInModel)
										{
											LocalIndexsOfOppoRegion.AddUnique(_CurLight);
										}

									}
								}

								if (!LocalIndexsOfOppoRegion.Contains(_CurLight))
								{
									FourthLights.AddUnique(LightsOfOppoSmallRegion[_CurLight]);
								}
							}
						}
					}

				}
			}
		}
	}
	if (LivingRegionLights.Num() != 0)
	{
		for (int I = 0; I < LivingRegionLights.Num(); ++I)
		{
			FIntelligentLight LocalLight;
			LocalLight.Loc = LivingRegionLights[I];
			LightsOfVestibule.LightInfo.Add(LocalLight);
		}
	}

	if (DiningRegionLights.Num() != 0)
	{
		FRegionLights TempLights;
		for (int I = 0; I < DiningRegionLights.Num(); ++I)
		{
			FIntelligentLight LocalLight;
			LocalLight.Loc = DiningRegionLights[I];
			LightsOfVestibule.LightInfo.Add(LocalLight);
		}
	}

	if (ThirdLights.Num() != 0)
	{
		FRegionLights TempLights;
		for (int I = 0; I < ThirdLights.Num(); ++I)
		{
			FIntelligentLight LocalLight;
			LocalLight.Loc = ThirdLights[I];
			LightsOfVestibule.LightInfo.Add(LocalLight);
		}
	}

	if (FourthLights.Num() != 0)
	{
		FRegionLights TempLights;
		for (int I = 0; I < FourthLights.Num(); ++I)
		{
			FIntelligentLight LocalLight;
			LocalLight.Loc = FourthLights[I];
			LightsOfVestibule.LightInfo.Add(LocalLight);
		}
	}
	return true;
}


bool UWriteMeshObj_FunctionLibrary::LocateCentersOfMainDefense(UObject* WorldContextObject, const TArray<FVector2D>RegionPoints, const TArray<FVector2D>ShowerAreaPoints, TArray<FVector2D>&Centers)
{
	float LengthOfSide1 = FVector2D::Distance(ShowerAreaPoints[0], ShowerAreaPoints[1]);
	float LengthOfSide2 = FVector2D::Distance(ShowerAreaPoints[0], ShowerAreaPoints[3]);
	float Ratio1 = LengthOfSide1 / LengthOfSide2;
	float MaxRatio = Ratio1;
	if (Ratio1 < 1.0 / Ratio1)
	{
		MaxRatio = 1.0 / Ratio1;
	}
	if (MaxRatio > 5.0f)
	{
		FVector2D TempMiddle = 0.25*(ShowerAreaPoints[0] + ShowerAreaPoints[1] + ShowerAreaPoints[2] + ShowerAreaPoints[3]);
		FVector2D TempBaseDir = ShowerAreaPoints[1] - ShowerAreaPoints[0];
		if (LengthOfSide1 < LengthOfSide2)
		{
			TempBaseDir = ShowerAreaPoints[3] - ShowerAreaPoints[0];
		}
		TempBaseDir.Normalize();
		FVector2D TempRotatedDir = TempBaseDir.GetRotated(90);
		FVector2D TempInterSectP1, TempInterSectP2;
		bool IsGetted1 = FPolygonAlg::GetRayToInterSectP(RegionPoints, TempMiddle, TempRotatedDir, TempInterSectP1);
		bool IsGetted2 = FPolygonAlg::GetRayToInterSectP(RegionPoints, TempMiddle, -TempRotatedDir, TempInterSectP2);
		float L1 = FVector2D::Distance(TempMiddle, TempInterSectP1);
		float L2 = FVector2D::Distance(TempMiddle, TempInterSectP2);
		if (L1 > L2)
		{
			Centers.Add(0.5*(TempMiddle + TempInterSectP1));
			Centers.Add(0.5*(TempMiddle + TempInterSectP2));
		}
		else
		{
			Centers.Add(0.5*(TempMiddle + TempInterSectP2));
			Centers.Add(0.5*(TempMiddle + TempInterSectP1));
		}
	}
	else
	{
		int _CurNextE = 0;
		int TargetPIndex = 0;
		for (int _CurP = 0; _CurP < ShowerAreaPoints.Num(); ++_CurP)
		{
			float TempMaxDis = 0.0f;
			for (int _CurE = 0; _CurE < RegionPoints.Num(); ++_CurE)
			{
				if (_CurE == RegionPoints.Num() - 1)
				{
					_CurNextE = 0;
				}
				else
				{
					_CurNextE = _CurE + 1;
				}
				float TempDisToSeg = FMath::PointDistToSegment(FVector(ShowerAreaPoints[_CurP], 0.0), FVector(RegionPoints[_CurE], 0.0), FVector(RegionPoints[_CurNextE], 0.0));
				if ((TempMaxDis <= 1.0*10E-3) || (TempDisToSeg > TempMaxDis))
				{
					TempMaxDis = TempDisToSeg;
					TargetPIndex = _CurP;
				}
			}
		}
		int NextPIndex = 0, FrontPIndex = 0;
		if (TargetPIndex == 0)
		{
			NextPIndex = 1;
			FrontPIndex = 3;
		}
		else if (TargetPIndex == 1)
		{
			NextPIndex = 2;
			FrontPIndex = 0;
		}
		else if (TargetPIndex == 2)
		{
			NextPIndex = 3;
			FrontPIndex = 1;
		}
		else
		{
			NextPIndex = 0;
			FrontPIndex = 2;
		}
		FVector2D TempDir1 = ShowerAreaPoints[NextPIndex] - ShowerAreaPoints[TargetPIndex];
		FVector2D TempDir2 = ShowerAreaPoints[FrontPIndex] - ShowerAreaPoints[TargetPIndex];
		TempDir1.Normalize();
		TempDir2.Normalize();
		FVector2D TempSectP1, TempSectP2;
		bool IsSuccessful1 = FPolygonAlg::GetRayToInterSectP(RegionPoints, ShowerAreaPoints[TargetPIndex], TempDir1, TempSectP1);
		bool IsSuccessful2 = FPolygonAlg::GetRayToInterSectP(RegionPoints, ShowerAreaPoints[TargetPIndex], -TempDir1, TempSectP2);
		float TempLen1 = 0.0f;
		if ((IsSuccessful1) && (IsSuccessful2))
		{
			TempLen1 = FVector2D::Distance(TempSectP1, TempSectP2);
		}
		else
		{
			return false;
		}
		FVector2D TempSectP3, TempSectP4;
		bool IsSuccessful3 = FPolygonAlg::GetRayToInterSectP(RegionPoints, ShowerAreaPoints[TargetPIndex], TempDir2, TempSectP3);
		bool IsSuccessful4 = FPolygonAlg::GetRayToInterSectP(RegionPoints, ShowerAreaPoints[TargetPIndex], -TempDir2, TempSectP4);
		float TempLen2 = 0.0f;
		if ((IsSuccessful3) && (IsSuccessful4))
		{
			TempLen2 = FVector2D::Distance(TempSectP3, TempSectP4);
		}
		else
		{
			return false;
		}
		if (TempLen1 > TempLen2)
		{
			FVector2D UpdateMiddleP = 0.5*(TempSectP3 + TempSectP4);
			FVector2D MoveDir = TempDir2.GetRotated(90);
			FVector2D TempP1, TempP2;
			bool IsLoc1 = FPolygonAlg::GetRayToInterSectP(RegionPoints, UpdateMiddleP, MoveDir, TempP1);
			bool IsLoc2 = FPolygonAlg::GetRayToInterSectP(RegionPoints, UpdateMiddleP, -MoveDir, TempP2);
			if ((IsLoc1) && (IsLoc2))
			{
				float UpdateL1 = FVector2D::Distance(UpdateMiddleP, TempP1);
				float UpdateL2 = FVector2D::Distance(UpdateMiddleP, TempP2);
				if (UpdateL1 > UpdateL2)
				{
					Centers.Add(0.5*(UpdateMiddleP + TempP1));
				}
				else
				{
					Centers.Add(0.5*(UpdateMiddleP + TempP2));
				}
			}
			else
			{
				return false;
			}
		}
		else
		{
			FVector2D UpdateMiddleP = 0.5*(TempSectP1 + TempSectP2);
			FVector2D MoveDir = TempDir1.GetRotated(90);
			FVector2D TempP1, TempP2;
			bool IsLoc1 = FPolygonAlg::GetRayToInterSectP(RegionPoints, UpdateMiddleP, MoveDir, TempP1);
			bool IsLoc2 = FPolygonAlg::GetRayToInterSectP(RegionPoints, UpdateMiddleP, -MoveDir, TempP2);
			if ((IsLoc1) && (IsLoc2))
			{
				float UpdateL1 = FVector2D::Distance(UpdateMiddleP, TempP1);
				float UpdateL2 = FVector2D::Distance(UpdateMiddleP, TempP2);
				if (UpdateL1 > UpdateL2)
				{
					Centers.Add(0.5*(UpdateMiddleP + TempP1));
				}
				else
				{
					Centers.Add(0.5*(UpdateMiddleP + TempP2));
				}
			}
			else
			{
				return false;
			}
		}
		Centers.Add(0.25*(ShowerAreaPoints[0] + ShowerAreaPoints[1] + ShowerAreaPoints[2] + ShowerAreaPoints[3]));
	}
	return true;
}
